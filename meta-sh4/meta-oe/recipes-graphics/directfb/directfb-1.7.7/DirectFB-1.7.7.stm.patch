diff --git a/Makefile.am b/Makefile.am
index bd85528..fe22cf5 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -56,6 +56,7 @@ SUBDIRS = \
 	lib			\
 	src 			\
 	lib/++dfb		\
+	lib/wayland-dfb \
 	$(SAWMAN_DIR)		\
 	$(DIVINE_DIR)		\
 	$(DVC_DIR)		\
diff --git a/SPECS/stm-target-directfb.template b/SPECS/stm-target-directfb.template
new file mode 100644
index 0000000..d8c727f
--- /dev/null
+++ b/SPECS/stm-target-directfb.template
@@ -0,0 +1,786 @@
+%define _dfb_build_config	x@BUILD_CONFIG@
+
+Name:		%{_stm_pkg_prefix}-target-directfb@BUILD_CONFIG@
+Summary:	Hardware graphics acceleration library
+Group:		DirectFB/Libraries
+%define _dfbversion	1.7.7
+%define _abiversion	1.7-7
+%define _stmversion	+STM2016.01.26
+Version:	1.7.7%{_stmversion}
+Release:	1
+Epoch: 1
+License:	LGPL
+# created by:
+# git archive --format=tar --prefix=DirectFB-1.7.7/ DIRECTFB_1_7_7 | bzip2 --best > DirectFB-1.7.7.tar.bz2
+# git diff DIRECTFB_1_7_7..DIRECTFB_1_7_7_STM2016.01.26 | bzip2 --best > DirectFB-1.7.7.stm.patch.bz2
+# old way:
+# git archive --format=tar --prefix=DirectFB-1.6.1+STM2012.07.25/ DIRECTFB_1_6_1_STM2012.07.25 | bzip2 --best > DirectFB-1.6.1+STM2012.07.25.tar.bz2
+Source0:	DirectFB-%{_dfbversion}.tar.bz2
+Patch0:	DirectFB-%{_dfbversion}.stm.patch.bz2
+
+
+URL:		http://www.directfb.org
+Buildroot:	%(mktemp -ud %{_tmppath}/%{name}-%{version}-%{release}-%{_stm_target_arch}-XXXXXX)
+Prefix:		%{_stm_cross_target_dir}
+
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-libpng-dev
+BuildRequires: %{_stm_pkg_prefix}-host-fluxcomp >= 1.4.4
+%if %target_cpu arm sh
+BuildRequires: %{_stm_pkg_prefix}-host-wayland
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-libffi-dev
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-wayland-dev
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-libwayland-client-dev
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-libwayland-server-dev
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-mali-stubs-internal-dev
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-udev-dev
+%define _mme_enabled no
+%define _stmfbdev --enable-stmfbdev
+%define _dfb_wayland --enable-wayland
+%else
+%define _mme_enabled no
+%define _stmfbdev --disable-stmfbdev
+%define _dfb_wayland --disable-wayland
+%endif
+%if %target_cpu arm
+%define _multicore_enabled yes
+%else
+%define _multicore_enabled no
+%endif
+%if "%{_dfb_build_config}" == "x-multi"
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-linux-fusion-headers >= 9.0.3
+%define _dfb_multiapp --enable-multi
+%define _dfb_fusion_impl --enable-multi-kernel
+%else
+%if "%{_dfb_build_config}" == "x"
+%define _dfb_multiapp --disable-multi
+%define _dfb_fusion_impl --disable-multi-kernel
+%else
+# unsupported, error out
+unsupported BUILD_CONFIG option
+%endif
+%endif
+
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-fusiondale
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-fusiondale-dev
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman-bin
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman-dev
+
+%define _pkgname	%{_stm_pkg_prefix}-%{_stm_target_arch}-directfb
+%define _fullname	directfb-%{_abiversion}
+%define _docdir		%{_stm_cross_target_dir}%{_stm_target_doc_dir}
+
+#
+#  SRPM Package
+#
+%description
+The source package for DirectFB.
+
+#
+#  RPMS
+#
+%package -n %{_pkgname}@BUILD_CONFIG@
+Summary:	Hardware graphics acceleration library
+Group:		DirectFB/Libraries
+Provides:	%{_pkgname} = %{version}-%{release}
+
+%if "%{_dfb_build_config}" == "x-multi"
+Provides:	%{_pkgname}-multi = %{version}-%{release}
+Conflicts:	%{_pkgname}-single
+%else
+%if "%{_dfb_build_config}" == "x"
+Provides:	%{_pkgname}-single = %{version}-%{release}
+Conflicts:	%{_pkgname}-multi
+%endif
+%endif
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-fusiondale
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman-bin
+
+%description -n %{_pkgname}@BUILD_CONFIG@
+DirectFB is a thin library that provides developers with hardware graphics
+acceleration, input device handling and abstraction, an integrated windowing
+system with support for translucent windows and multiple display layers on top
+of the Linux frame buffer device. It is a complete hardware abstraction layer
+with software fallbacks for every graphics operation that is not supported by
+the underlying hardware.
+%if "%{_dfb_build_config}" == "x-multi"
+This version has been built with the Multi Application Core.
+%else
+%if "%{_dfb_build_config}" == "x"
+This version has been built with the Single Application Core.
+%endif
+%endif
+
+
+%package -n %{_pkgname}@BUILD_CONFIG@-dev
+Summary:	Hardware graphics acceleration library - development
+Group:		DirectFB/Development
+AutoReq:	no
+Provides:	%{_pkgname}-dev = %{version}-%{release}
+%if "%{_dfb_build_config}" == "x-multi"
+Requires:	%{_pkgname}-multi = %{version}-%{release}
+Provides:	%{_pkgname}-multi-dev = %{version}-%{release}
+%else
+%if "%{_dfb_build_config}" == "x"
+Requires:	%{_pkgname}-single = %{version}-%{release}
+Provides:	%{_pkgname}-single-dev = %{version}-%{release}
+%endif
+%endif
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-fusiondale-dev
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman-dev
+
+%description -n %{_pkgname}@BUILD_CONFIG@-dev
+DirectFB header files needed for building DirectFB applications.
+
+%package -n %{_pkgname}@BUILD_CONFIG@-dbg
+Summary:	Hardware graphics acceleration library - debug info
+Group:		DirectFB/Development
+AutoReq:	no
+Provides:	%{_pkgname}-dbg = %{version}-%{release}
+%if "%{_dfb_build_config}" == "x-multi"
+Requires:	%{_pkgname}-multi = %{version}-%{release}
+Provides:	%{_pkgname}-multi-dbg = %{version}-%{release}
+%else
+%if "%{_dfb_build_config}" == "x"
+Requires:	%{_pkgname}-single = %{version}-%{release}
+Provides:	%{_pkgname}-single-dbg = %{version}-%{release}
+%endif
+%endif
+%description -n %{_pkgname}@BUILD_CONFIG@-dbg
+This package provides debug information for DirectFB. Debug information
+is useful for providing meaningful backtraces in case of bugs.
+
+%package -n %{_pkgname}-bin
+Summary:	Hardware graphics acceleration library - binaries
+Group:		DirectFB/Development
+%description -n %{_pkgname}-bin
+ DirectFB is a graphics library which was designed with embedded systems
+ in mind. It offers maximum hardware accelerated performance at a minimum
+ of resource usage and overhead.
+ .
+ This package contains the various DirectFB tools, e.g. a background
+ configuration tool, and also the directfbrc man page.
+
+%package -n %{_pkgname}-tests
+Summary:	Hardware graphics acceleration library - tests
+Group:		DirectFB/Development
+%description -n %{_pkgname}-tests
+ DirectFB is a graphics library which was designed with embedded systems
+ in mind. It offers maximum hardware accelerated performance at a minimum
+ of resource usage and overhead.
+ .
+ This package various tests that come with the DirectFB source tree. They
+ are normally not needed, except for maybe driver validatation.
+
+
+%prep
+%target_setup
+%setup -qn DirectFB-%{_dfbversion}
+%patch0 -p1
+# the patch contains symlinks (in git format), but only git-patch can
+# deal with these, do it manually
+for i in fb.h vt.h ; do
+  rm -f systems/stmfbdev/${i}
+  ln -s ../fbdev/${i} systems/stmfbdev/
+done
+%target_autoreconf
+
+%build
+%target_setup
+# the st231 compiler emits a warning when it encounters multiple -O statements,
+# which makes auto* assume that some of its tests failed. Strip out existing -O
+# and add -O3
+_stripped_flags=
+for _this_flag in $CFLAGS ; do
+  _stripped_flags="${_stripped_flags} `echo $_this_flag | sed -e 's,-O.,,'`"
+done
+export CFLAGS="${_stripped_flags} -O3"
+# add -g for debug package
+export CFLAGS="${CFLAGS} -g3"
+export CXXFLAGS="${CFLAGS} -g3"
+export DIRECTFB_VERSION_VENDOR="%{_stmversion}"
+%target_do_configure \
+	--enable-static \
+	\
+	--disable-devmem \
+	--disable-sdl \
+	%{_stmfbdev} \
+	\
+	--enable-voodoo \
+	\
+	--enable-egl \
+	--with-gfxdrivers=gles2 \
+	\
+	--enable-mme=%{_mme_enabled} \
+	--enable-multicore=%{_multicore_enabled} \
+	--with-message-size=65536 \
+	\
+	%{_dfb_multiapp} \
+	%{_dfb_fusion_impl} \
+	\
+	--enable-one \
+	--enable-divine \
+	--enable-sawman \
+	--enable-fusiondale \
+	\
+	%{_dfb_wayland} \
+	\
+	--with-tests
+sed -i -e 's/^hardcode_libdir_flag_spec.*$/hardcode_libdir_flag_spec=\"-D_LIBTOOL_NO_RPATH_\"/' libtool
+
+%make
+
+
+%install
+%target_setup
+%target_makeinstall_destdir
+# make sure the graphics drivers directory exists as we don't (necessarily)
+# build graphics drivers. This will ensure a defined owner of this directory
+# (the DirectFB RPMs), also ensuring that the directory is removed during
+# uninstall of the DFB RPMs.
+mkdir -p %{buildroot}%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/gfxdrivers
+
+# build directfb-config for host environment
+# we assume that _stm_target_lib_dir is in the default search path of both the cross
+# and target dynamic linkers, to suppres spurious -L/usr/lib in *.la files
+mkdir -p %{buildroot}%{_stm_cross_bin_dir}
+sed -e "s,libs=-L%{_stm_target_lib_dir},libs=,g" \
+    -e "s,%{_stm_target_prefix},%{_stm_cross_target_dir}%{_stm_target_prefix},g" \
+    < %{buildroot}%{_stm_cross_target_dir}%{_stm_target_bin_dir}/directfb-config \
+    > %{buildroot}%{_stm_cross_bin_dir}/%{_stm_target_toolprefix}directfb-config
+chmod +x %{buildroot}%{_stm_cross_bin_dir}/%{_stm_target_toolprefix}directfb-config
+
+%target_install_fixup
+# Process target .pc files so they are useful in a cross environment
+for f in %{buildroot}%{_stm_cross_target_dir}%{_stm_target_pkgconfig_dir}/*.pc ; do
+  sed -i '/^prefix=/!s,%{_stm_target_prefix},${prefix},' $f
+done
+
+
+cd ..
+cp COPYING LICENSE
+
+
+# pull debug from elf files out into separate files, to be packaged in the -dbg package
+: > debugfiles.list
+files=`find %{buildroot}%{_stm_cross_target_dir}%{_stm_target_bin_dir} -type f` || true
+files="${files} `find %{buildroot}%{_stm_cross_target_dir}%{_stm_target_lib_dir} -name '*so*' -type f | egrep -v '\.debug$' | egrep '(\.so$|\.so\.)'`"
+for elffile in ${files} ; do
+  sofile=`readelf -h ${elffile} 2> /dev/null | grep "DYN"` || true
+  execfile=`readelf -h ${elffile} 2> /dev/null | grep "EXEC"` || true
+  if [ "X${sofile}" != "X" -o "X${execfile}" != "X" ] ; then
+    debugfile=%{_stm_cross_target_dir}%{_stm_target_debug_dir}`echo ${elffile} | sed -e s,%{buildroot}%{_stm_cross_target_dir},,`.debug
+    mkdir -p `dirname %{buildroot}${debugfile}`
+    %{_stm_target_toolprefix}objcopy --only-keep-debug ${elffile} %{buildroot}${debugfile}
+    %{_stm_target_toolprefix}objcopy --strip-debug ${elffile}
+    %{_stm_target_toolprefix}objcopy --add-gnu-debuglink=%{buildroot}${debugfile} ${elffile}
+    echo ${debugfile} >> debugfiles.list
+  fi
+done
+
+
+%clean
+rm -rf %{buildroot}
+
+
+%files -n %{_pkgname}@BUILD_CONFIG@
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.so.*
+%dir %{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}
+%dir %{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.so
+%dir %{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.so
+%dir %{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}/cursor.dat
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}/cursor.png
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}/decker.ttf
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}@BUILD_CONFIG@-dev
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/directfb-config
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/directfb-csource
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/directfb
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/directfb-internal
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/++dfb
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/One
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/divine
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/fusiondale
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/sawman
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.so
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.a
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.la
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.a
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.la
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.o
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.a
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.la
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.o
+%{_stm_cross_target_dir}%{_stm_target_pkgconfig_dir}/*.pc
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/man/man1/directfb-csource*1*
+%{_stm_cross_bin_dir}/*
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}@BUILD_CONFIG@-dbg -f debugfiles.list
+%defattr(-,root,root)
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}-bin
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbdump
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbfx
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbg
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbinfo
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbinput
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbinspector
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfblayer
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbmaster
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbpenmount
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbproxy
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbscreen
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbdumpinput
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbplay
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbshow
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbswitch
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/mkdfiff
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/mkdgiff
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/mkdgifft
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/voodooplay
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/voodooplay_client
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/voodooplay_server
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/divine_test
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fddump
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fdmaster
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fdtest_bench
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fdtest_coma
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fdtest_init
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/sample1
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/spooky
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/swmdump
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/testman
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/testrun
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/man/man1/dfbg*1*
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/man/man5/directfbrc*5*
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}-tests
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/coretest_*
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbtest_*
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/direct_*
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fusion_*
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/voodoo_bench*
+%dir %{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}/decker.dgiff
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/OneBench
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/OneTest
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+
+%changelog
+* Tue Jan 26 2016 Ilyes Gouta <ilyes.gouta@st.com> 1
+- [Ticket: 93678] New wayland system module for DirectFB
+- [Ticket: 75564] SetOpacity for video layer is not working
+
+* Fri Nov 27 2015 Ilyes Gouta <ilyes.gouta@st.com> 1
+- [Ticket: 87247] Retire the Multicom (JPEG, PNG and RLE) integration
+- [Delete patch: directfb-include-missing-ioctl.h-header.patch]
+  not needed anymore
+
+* Fri Aug 14 2015 Mohamed Hafsia <mohamed.hafsia@st.com> 3
+- [Spec] remove RPATH set for egl plugins.
+
+* Thu Aug 13 2015 Mohamed Hafsia <mohamed.hafsia@st.com> 2
+- [Add patch: directfb-include-missing-ioctl.h-header.patch]
+  Add missed ioctl.h include for commit#3fabd47f :merge the hwJPEG V4L2 decoder back into the default provider
+
+* Tue Aug 11 2015 Ilyes Gouta <ilyes.gouta@st.com> 1
+- [Update: 1.7.7] Update to DirectFB-1.7.7
+- [Spec] Enable the EGL/GLES2 system and acceleration modules
+- Deprecate the Multicom based JPEG decoding path
+- Merge the V4L2 h/w JPEG decoder back into the default image provider
+
+* Fri Jul 31 2015 Mohamed Hafsia <mohamed.hafsia@st.com> 2
+- [Spec] bump release to rebuild against udev package
+   Input hot-plug detection requires libudev
+
+* Wed Jun 10 2015 Ilyes Gouta <ilyes.gouta@st.com> 1
+- [Ticket: 56609] Input hot-plug detection using libudev
+- [Ticket: 69173] Memory leaks detected using valgrind
+- [Ticket: 70800] No hot-plug detection when using stmfbdev
+- [Ticket: 71972] Paint over issue on transparent animated GIF
+- [Ticket: 75012] Segmentation fault in DirectFB-multi using the default wm
+
+* Fri May 22 2015 Gilles Grandjouan <gilles.grandjouan@st.com> 8
+- [Spec] Bump the release number for 2.4 product release,
+         after update of gcc from 4.8 to 4.9.
+
+* Wed Feb 11 2015 Francesco Rundo <francesco.rundo@st.com> 7
+- [Spec] Bump release to force rebuild against updated libjpeg
+
+* Wed Feb 04 2015 Ilyes Gouta <ilyes.gouta@st.com> 6
+- [Bugzilla: 68242] Explicitly disable multi-kernel for DirectFB-single builds
+
+* Fri Jan 16 2015 Ilyes Gouta <ilyes.gouta@st.com> 5
+- [Bugzilla: 64697] Backport wayland-dfb library to DirectFB-1.7
+
+* Thu Dec 04 2014 Ilyes Gouta <ilyes.gouta@st.com> 4
+- [Bugzilla: 63244] Disable Multicom integration
+
+* Fri Nov 14 2014 Frederic Pillon <frederic.pillon@st.com> 3
+- [Spec] Correct Obsoletes macro as it was not take in account.
+
+* Fri Oct 31 2014 Gilles Grandjouan <gilles.grandjouan@st.com> 2
+- [Spec] Bump the release number for 2.4 product release.
+- [Spec] Bump the release number to force rebuild against updated libjpeg
+
+* Thu Oct 23 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.7.6+STM2014.10.23-1
+- [Update: 1.7.6] Update to DirectFB-1.7 API (+STM patches)
+
+* Wed Sep 24 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.6.4+STM2014.09.24-1
+- [Bugzilla: 59216] Improve shutdown sequence in DirectFB-1.6
+
+* Fri Sep 12 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.6.4+STM2014.09.12-1
+- [Bugzilla: 56438] fix a memory leak in the TIFF image provider
+- fbdev: don't destroy the surface pool if already freed
+- core: flush and wait for pending h/w ops. prior surface destruction
+- libfusion: fix secure-fusion mode for reactor_globals and arenas_lock
+- [Delete patch: 0001-configure-ignore-with-sysroot-option.patch]
+  not needed anymore
+
+* Thu Jul 24 2014 Gilles Grandjouan <gilles.grandjouan@st.com> 1:1.6.4+STM2014.07.22-2
+- [Bugzilla: 54814] Applied patch received from Ilyes
+
+* Tue Jul 22 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.6.4+STM2014.07.22-1
+- [Bugzilla: 54814] segmentation fault when creating the IDirectFB interface twice
+
+* Fri Jun 27 2014 Christian Bruel <christian.bruel@st.com> 2
+- [Spec] Reinstall with correct dependencies in .la.
+
+* Wed Apr 23 2014 BogusDateBot
+- Eliminated rpmbuild "bogus date" warnings due to inconsistent weekday,
+  by assuming the date is correct and changing the weekday.
+  Tue Jul 29 2009 --> Tue Jul 28 2009 or Wed Jul 29 2009 or Tue Aug 04 2009 or ....
+  Wed Mar 09 2010 --> Wed Mar 03 2010 or Tue Mar 09 2010 or Wed Mar 10 2010 or ....
+
+* Mon Apr 21 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.6.4+STM2014.04.21-1
+- [Bugzilla: 37637] FBDev: Enable stmfb auxiliary memory support on STM platforms
+- [Bugzilla: 39840] Revert implementation for CORE_STMFBDEV system
+  STMfbdev has been discontinued in STLinux and is now part of SDK2 deliverables
+- [Bugzilla: 42061] Busy allocations should have a valid parent buffer
+- [Bugzilla: 48949] Avoid calling direct_shutdown() twice
+- [Bugzilla: 48950] Initialize the shm pool lock as a shared object
+- libfusion: hash resizing in fusion_hash_replace (when new)
+- Core: Don't freeze when moving layer (update_primary_region_config)
+
+* Mon Mar  3 2014 Gilles Grandjouan <gilles.grandjouan@st.com> 1:1.6.4+STM2013.11.29-3
+- [Spec] Bump release to force rebuild against updated libjpeg
+
+* Mon Feb 03 2014 Mohamed Hafsia <mohamed.hafsia@st.com> 1:1.6.4+STM2013.11.29-2
+- [Spec] bump release to rebuild against updated libwebp
+
+* Fri Nov 29 2013 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.4+STM2013.11.29-1
+- Update to the latest directfb-1.6 (SHA1 cc46784)
+- [Bugzilla: 32930] Enable One in DirectFB-1.6.x, FusionDale
+- [Bugzilla: 34641] Fusiondale not supporting Secure Mode
+- [Bugzilla: 38142] DirectFB: Add 4k display resolution
+- [Bugzilla: 39478] direct_list_contains_element_EXPENSIVE( *list, link ) fails
+- [Bugzilla: 40435] Swapped red/blue channels when decoding a TIFF picture
+
+* Fri Aug 30 2013 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.3+STM2013.08.30-1
+- [Bugzilla: 29557] colour fill to NV12 and NV21 broken
+- [Bugzilla: 29559] IDirectFBSurface::Dump() for DSPF_YUV444P incorrect
+- [Bugzilla: 29496] IDirectFBSurface::Dump() for DSPF_(A)VYU incorrect
+- [Bugzilla: 29512] IDirectFBSurface::Dump() for DSPF_YV16 incorrect
+- [Bugzilla: 29985] DSPF_NV12MB and DSPF_NV16MB aren't marked as YCbCr
+- [Bugzilla: 35133] WebP imageprovider crashes when doing multiple RenderTo()
+- inputdrivers: set DICAPS_KEYS only for input devices with keys
+- imageprovider: add a new TIFF image provider
+
+* Wed Jun 12 2013 André Draszik <andre.draszik@st.com> - 1:1.6.3+STM2013.04.10-2
+- [Spec; Bugzilla: 31952] make sure we create and own the gfxdrivers directory
+
+* Wed Apr 10 2013 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.3+STM2013.04.10-1
+- [Bugzilla: 29280] idirectfb: allow creating NV1xMB surfaces with
+  DSCAPS_PREMULTIPLIED set
+- imageprovider: add WebP imageprovider
+- hwjpeg: early validate the JPEG buffer with the h/w decoder
+- hwjpeg: don't downsample NV24 to a temporary NV16 buffer
+- [Bugzilla: 27188] fusion: ref: immediately execute FusionCall in
+  fusion_ref_down()
+- [Bugzilla: 16971] Revert
+  "direct: replace C++ style comments by standard C comments"
+- [Bugzilla: 27699] interfaces: gif: fix up DVPLAY_PACED decoding mode
+- [Bugzilla: 27886] idirectfb: don't clear config.surface_caps if already set
+
+* Mon Feb 25 2013 Francesco Virlinzi <francesco.virlinzi@st.com> 2
+- [Spec; Bugzilla: 23138] Make compatible with rpm-build 4.10.
+
+* Fri Feb 01 2013 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.3+STM2013.02.01-1
+- [Update: 1.6.3] update to 1.6.3 release
+- [Bugzilla: 25124] direct: reimplement direct_waitqueue_wait_timeout() to use
+  clock_gettime()
+- interfaces: jpeg: new hwjpeg-v4l2 image provider
+- directfb: new DSPF_NV24 pixel format
+- directfb: new DSPF_BYTE pixel format
+
+* Fri Sep 21 2012 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.1+STM2012.09.21-1
+- [Bugzilla: 21232] DirectFB-1.6: Grayscale JPEG decoding is broken
+- [Bugzilla: 21233] DirectFB-1.6: LUT4 (or LUT2) animated gif doesn't
+		    get rendered properly
+- [Bugzilla: 16971] DirectFB-1.6: replace C++ style comments by
+		    standard C comments
+- [Bugzilla: 18969] Bad interaction between libmme.so and DirectFB
+
+* Wed Aug 01 2012 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.1+STM2012.07.25-1
+- [Spec] configure with a 65356 bytes per Fusion message buffer (IPC)
+- [Spec] disable parallel build process (fluxcomp/gcc concurrency)
+
+* Wed Jul 25 2012 André Draszik <andre.draszik@st.com> - 1:1.6.1+STM2012.07.25-1
+- [Update: 1.6.1] update to 1.6.1 release
+- [Spec] change contents of SRPM to contain pristine tarball + STM patch
+- [Spec] add BuildRequires for fluxcomp
+- [Spec] enable voodoo during configure
+- [Spec] package binaries in new -bin package and move man pages here
+- [Spec] package tests in new -tests package
+- [Spec] always fully disable gfxdrivers, stgfx(1) is completely gone,
+  and stgfx2 is now hosted elsewhere
+- [Spec] build armv7 version with multicore support (SMP)
+- [Spec] always fully disable gfxdrivers, stgfx(1) is completely gone,
+  and stgfx2 is now hosted elsewhere
+- [Spec] forcefully enable stmfbdev on SH4 and ARM
+- [Bugzilla: 18771] stmfbdev: don't error out if display driver announced no
+  supported modes
+- stmfbdev: fix to actually allow configuring DVO, allow selection
+  between RGB 24bit and YCbCr 444 16bit
+- stmfbdev: add support for 960x540 and 1440x540 NTG5 modes
+- stmfbdev: for HDMI outputs, be more explicit about YCbCr 444 / 422 / RGB
+- move all of the stmfbdev layer and screen handling out of stgfx2, so that
+  stmfbdev can be used independently of any hardware acceleration
+- [Bugzilla: 12425] JPEG decode segfaults for iDCT downscaled grayscale images
+- [Bugzilla: 16039] jpeg software decode error path broken in case h/w decode
+  failed earlier
+- [Bugzilla: 16040] jpeg: optimise grayscale JPEG decoding
+- jpeg: use JDCT_FASTEST instead of JDCT_IFAST
+- image providers: change the backgrounded image provider API to use the
+  DIRenderFlags that upstream added recently, instead of our
+  DFBImageProviderFlags
+- rle: remove image provider
+- add DSPF_LUT4 implementation
+- add DSPF_BGR24 implementation
+- add DSPF_NV12MB and DSPF_NV16MB and (incomplete) implementation
+- directfb: extend IDirectFBInputDevice to recognize sensors-based input devices
+
+* Fri Jun 08 2012 Ilyes Gouta <ilyes.gouta@st.com> 1:1.4.12+STM2011.09.27-3
+- [Bugzilla: 17925] jpeg: fix stack corruption when going through hardware
+  assisted decode
+- [Bugzilla: 17956] fix SIGSEGV when downscaling via iDCT in the JPEG raw
+  decode path
+- [Bugzilla: 17958] image provider: have to wait for the hardware in certain
+  cases
+- [Bugzilla: 18969] prefer runtime dynamic linking for certain image providers
+- [Delete patch: DirectFB-1.4.12-directfb-improved-idirectfbvideoprovider_gif.patch,
+   DirectFB-1.4.12-directfb-DVPLAY_PACED-declaration.patch,
+   DirectFB-1.4.12-directfb-palette_pass_data-core_instead_of_NULL.patch]
+  not needed anymore
+
+* Thu Feb 16 2012 Mohamed Hafsia <mohamed.hafsia@st.com> 1:1.4.12+STM2011.09.27-2
+- [Bugzilla: 16564] Rework IDirectFBVideoProvider_GIF to implement a paced decode
+- [Add patch: DirectFB-1.4.12-directfb-improved-idirectfbvideoprovider_gif.patch,
+   DirectFB-1.4.12-directfb-DVPLAY_PACED-declaration.patch
+   DirectFB-1.4.12-directfb-palette_pass_data-core_instead_of_NULL.patch]
+  Improved DirectFB IDirectFBVideoProvider_gif
+
+* Tue Sep 27 2011 André Draszik <andre.draszik@st.com> - 1:1.4.12+STM2011.09.27-1
+- [Bugzilla: 14222] subpixel based backwards blits don't look perfect
+- [Delete patch:
+   DirectFB-1.4.12+STM2011.05.05-bdisp2_accel-fix-directions-for-backwards-copy.patch,
+   DirectFB-1.4.12+STM2011.05.05-bdisp_accel-hot-fix-for-backwards-blits-than-don-t-r.patch]
+  not needed anymore
+
+* Fri Sep 16 2011 André Draszik <andre.draszik@st.com> - 1:1.4.12+STM2011.05.05-3
+- [Bugzilla: 14177; Add patch:
+   DirectFB-1.4.12+STM2011.05.05-bdisp2_accel-fix-directions-for-backwards-copy.patch,
+   DirectFB-1.4.12+STM2011.05.05-bdisp_accel-hot-fix-for-backwards-blits-than-don-t-r.patch]
+  hotfix for STLinux bugzilla 14177
+
+* Wed Aug 31 2011 Giuseppe Condorelli <giuseppe.condorelli@st.com> 1:1.4.12+STM2011.05.05-2
+- [Spec] Add libpng BuildRequires, also rebuilding package against updated libpng
+
+* Thu May 05 2011 André Draszik <andre.draszik@st.com> 1:1.4.12+STM2011.05.05-1
+- [Bugzilla: 11922] really fix raw jpeg decoding for libjpeg >= v7
+- [Bugzilla: 10850, 12050] clipping in "fb_gfxcard_drawstring" not checked correctly
+- fix small memory leak in DirectGetInterface()
+
+* Thu Apr 14 2011 André Draszik <andre.draszik@st.com> 1:1.4.12+STM2011.04.14-1
+- [Update: 1.4.12+STM2011.04.14] update to DirectFB 1.4.12 and latest STM version
+- [Bugzilla: 11689] inputdrivers: support lirc>=0.8.6
+- [Bugzilla: 11884] build: libidirectfbfont_ft2 must be linked against libm
+- [Delete patch: DirectFB-1.4.11-non-mme-hotfix.patch] not needed anymore
+- [Bugzilla: 11922] fix raw jpeg decoding for libjpeg >= v7
+
+* Tue Apr 05 2011 André Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-4
+- [Bugzilla: 11825; Spec] add debug info package
+- [Spec] update summary of -dev package
+
+* Thu Jan 06 2011 André Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-3
+- [Add patch: DirectFB-1.4.11-non-mme-hotfix.patch] hotfix for builds with
+  disabled MME
+- Breaks binary compatibility with Mali drivers (Mali drivers need to be rebuilt)
+
+* Wed Jan 05 2011 André Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-2
+- [Spec] disable MME use for image decoding for non sh4 builds during configure
+  to fix build failures on ARM
+
+* Wed Dec 15 2010 André Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-1
+- [Update: 1.4.11+STM2010.12.15] new release based on 1.4.11 + git 811a8c0
+- [Bugzilla: 10320] don't set any output resolution on startup
+- [Bugzilla: 10344] take DirectFB's init-layer=<x> option into account
+- [Bugzilla: 10769] want SOURCE2 support in DirectFB BDisp driver
+- image providers: accelerate JPEG and PNG using MME
+- fixed point fixes
+- [Delete patch: DirectFB-1.4.3-0001-stgfx2-version-bump.patch] integrated upstream
+- [Spec] Bump BuildRequires for linux-fusion to 8.2.0
+- [Spec] drop setting of LIBPNG_CONFIG - it's not needed anymore
+
+* Thu Oct 21 2010 André Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.10.15-1
+- [Add patch: DirectFB-1.4.3-0001-stgfx2-version-bump.patch] bump stgfx2 version
+  to 0.8
+
+* Fri Oct 15 2010 André Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.10.15-1
+- [Update: 1.4.3+STM2010.10.15] new release
+- [Bugzilla: 10253] jpeg: fix raw decode error paths
+- [Bugzilla: 10242] stgfx2: DSBLIT_XOR does not work
+- [Bugzilla: 10254] stgfx2: incorrect use of line filters for 'slim' stretch blits
+- [Bugzilla: 10228] stgfx2: disable use of hw based clipping
+- [Bugzilla: 10226] stgfx2: full DSBLIT_BLEND_COLORALPHA support
+- [Bugzilla: 10227] stgfx2: fix some 'unusual' PorterDuff blends
+- [Bugzilaa: 10247] stgfx2: DSPD_CLEAR crashes the BDisp in 422r modes
+- stgfx2 cleanup: blit state rewrite, compiler warnings, debug for DirectFB 1.4.3,
+  fixes for RGB32
+- [Spec] some changes so as to make future updates easier
+
+* Thu Aug 26 2010 André Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.06.22-2
+- [Spec] fix build requires to reference correct stmfb headers package version
+  on sh4
+
+* Wed Aug 25 2010 André Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.06.22-1
+- [Update: 1.4.3+STM2010.06.22] new release
+- [Delete patch: DirectFB-1.4.3+STM2010.06.16-stmfb0029.patch] we have an up to
+  date stmfb in STLinux 2.4 now, so this patch is a) harmful for STi7108 support
+  and b) not needed anymore anyway
+- stgfx2: fix clip validation
+
+* Wed Jun 16 2010 André Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.06.16-1
+- [Update: 1.4.3.STM2010.06.16] new release
+- [Delete patch: DirectFB-1.4.3.STM2010.03.10-libjpeg7.patch,
+   DirectFB-1.4.3.STM2010.03.10-libjpeg7_2.patch]
+  jpeg problems correctly fixed upstream
+- [Delete patch: DirectFB-1.4-Revert-versioned-DirectFB-libraries.patch]
+  not needed anymore
+- [Add patch: DirectFB-1.4.3+STM2010.06.16-stmfb0029.patch] needed now
+
+* Tue Apr 27 2010 André Draszik <andre.draszik@st.com> 1.4.3.STM2010.03.10-4
+- [Bugzilla: 8912; Add patch: DirectFB-1.4.3.STM2010.03.10-libjpeg7.patch,
+   DirectFB-1.4.3.STM2010.03.10-libjpeg7_2.patch]
+  fix libjpeg usage for libjpeg versions >= 7
+- [Spec] simplify file ownership list
+- [Spec] bump version to rebuild against updated libjpeg
+
+* Tue Apr 13 2010 André Draszik <andre.draszik@st.com> 1.4.3.STM2010.03.10-3
+- [Spec] fix source package name
+
+* Wed Mar 31 2010 Stuart Menefy <stuart.menefy@st.com> 2
+- [Spec] Bump the release number for 2.4 product release.
+- [Spec] Update BuildRoot to use %%(mktemp ...) to guarantee a unique name.
+
+* Tue Mar 09 2010 André Draszik <andre.draszik@st.com> 1.4.3.STM2010.03.10-1
+  Wed Mar 09 2010 --> Wed Mar 03 2010 or Tue Mar 09 2010 or Wed Mar 10 2010 or ....
+- [Spec] add some more files to main package's documentation
+- merge in latest updates from DirectFB/master branch
+- input: handle button devices with just up/down keys as keyboards, too
+- stgfx2: fix shutdown error path
+- stgfx2: big cleanup regarding the destination address
+- stgfx2: slightly smaller cleanup regarding the s3 address & type
+- stgfx2: cleanup regarding s2 address & type
+- stgfx2: huge cleanup regarding drawing state
+- the above four changes yield in about 10% less CPU usage on fills!
+- [Bugzilla: 8256] XOR doesn't work as expected
+- [Bugzilla: 8406] prevent BDisp crash when doing YCbCr422R fast blit
+- [Bugzilla: 8366] desaturation of YCbCr surfaces
+- stgfx2: back to bdisp_aq_VideoYCbCr601_2_RGB matrix for YCbCr->RGB conversions
+- stgfx2: allow 'other' accelerators to access our surface pools
+- stgfx2: RGB32 updates
+
+* Fri Feb 05 2010 André Draszik <andre.draszik@st.com> 1.4.3.STM2010.02.08-1
+- [Bugzilla: 8193] do necessary changes (pollvsync_after)
+- [Bugzilla: 7360, 8077] subpixel vertical filter setup has been
+  greatly simplified and corrected
+
+* Fri Feb 05 2010 André Draszik <andre.draszik@st.com> 1.4.3.STM2010.02.05-1
+- stgfx stgfx2: fix shutdown when not running in stmfbdev system
+- linux_input: fix compilation if stmfbdev is disabled
+
+* Sun Jan 31 2010 André Draszik <andre.draszik@st.com> 1.4.3.STM2010.01.31-1
+- merge in latest updates from DirectFB/master branch
+- stmfbdev: address compiler warnings in non debug builds
+- stmfbdev: fix crash in shutdown
+- stmfbdev: optimize ioctl handling
+- stmfbdev: don't instanciate screens, layers & surface pools anymore
+- stgfx/stgfx2: move instanciation of the above here, this gets us rid of more of DirectFB's startup warnings
+
+* Fri Jan 29 2010 André Draszik <andre.draszik@st.com> 1.4.3.STM2010.01.29-1
+- [Bugzilla: 7995] new system: 'stmfbdev' for many new features reg. screen control
+- stgfx2:
+  + some fixes for blit and fill if destination is YUV
+  + WA for https://bugzilla.stlinux.com/show_bug.cgi?id=7084
+  + update alignment restrictions for STi7108
+  + stgfx surface pools: prevent confusing startup message
+- stgfx:
+  + update alignment restrictions for STi7108
+  + stgfx surface pools: prevent confusing startup message
+- misc:
+  + dfbscreen: little fixes
+  + generic: LUT8 is not a YUV format
+  + screen: NTSC and PAL60 standards are defined as 59.94Hz not 60Hz
+  + IDirectFBScreen: add IDirectFBScreen::GetVSyncCount()
+  + directfb.h: add a DVO 656 'connector'
+  + dfblayer: allow to set layer position and size using command line
+  + dfbinspector: add DSPF_AVYU and DSPF_VYU pixelformats
+- [Delete patch: DirectFB-1.4.3.STM2009.12.11-CLUT8_fix.patch] integrated upstream
+
+* Fri Jan 29 2010 André Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-4
+- [Add patch: DirectFB-1.4.3.STM2009.12.11-CLUT8_fix.patch] fix CLUT8 issue in
+  software renderer
+
+* Mon Jan 11 2010 André Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-3
+- [Spec] unify multi app and single app spec files
+
+* Wed Dec 16 2009 André Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-2
+- [Add patch: DirectFB-1.4.3.STM2009.12.11-autoconf259.patch] so as to enable
+  successful build on arm with old autotools in STLinux-2.3
+
+* Fri Dec 11 2009 André Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-1
+- [update: 2009-12.11] update to DirectFB 1.4.3
+- misc: use pkgconfig to detect X11
+- misc: surface: replace GetFramebufferOffset() with GetPhysicalAddress()
+- stgfx2: pick up all updates from 1.0.1 branch
+- stgfx2: release surface pools on shutdown
+- [Bugzilla: 7776] stgfx2: cleanup draw/blitting wrt flags
+- stgfx: release surface pools on shutdown
+- [Bugzilla: 7570] jpeg: implement decimated decode for software JPEG decoder
+- [Bugzilla: 7636] jpeg: implement raw libjpeg decode for possible HW acceleration (using stgfx2)
+
+* Fri Aug 21 2009 André Draszik <andre.draszik@st.com> 1.4.1.STM2009.08.21-1
+- [update: 2009-08-21]
+  allow source widths and heights < 1.0 (but > 0) in BatchStretchBlit()
+
+* Tue Aug 18 2009 André Draszik <andre.draszik@st.com> 1.4.1.STM2009.08.18-1
+- [update: 2009-08-18]
+
+* Wed Jul 29 2009 André Draszik <andre.draszik@st.com> 1
+  Tue Jul 29 2009 --> Tue Jul 28 2009 or Wed Jul 29 2009 or Tue Aug 04 2009 or ....
+- [update: 1.4.1] new upstream version with all the STM patches
+
diff --git a/configure.in b/configure.in
index dc78d59..4c80aee 100644
--- a/configure.in
+++ b/configure.in
@@ -147,6 +147,20 @@ available from git://git.directfb.org/git/directfb/core/flux
   fi
 fi
 
+AC_PATH_TOOL(WAYLAND_SCANNER, wayland-scanner)
+AC_SUBST(WAYLAND_SCANNER)
+if test "$enable_wayland" = "yes" && test -z "$WAYLAND_SCANNER"; then
+  if ! test -e lib/wayland-dfb/wayland-dfb-server-protocol.h; then
+    AC_MSG_ERROR([
+*** DirectFB compilation requires wayland-scanner ***
+
+Unless you are compiling from a distributed tarball you need wayland-scanner
+available from git://anongit.freedesktop.org/wayland/wayland installed
+in your PATH.
+])
+  fi
+fi
+
 dnl Test for OSX
 AC_ARG_ENABLE(osx,
               AC_HELP_STRING([--enable-osx],
@@ -1130,9 +1144,9 @@ AC_ARG_ENABLE(egl,
                              [build with EGL support @<:@default=no@:>@]),
               [], [enable_egl=no])
 if test "$enable_egl" = "yes"; then
-  PKG_CHECK_MODULES(EGL, [gl egl], [enable_egl=yes], [enable_egl=no
+  PKG_CHECK_MODULES(EGL, [egl], [enable_egl=yes], [enable_egl=no
     AC_MSG_WARN([
-*** gl egl packages not found -- Building without EGL support.])
+*** egl package not found -- Building without EGL support.])
     ])
 fi
 
@@ -1186,6 +1200,25 @@ AM_CONDITIONAL(FBDEV_CORE, test "$enable_fbdev" = "yes")
 
 
 
+dnl Test for STMicroelectronics frame buffer system
+
+if test "$enable_fbdev" = "yes"; then
+  AC_CHECK_HEADER([linux/stmfb.h],
+                  [have_stmfb_h=yes
+                  AC_DEFINE(HAVE_STMFB_H,1,[Define to 1 if you have the <linux/stmfb.h> header file.])],
+                  [have_stmfb_h=no],
+                  [#include <linux/fb.h>])
+  AM_CONDITIONAL(STMFB_H, [test "$have_stmfb_h" = "yes"])
+fi
+
+AC_ARG_ENABLE(stmfbdev,
+              AC_HELP_STRING([--enable-stmfbdev],
+                             [build with STMicroelectronics stmfb system support @<:@default=auto@:>@]),
+              [], [enable_stmfbdev=yes])
+AM_CONDITIONAL(STMFBDEV_CORE, test "$enable_stmfbdev" = "yes")
+
+
+
 dnl Test for SDL
 AC_ARG_ENABLE(sdl,
               AC_HELP_STRING([--enable-sdl],
@@ -1242,7 +1275,7 @@ AC_ARG_ENABLE(mesa,
 if test "$enable_mesa" = "yes"; then
   PKG_CHECK_MODULES(MESA, [glesv2 egl libdrm gbm], [enable_mesa=yes], [enable_mesa=no
     AC_MSG_WARN([
-*** gl egl libdrm gbm packages not found -- Building without MESA support.])
+*** glesv2 egl libdrm gbm packages not found -- Building without MESA support.])
     ])
 fi
 
@@ -1268,13 +1301,38 @@ AC_SUBST(DRMKMS_CFLAGS)
 
 
 
+dnl Test for Wayland
+AC_ARG_ENABLE(wayland,
+              AC_HELP_STRING([--enable-wayland],
+                             [build with Wayland support @<:@default=auto@:>@]),
+              [], [enable_wayland=yes])
+if test "$enable_wayland" = "yes"; then
+  PKG_CHECK_MODULES(WAYLAND, [wayland-client wayland-server], [enable_wayland=yes], [enable_wayland=no
+    AC_MSG_WARN([
+*** wayland-client packages not found -- Building without Wayland support.])
+    ])
+fi
+
+AM_CONDITIONAL(ENABLE_WAYLAND, test "$enable_wayland" = "yes")
+if test "$enable_wayland" = "yes"; then
+  AC_CHECK_FUNCS([mkostemp posix_fallocate])
+  AM_CONDITIONAL(WAYLAND_CORE, test "$enable_wayland" = "yes")
+fi
+AC_SUBST(WAYLAND_LIBS)
+AC_SUBST(WAYLAND_CFLAGS)
+
 dnl Test for libjpeg
 JPEG=no
+JPEG_HW=no
 
 AC_ARG_ENABLE(jpeg,
               AC_HELP_STRING([--enable-jpeg],
                              [build JPEG image provider @<:@default=yes@:>@]),
               [], [enable_jpeg=yes])
+AC_ARG_ENABLE(hwjpeg,
+              AC_HELP_STRING([--enable-hwjpeg],
+                             [add hardware acceleration to JPEG image provider @<:@default=yes@:>@]),
+              [], [enable_hwjpeg=yes])
 
 if test "$enable_jpeg" = "yes"; then
   if test -z "$LIBJPEG"; then
@@ -1303,11 +1361,24 @@ if test "$enable_jpeg" = "yes"; then
   fi
 fi
 
+if test "$enable_hwjpeg" != "no"; then
+  if test "$JPEG" = "yes"; then
+    AC_DEFINE(JPEG_PROVIDER_HW, 1, [Define to 1 to enable hardware JPEG decoder.])
+    JPEG_HW=yes
+  else
+    AC_MSG_WARN([*** JPEG decoding not enabled. Hardware JPEG image provider can not be built.])
+    JPEG_HW=no
+  fi
+fi
+
 AM_CONDITIONAL(JPEG_PROVIDER, test "$JPEG" = "yes")
+AM_CONDITIONAL(JPEG_PROVIDER_HW, test "$JPEG_HW" = "yes")
 
-if test "$enable_jpeg" != "no" && test "$JPEG" != "yes"; then
-  jpeg_warning="
+if test "$JPEG" != "yes"; then
+  if test "$enable_jpeg" != "no" || test "$enable_hwjpeg" != "no" ; then
+    jpeg_warning="
 JPEG support is missing - many applications won't work correctly!"
+  fi
 fi
 
 
@@ -2102,9 +2173,14 @@ fi
 AC_SUBST(GL_LIBS)
 
 if test "$checkfor_gles2" = "yes"; then
+   PKG_CHECK_MODULES(GLES2, [glesv2], [have_glesv2=yes], [have_glesv2=no])
    if test "$enable_egl" = "yes"; then
-      GLES2_CFLAGS="$GLES2_CFLAGS $EGL_CFLAGS -DGLES2_EGL"
-      GLES2_LIBS="$GLES2_LIBS $EGL_LIBS"
+      if test "$have_glesv2" = "no"; then
+         GLES2_CFLAGS="$GLES2_CFLAGS $EGL_CFLAGS -DGLES2_EGL"
+         GLES2_LIBS="$GLES2_LIBS $EGL_LIBS"
+      else
+         GLES2_CFLAGS="$GLES2_CFLAGS -DGLES2_EGL"
+      fi
    fi
    if test "$enable_mesa" = "yes"; then
       GLES2_CFLAGS="$GLES2_CFLAGS $MESA_CFLAGS -DGLES2_MESA"
@@ -2254,7 +2330,7 @@ if test "$inputdrivers" = "all"; then
   checkfor_h3600ts=yes
   checkfor_input_hub=yes
   checkfor_joystick=yes
-  checkfor_keyboard=yes
+  checkfor_keyboard=no
   checkfor_linux_input=yes
   checkfor_lirc=yes
   checkfor_mutouch=yes
@@ -2406,6 +2482,12 @@ if test "$checkfor_linux_input" = "yes"; then
     AC_MSG_WARN([*** no linux/input.h -- Linux Input driver will not be built.]))
 
   if test "$enable_linux_input" = "yes"; then
+      PKG_CHECK_MODULES([LIBUDEV], [libudev],
+                        [enable_linux_input=yes],
+                        [enable_linux_input=no])
+  fi
+
+  if test "$enable_linux_input" = "yes"; then
     AC_MSG_CHECKING([for struct input_absinfo in linux/input.h])
     AC_TRY_COMPILE([#include <linux/input.h>], [struct input_absinfo x; (void)x;],
        AC_DEFINE(HAVE_INPUT_ABSINFO,1,
@@ -2628,7 +2710,7 @@ AC_ARG_WITH(runtime-sysroot,
             AC_HELP_STRING([--with-runtime-sysroot=DIR],
                            [search for lib/share et al within DIR at runtime,]
                            [e.g. when loading modules]),
-            [RUNTIME_SYSROOT="$withval"], [RUNTIME_SYSROOT=])
+            [RUNTIME_SYSROOT=], [RUNTIME_SYSROOT=])
 test x"$RUNTIME_SYSROOT" = x"no" && RUNTIME_SYSROOT=
 AC_SUBST(RUNTIME_SYSROOT)
 
@@ -2646,6 +2728,14 @@ if test "$enable_unique" = "yes"; then
 fi
 
 
+AC_ARG_WITH(cxxstd,
+            AC_HELP_STRING([--with-cxxstd],
+                           [select C++ standard for compiler @<:@default=c++11@:>@]),
+            [cxxstd="$withval"], [cxxstd="c++11"])
+test x"$cxxstd" = x"no" && cxxstd="c++11"
+CXXSTD="$cxxstd"
+AC_SUBST(CXXSTD)
+
 
 AM_CONDITIONAL(GFX_ATI128, test "$ati128" = "yes")
 AM_CONDITIONAL(GFX_CLE266, test "$cle266" = "yes")
@@ -2824,6 +2914,9 @@ lib/voodoo/build.h
 lib/voodoo/unix/Makefile
 lib/voodoo/voodoo.pc
 
+lib/wayland-dfb/Makefile
+lib/wayland-dfb/wayland-dfb.pc
+
 lib/sawman/Makefile
 lib/sawman/sawman.pc
 
@@ -2887,6 +2980,8 @@ systems/x11vdpau/Makefile
 systems/osx/Makefile
 systems/sdl/Makefile
 systems/vnc/Makefile
+systems/stmfbdev/Makefile
+systems/wayland/Makefile
 
 wm/Makefile
 wm/default/Makefile
@@ -2947,6 +3042,7 @@ inputdrivers/sonypi/Makefile
 inputdrivers/tslib/Makefile
 inputdrivers/ucb1x00_ts/Makefile
 inputdrivers/wm97xx_ts/Makefile
+inputdrivers/wayland/Makefile
 
 interfaces/Makefile
 interfaces/ICoreResourceManager/Makefile
@@ -3032,6 +3128,7 @@ Misc options:
   Dithering 565             $with_dither_rgb16
   zlib compression          $use_zlib                 $ZLIB_LIBS
   Using setsockopt          $with_setsockopt
+  c++ compiler standard     $cxxstd
 
 Building Tests              $with_tests
 Building Tools              $with_tools
@@ -3048,6 +3145,7 @@ Building System Modules:
   OSX support               $enable_osx                 $OSX_CFLAGS $OSX_LIBS
   SDL support               $enable_sdl                 $SDL_CFLAGS $SDL_LIBS
   VNC support               $enable_vnc                 $VNC_CFLAGS $VNC_LIBS
+  STM stmfb support         $enable_stmfbdev
 
 Building Window Manager Modules:
   Default                   yes
@@ -3057,6 +3155,7 @@ Building Window Manager Modules:
 Building Image Provider Modules:
   GIF                       $enable_gif
   JPEG                      $JPEG                 $LIBJPEG
+    - hardware              $JPEG_HW
   PNG                       $PNG                  $LIBPNG_CFLAGS $LIBPNG_LIBS
   Imlib2                    $imlib2               $IMLIB2_CFLAGS $IMLIB2_LIBS
   PNM                       $enable_pnm
@@ -3156,7 +3255,7 @@ Building Input Drivers:
   Input Hub                 $enable_input_hub
   Joystick                  $enable_joystick
   Keyboard                  $enable_keyboard
-  Linux Input               $enable_linux_input
+  Linux Input               $enable_linux_input          $LIBUDEV_CFLAGS $LIBUDEV_LIBS
   LiRC                      $enable_lirc
   MuTouch touchscreen       $enable_mutouch
   Zytronic touchscreen      $enable_zytronic
diff --git a/gfxdrivers/gles2/gles2_2d.c b/gfxdrivers/gles2/gles2_2d.c
index c98ca9d..8e8242b 100644
--- a/gfxdrivers/gles2/gles2_2d.c
+++ b/gfxdrivers/gles2/gles2_2d.c
@@ -196,6 +196,10 @@ gles2_validate_DESTINATION(GLES2DriverData *gdrv,
      }
 #endif
 
+     DFBSurfaceBlittingFlags blittingflags = state->blittingflags;
+
+     dfb_simplify_blittingflags( &blittingflags );
+
      if (1/*(buffer->flags & GLES2BF_UPDATE_TARGET)*/ ||
          (gdev->prog_index != gdev->prog_last)) {
 
@@ -208,7 +212,8 @@ gles2_validate_DESTINATION(GLES2DriverData *gdrv,
 
           glViewport(0, 0, w, h);
 
-          if (state->render_options & DSRO_MATRIX) {
+          if (state->render_options & DSRO_MATRIX
+              || blittingflags & (DSBLIT_ROTATE90 | DSBLIT_FLIP_HORIZONTAL | DSBLIT_FLIP_VERTICAL)) {
                /*
              * We need a 3x3 matrix multiplication in the vertex shader to
              * support the non-affine elements of the DSRO matrix.  Load
@@ -599,7 +604,7 @@ gles2EngineSync(void *drv, void *dev)
      D_DEBUG_AT(GLES2__2D, "%s()\n", __FUNCTION__);
 
      if (gdrv->calls > 0) {
-//          glFinish();
+          glFinish();
           //eglSwapBuffers( eglGetCurrentDisplay(), eglGetCurrentSurface( EGL_DRAW ) );
           gdrv->calls = 0;
      }
@@ -705,11 +710,14 @@ gles2SetState(void                *drv,
      GLES2DeviceData       *gdev     = dev;
      StateModificationFlags modified = state->mod_hw;
      DFBBoolean             blend    = DFB_FALSE;
+     DFBSurfaceBlittingFlags blittingflags = state->blittingflags;
 
      D_DEBUG_AT(GLES2__2D,
                 "%s(state %p, accel 0x%08x) <- dest %p, modified 0x%08x\n",
                 __FUNCTION__, state, accel, state->destination, modified);
 
+     dfb_simplify_blittingflags( &blittingflags );
+
      /*
       * 1) Invalidate hardware states
       *
@@ -830,8 +838,8 @@ gles2SetState(void                *drv,
                GLES2_INVALIDATE(BLENDFUNC);
 
                // If alpha blending is used...
-               if (state->blittingflags & (DSBLIT_BLEND_ALPHACHANNEL |
-                                           DSBLIT_BLEND_COLORALPHA)) {
+               if (blittingflags & (DSBLIT_BLEND_ALPHACHANNEL |
+                                    DSBLIT_BLEND_COLORALPHA)) {
                     // ...require valid blend functions.
                     GLES2_CHECK_VALIDATE(BLENDFUNC);
                     glEnable(GL_BLEND);
@@ -849,7 +857,7 @@ gles2SetState(void                *drv,
                 * tracked by DFB.
                 */
                if (state->render_options & DSRO_MATRIX) {
-                    if (state->blittingflags & DSBLIT_SRC_COLORKEY && !blend) {
+                    if (blittingflags & DSBLIT_SRC_COLORKEY && !blend) {
                          if (gdev->prog_index != GLES2_BLIT_COLORKEY_MAT) {
 
                               gdev->prog_index = GLES2_BLIT_COLORKEY_MAT;
@@ -859,14 +867,14 @@ gles2SetState(void                *drv,
                               glEnable(GL_BLEND);
                          }
                     }
-                    else if (state->blittingflags & DSBLIT_SRC_PREMULTIPLY) {
+                    else if (blittingflags & DSBLIT_SRC_PREMULTIPLY) {
                          if (gdev->prog_index != GLES2_BLIT_PREMULTIPLY_MAT) {
 
                               gdev->prog_index = GLES2_BLIT_PREMULTIPLY_MAT;
                               glUseProgram(gdev->progs[gdev->prog_index].obj);
                          }
                     }
-                    else if (state->blittingflags & (DSBLIT_COLORIZE | DSBLIT_BLEND_COLORALPHA | DSBLIT_SRC_PREMULTCOLOR)) {
+                    else if (blittingflags & (DSBLIT_COLORIZE | DSBLIT_BLEND_COLORALPHA | DSBLIT_SRC_PREMULTCOLOR)) {
                          if (gdev->prog_index != GLES2_BLIT_COLOR_MAT) {
 
                               gdev->prog_index = GLES2_BLIT_COLOR_MAT;
@@ -882,7 +890,7 @@ gles2SetState(void                *drv,
                     }
                }
                else {
-                    if (state->blittingflags & DSBLIT_SRC_COLORKEY && !blend) {
+                    if (blittingflags & DSBLIT_SRC_COLORKEY && !blend) {
                          if (gdev->prog_index != GLES2_BLIT_COLORKEY) {
 
                               gdev->prog_index = GLES2_BLIT_COLORKEY;
@@ -892,14 +900,14 @@ gles2SetState(void                *drv,
                               glEnable(GL_BLEND);
                          }
                     }
-                    else if (state->blittingflags & DSBLIT_SRC_PREMULTIPLY) {
+                    else if (blittingflags & DSBLIT_SRC_PREMULTIPLY) {
                          if (gdev->prog_index != GLES2_BLIT_PREMULTIPLY) {
 
                               gdev->prog_index = GLES2_BLIT_PREMULTIPLY;
                               glUseProgram(gdev->progs[gdev->prog_index].obj);
                          }
                     }
-                    else if (state->blittingflags & (DSBLIT_COLORIZE | DSBLIT_BLEND_COLORALPHA | DSBLIT_SRC_PREMULTCOLOR)) {
+                    else if (blittingflags & (DSBLIT_COLORIZE | DSBLIT_BLEND_COLORALPHA | DSBLIT_SRC_PREMULTCOLOR)) {
                          if (gdev->prog_index != GLES2_BLIT_COLOR) {
 
                               gdev->prog_index = GLES2_BLIT_COLOR;
@@ -907,10 +915,16 @@ gles2SetState(void                *drv,
                          }
                     }
                     else {
-                         if (gdev->prog_index != GLES2_BLIT) {
-
-                              gdev->prog_index = GLES2_BLIT;
-                              glUseProgram(gdev->progs[gdev->prog_index].obj);
+                         if (blittingflags & (DSBLIT_ROTATE90 | DSBLIT_FLIP_HORIZONTAL | DSBLIT_FLIP_VERTICAL)) {
+                              if (gdev->prog_index != GLES2_BLIT_MAT) {
+                                   gdev->prog_index = GLES2_BLIT_MAT;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
+                         } else {
+                              if (gdev->prog_index != GLES2_BLIT) {
+                                   gdev->prog_index = GLES2_BLIT;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
                          }
                     }
                }
@@ -920,7 +934,7 @@ gles2SetState(void                *drv,
                GLES2_CHECK_VALIDATE(SOURCE);
 
                // If normal blitting or color keying is used...
-               if (accel == DFXL_BLIT || (state->blittingflags & DSBLIT_SRC_COLORKEY)) {
+               if (accel == DFXL_BLIT || (blittingflags & DSBLIT_SRC_COLORKEY)) {
                     // ...don't use filtering
                     glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
                     glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
@@ -963,7 +977,7 @@ gles2SetState(void                *drv,
                break;
      }
 
-     gdrv->blittingflags = state->blittingflags;
+     gdrv->blittingflags = blittingflags;
 
      /*
       * prog_last is used by some state setting functions to determine if a
@@ -1096,6 +1110,22 @@ gles2FillTriangle(void *drv, void *dev, DFBTriangle *tri)
      return true;
 }
 
+static inline void
+multMatrix3fv(float* m, float *n, float *q)
+{
+     float p[9];
+     int i, j, k;
+
+     memset(p, 0, sizeof(p));
+
+     for (i = 0; i < 3; i++)
+          for (j = 0; j < 3; j++)
+               for (k = 0; k < 3; k++)
+                    p[j + 3 * i] += m[k + 3 * i] * n[j + 3 * k];
+
+     memcpy(q, p, sizeof(p));
+}
+
 /*
  * Blit a rectangle using the current hardware state.
  */
@@ -1103,6 +1133,7 @@ bool
 gles2Blit(void *drv, void *dev, DFBRectangle *srect, int dx, int dy)
 {
      GLES2DriverData *gdrv = drv;
+     GLES2DeviceData *gdev = dev;
 
      float x1 = dx;
      float y1 = dy;
@@ -1114,26 +1145,67 @@ gles2Blit(void *drv, void *dev, DFBRectangle *srect, int dx, int dy)
      float tx2 = srect->w + tx1;
      float ty2 = srect->h + ty1;
 
-     GLfloat pos[] = {
-          x1, y1,   x2, y1,   x2, y2,   x1, y2
-     };
-
+     GLfloat pos[8];
      GLfloat tex[8];
 
      D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d <- %4d,%4d)\n",
                 __FUNCTION__, dx, dy, srect->w, srect->h, srect->x, srect->y);
 
-     if (gdrv->blittingflags & DSBLIT_ROTATE180) {
-          tex[0] = tx2; tex[1] = ty2;
-          tex[2] = tx1; tex[3] = ty2;
-          tex[4] = tx1; tex[5] = ty1;
-          tex[6] = tx2; tex[7] = ty1;
-     }
-     else {
-          tex[0] = tx1; tex[1] = ty1;
-          tex[2] = tx2; tex[3] = ty1;
-          tex[4] = tx2; tex[5] = ty2;
-          tex[6] = tx1; tex[7] = ty2;
+     tex[0] = tx1; tex[1] = ty1;
+     tex[2] = tx2; tex[3] = ty1;
+     tex[4] = tx2; tex[5] = ty2;
+     tex[6] = tx1; tex[7] = ty2;
+
+     if (gdrv->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_FLIP_HORIZONTAL | DSBLIT_FLIP_VERTICAL)) {
+          float trfm[9], m[9];
+
+          float x0 = (x1 + x2) / 2;
+          float y0 = (y1 + y2) / 2;
+
+          pos[0] = x1 - x0; pos[1] = y1 - y0;
+          pos[2] = x2 - x0; pos[3] = y1 - y0;
+          pos[4] = x2 - x0; pos[5] = y2 - y0;
+          pos[6] = x1 - x0; pos[7] = y2 - y0;
+
+          /* identity */
+          trfm[0] = 1; trfm[3] = 0; trfm[6] = 0;
+          trfm[1] = 0; trfm[4] = 1; trfm[7] = 0;
+          trfm[2] = 0; trfm[5] = 0; trfm[8] = 1;
+
+          if (gdrv->blittingflags & DSBLIT_FLIP_HORIZONTAL) {
+               m[0] = -1; m[3] = 0; m[6] = 0;
+               m[1] = 0; m[4] = 1; m[7] = 0;
+               m[2] = 0; m[5] = 0; m[8] = 1;
+               multMatrix3fv(trfm, m, trfm);
+          }
+
+          if (gdrv->blittingflags & DSBLIT_FLIP_VERTICAL) {
+               m[0] = 1; m[3] = 0; m[6] = 0;
+               m[1] = 0; m[4] = -1; m[7] = 0;
+               m[2] = 0; m[5] = 0; m[8] = 1;
+               multMatrix3fv(trfm, m, trfm);
+          }
+
+          if (gdrv->blittingflags & DSBLIT_ROTATE90) {
+               m[0] = 0; m[3] = 1; m[6] = 0;
+               m[1] = -1; m[4] = 0; m[7] = 0;
+               m[2] = 0; m[5] = 0; m[8] = 1;
+               multMatrix3fv(trfm, m, trfm);
+          }
+
+          /* finally translate to x0, y0 */
+          m[0] = 1; m[3] = 0; m[6] = x0;
+          m[1] = 0; m[4] = 1; m[7] = y0;
+          m[2] = 0; m[5] = 0; m[8] = 1;
+          multMatrix3fv(trfm, m, trfm);
+
+          GLES2ProgramInfo *prog = &gdev->progs[gdev->prog_index];
+          glUniformMatrix3fv(prog->dfbROMatrix, 1, GL_FALSE, trfm);
+     } else {
+          pos[0] = x1; pos[1] = y1;
+          pos[2] = x2; pos[3] = y1;
+          pos[4] = x2; pos[5] = y2;
+          pos[6] = x1; pos[7] = y2;
      }
 
      glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
@@ -1164,6 +1236,13 @@ gles2BatchBlit(void *drv, void *dev,
      //     D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d <- %4d,%4d)\n",
      //                __FUNCTION__, dx, dy, srect->w, srect->h, srect->x, srect->y);
 
+     if (num == 1)
+          return gles2Blit(drv, dev, rects, points[0].x, points[0].y);
+
+     /* can't support these as a per-triangle transform (uniform) is required */
+     if (gdrv->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_FLIP_HORIZONTAL | DSBLIT_FLIP_VERTICAL))
+          return false;
+
      for (i=0; i<num; i++) {
           float x1 = points[i].x;
           float y1 = points[i].y;
@@ -1233,6 +1312,7 @@ gles2StretchBlit(void *drv, void *dev,
                  DFBRectangle *srect, DFBRectangle *drect)
 {
      GLES2DriverData *gdrv = drv;
+     GLES2DeviceData *gdev = dev;
 
      float x1 = drect->x;
      float y1 = drect->y;
@@ -1244,27 +1324,66 @@ gles2StretchBlit(void *drv, void *dev,
      float tx2 = srect->w + tx1;
      float ty2 = srect->h + ty1;
 
-     GLfloat pos[] = {
-          x1, y1,   x2, y1,   x2, y2,   x1, y2
-     };
-
+     GLfloat pos[8];
      GLfloat tex[8];
 
      D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d <- %4d,%4d-%4dx%4d)\n",
                 __FUNCTION__, DFB_RECTANGLE_VALS(drect),
                 DFB_RECTANGLE_VALS(srect));
 
-     if (gdrv->blittingflags & DSBLIT_ROTATE180) {
-          tex[0] = tx2; tex[1] = ty2;
-          tex[2] = tx1; tex[3] = ty2;
-          tex[4] = tx1; tex[5] = ty1;
-          tex[6] = tx2; tex[7] = ty1;
-     }
-     else {
-          tex[0] = tx1; tex[1] = ty1;
-          tex[2] = tx2; tex[3] = ty1;
-          tex[4] = tx2; tex[5] = ty2;
-          tex[6] = tx1; tex[7] = ty2;
+     tex[0] = tx1; tex[1] = ty1;
+     tex[2] = tx2; tex[3] = ty1;
+     tex[4] = tx2; tex[5] = ty2;
+     tex[6] = tx1; tex[7] = ty2;
+
+     if (gdrv->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_FLIP_HORIZONTAL | DSBLIT_FLIP_VERTICAL)) {
+          float trfm[9], m[9];
+
+          float x0 = (x1 + x2) / 2;
+          float y0 = (y1 + y2) / 2;
+
+          pos[0] = x1 - x0; pos[1] = y1 - y0;
+          pos[2] = x2 - x0; pos[3] = y1 - y0;
+          pos[4] = x2 - x0; pos[5] = y2 - y0;
+          pos[6] = x1 - x0; pos[7] = y2 - y0;
+
+          trfm[0] = 1; trfm[3] = 0; trfm[6] = 0;
+          trfm[1] = 0; trfm[4] = 1; trfm[7] = 0;
+          trfm[2] = 0; trfm[5] = 0; trfm[8] = 1;
+
+          if (gdrv->blittingflags & DSBLIT_FLIP_HORIZONTAL) {
+               m[0] = -1; m[3] = 0; m[6] = 0;
+               m[1] = 0; m[4] = 1; m[7] = 0;
+               m[2] = 0; m[5] = 0; m[8] = 1;
+               multMatrix3fv(trfm, m, trfm);
+          }
+
+          if (gdrv->blittingflags & DSBLIT_FLIP_VERTICAL) {
+               m[0] = 1; m[3] = 0; m[6] = 0;
+               m[1] = 0; m[4] = -1; m[7] = 0;
+               m[2] = 0; m[5] = 0; m[8] = 1;
+               multMatrix3fv(trfm, m, trfm);
+          }
+
+          if (gdrv->blittingflags & DSBLIT_ROTATE90) {
+               m[0] = 0; m[3] = 1; m[6] = 0;
+               m[1] = -1; m[4] = 0; m[7] = 0;
+               m[2] = 0; m[5] = 0; m[8] = 1;
+               multMatrix3fv(trfm, m, trfm);
+          }
+
+          m[0] = 1; m[3] = 0; m[6] = x0;
+          m[1] = 0; m[4] = 1; m[7] = y0;
+          m[2] = 0; m[5] = 0; m[8] = 1;
+          multMatrix3fv(trfm, m, trfm);
+
+          GLES2ProgramInfo *prog = &gdev->progs[gdev->prog_index];
+          glUniformMatrix3fv(prog->dfbROMatrix, 1, GL_FALSE, trfm);
+     } else {
+          pos[0] = x1; pos[1] = y1;
+          pos[2] = x2; pos[3] = y1;
+          pos[4] = x2; pos[5] = y2;
+          pos[6] = x1; pos[7] = y2;
      }
 
      glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
diff --git a/gfxdrivers/gles2/gles2_2d.h b/gfxdrivers/gles2/gles2_2d.h
index eb5a99c..d8c8afb 100644
--- a/gfxdrivers/gles2/gles2_2d.h
+++ b/gfxdrivers/gles2/gles2_2d.h
@@ -48,9 +48,14 @@
                                            DSBLIT_BLEND_COLORALPHA   | \
                                            DSBLIT_COLORIZE           | \
                                            DSBLIT_ROTATE180          | \
+                                           DSBLIT_ROTATE90           | \
+                                           DSBLIT_ROTATE270          | \
+                                           DSBLIT_FLIP_HORIZONTAL    | \
+                                           DSBLIT_FLIP_VERTICAL      | \
                                            DSBLIT_SRC_PREMULTIPLY    | \
                                            DSBLIT_SRC_PREMULTCOLOR   | \
-                                           DSBLIT_SRC_COLORKEY)
+                                           DSBLIT_SRC_COLORKEY       | \
+                                           DSBLIT_DST_COLORKEY  )
 
 #define GLES2_SUPPORTED_BLITTINGFUNCTIONS (DFXL_BLIT | \
                                            DFXL_STRETCHBLIT)
diff --git a/gfxdrivers/gles2/gles2_shaders.c b/gfxdrivers/gles2/gles2_shaders.c
index 7596004..03ce51d 100644
--- a/gfxdrivers/gles2/gles2_shaders.c
+++ b/gfxdrivers/gles2/gles2_shaders.c
@@ -120,6 +120,8 @@ init_program(GLuint prog_obj,
           glDetachShader(prog_obj, shaders[0]);
           glDetachShader(prog_obj, shaders[1]);
 
+          glUseProgram( prog_obj );
+
           return DFB_TRUE;
      }
      else {
@@ -133,8 +135,6 @@ init_program(GLuint prog_obj,
 
           return DFB_FALSE;
      }
-
-     glUseProgram( prog_obj );
 }
 
 #define GET_UNIFORM_LOCATION(dev, index, name)				\
diff --git a/gfxdrivers/gles2/gles2_shaders.h b/gfxdrivers/gles2/gles2_shaders.h
index 41c21c9..a804ade 100644
--- a/gfxdrivers/gles2/gles2_shaders.h
+++ b/gfxdrivers/gles2/gles2_shaders.h
@@ -34,9 +34,9 @@
 #define HIGHP       "highp"
 #define GL_POS_Y_OP "+"
 #else
-#define LOWP        ""
-#define MEDIUMP     ""
-#define HIGHP       ""
+#define LOWP        "lowp"
+#define MEDIUMP     "mediump"
+#define HIGHP       "highp"
 #define GL_POS_Y_OP "-"
 #endif
 
diff --git a/include/directfb.h b/include/directfb.h
index 0cd54fc..d251e7d 100644
--- a/include/directfb.h
+++ b/include/directfb.h
@@ -544,7 +544,8 @@ typedef enum {
 typedef enum {
      DIRENDER_NONE           = 0x00000000,
      DIRENDER_FAST           = 0x00000001,   /* Select fast rendering method */
-     DIRENDER_ALL            = 0x00000001
+     DIRENDER_BACKGROUND     = 0x00000002,   /* Async rendering */
+     DIRENDER_ALL            = 0x00000003
 } DIRenderFlags;
 
 /*
@@ -860,8 +861,9 @@ typedef enum {
      DIDTF_JOYSTICK      = 0x00000004,  /* Can be used as a joystick. */
      DIDTF_REMOTE        = 0x00000008,  /* Is a remote control. */
      DIDTF_VIRTUAL       = 0x00000010,  /* Is a virtual input device. */
+     DIDTF_SENSOR        = 0x00000020,  /* Is a motion sensing input device. */
 
-     DIDTF_ALL           = 0x0000001F   /* All type flags set. */
+     DIDTF_ALL           = 0x0000003F   /* All type flags set. */
 } DFBInputDeviceTypeFlags;
 
 /*
@@ -872,8 +874,9 @@ typedef enum {
      DICAPS_KEYS         = 0x00000001,  /* device supports key events */
      DICAPS_AXES         = 0x00000002,  /* device supports axis events */
      DICAPS_BUTTONS      = 0x00000004,  /* device supports button events */
+     DICAPS_SENSORS      = 0x00000008,  /* device supports sensor events */
 
-     DICAPS_ALL          = 0x00000007   /* all capabilities */
+     DICAPS_ALL          = 0x0000000F   /* all capabilities */
 #else
      DIDCAPS_NONE        = 0x00000000,  /* device supports no events */
      DIDCAPS_KEYS        = 0x00000001,  /* device supports key events */ 
@@ -914,6 +917,26 @@ typedef enum {
      DIAI_LAST           = 0x0000001F   /* 32 axes maximum */
 } DFBInputDeviceAxisIdentifier;
 
+
+/*
+ * Sensors identifiers for sensors-equipped input devices
+ *
+ * Only motion generating sensors are defined here. Depending on its type as
+ * specified by DFBInputDeviceSensorIdentifier, the actual sensor data is
+ * stored in the <i>sensor_data</i> field of the DFBInputEvent structure and
+ * is expressed in a common referential (unit) across devices.
+ */
+typedef enum {
+     DISI_ACCELEROMETER       = 0x00000001,  /* Accelerometer sensor type */
+     DISI_GYROSCOPE           = 0x00000002,  /* Device rotation around
+                                                X, Y and Z axes  */
+     DISI_LINEAR_ACCELERATION = 0x00000010,  /* Acceleration along each device
+                                                axis (without gravity value) */
+     DISI_ORIENTATION         = 0x00000020,  /* Yaw, pitch and roll */
+     DISI_ALL                 = 0x0000003F   /* All sensors mask */
+} DFBInputDeviceSensorIdentifier;
+
+
 /*
  * Flags defining which fields of a DFBWindowDescription are valid.
  */
@@ -1311,11 +1334,24 @@ typedef enum {
      DSPF_ALUT8     = DFB_SURFACE_PIXELFORMAT( 40,  8, 8, 1, 0, 2, 0, 0, 0, 1, 0 ),
 
      /*  1 bit    LUT (1 byte/ 8 pixel, 1 bit color and alpha lookup from palette) */
-     DSPF_LUT1      = DFB_SURFACE_PIXELFORMAT( 41,  1, 0, 1, 1, 0, 7, 0, 0, 1, 0 )
+     DSPF_LUT1      = DFB_SURFACE_PIXELFORMAT( 41,  1, 0, 1, 1, 0, 7, 0, 0, 1, 0 ),
+
+     /* 24 bit   RGB (3 byte, blue 8@16, green 8@8, red 8@0) */
+     DSPF_BGR24     = DFB_SURFACE_PIXELFORMAT( 42, 24, 0, 0, 0, 3, 0, 0, 0, 0, 0 ),
+
+     /* 12 bit   YUV (8 bit Y plane followed by one 16 bit quarter size Cb|Cr [7:0|7:0] plane) in Omega2 macroblock format */
+     DSPF_NV12MB    = DFB_SURFACE_PIXELFORMAT( 43, 12, 0, 0, 0, 1, 0, 2, 0, 0, 0 ),
+
+     /* 16 bit   YUV (8 bit Y plane followed by one 16 bit half width Cb|Cr [7:0|7:0] plane) in Omega2 macroblock format */
+     DSPF_NV16MB    = DFB_SURFACE_PIXELFORMAT( 44, 24, 0, 0, 0, 1, 0, 0, 1, 0, 0 ),
+
+     /* 24 bit   YUV (8 bit Y plane followed by one 16 bit full width Cb|Cr [7:0|7:0] plane) */
+     DSPF_NV24     = DFB_SURFACE_PIXELFORMAT( 45, 24, 0, 0, 0, 1, 0, 0, 2, 0, 0 )
+
 } DFBSurfacePixelFormat;
 
 /* Number of pixelformats defined */
-#define DFB_NUM_PIXELFORMATS            42
+#define DFB_NUM_PIXELFORMATS            46
 
 /* These macros extract information about the pixel format. */
 #define DFB_PIXELFORMAT_INDEX(fmt)      (((fmt) & 0x0000007F)      )
@@ -1361,6 +1397,7 @@ typedef enum {
       ((fmt) == DSPF_BGR555)       ||   \
       ((fmt) == DSPF_ARGB8565)     ||   \
       ((fmt) == DSPF_ABGR)         ||   \
+      ((fmt) == DSPF_BGR24)        ||   \
       ((fmt) == DSPF_RGBAF88871))
 
 #define DFB_COLOR_IS_YUV(fmt)           \
@@ -1370,7 +1407,10 @@ typedef enum {
       ((fmt) == DSPF_YV12)         ||   \
       ((fmt) == DSPF_NV12)         ||   \
       ((fmt) == DSPF_NV16)         ||   \
+      ((fmt) == DSPF_NV12MB)       ||   \
+      ((fmt) == DSPF_NV16MB)       ||   \
       ((fmt) == DSPF_NV21)         ||   \
+      ((fmt) == DSPF_NV24)         ||   \
       ((fmt) == DSPF_AYUV)         ||   \
       ((fmt) == DSPF_YUV444P)      ||   \
       ((fmt) == DSPF_AVYU)         ||   \
@@ -1550,6 +1590,8 @@ typedef struct {
                                                         identifier */
      DFBInputDeviceButtonIdentifier     max_button;  /* highest button
                                                         identifier */
+     DFBInputDeviceSensorIdentifier     sensors;     /* supported sensors
+                                                        identifier */
 
      char name[DFB_INPUT_DEVICE_DESC_NAME_LENGTH];   /* Device name */
 
@@ -1741,12 +1783,25 @@ typedef enum {
 typedef enum {
      DVPLAY_NOFX        = 0x00000000, /* normal playback           */
      DVPLAY_REWIND      = 0x00000001, /* reverse playback          */
-     DVPLAY_LOOPING     = 0x00000002  /* automatically restart
+     DVPLAY_LOOPING     = 0x00000002, /* automatically restart
                                          playback when end-of-stream
                                          is reached (gapless).     */
+     DVPLAY_PACED       = 0x00000004, /* decoding pace is controlled
+                                         by the caller, the decoder
+                                         won't wait on its own while
+                                         decoding frames.          */
 } DFBVideoProviderPlaybackFlags;
 
 /*
+ * Playback context passed to IDirectFBVideoProvider::PlayTo()
+ * when decoding in DVPLAY_PACED mode.
+ */
+typedef struct {
+     unsigned int num_frame;
+     void        *ctx;
+} DFBVideoProviderPacedPlaybackCtx;
+
+/*
  * Flags to allow Audio Unit selection.
  */
 typedef enum {
@@ -5272,7 +5327,8 @@ typedef enum {
      DIET_KEYRELEASE,              /* a key is been released */
      DIET_BUTTONPRESS,             /* a (mouse) button is been pressed */
      DIET_BUTTONRELEASE,           /* a (mouse) button is been released */
-     DIET_AXISMOTION               /* mouse/joystick movement */
+     DIET_AXISMOTION,              /* mouse/joystick movement */
+     DIET_SENSOR,                  /* sensor event */
 } DFBInputEventType;
 
 /*
@@ -5306,7 +5362,10 @@ typedef enum {
      DIEF_FOLLOW         = 0x0800,   /* another event will follow immediately, e.g. x/y axis */
 
      DIEF_MIN            = 0x1000,   /* minimum value is set, e.g. for absolute axis motion */
-     DIEF_MAX            = 0x2000    /* maximum value is set, e.g. for absolute axis motion */
+     DIEF_MAX            = 0x2000,   /* maximum value is set, e.g. for absolute axis motion */
+
+     DIEF_SENSOR         = 0x4000,   /* sensor type and data are valid, contents
+                                        depend on sensor type */
 } DFBInputEventFlags;
 
 /*
@@ -5357,6 +5416,11 @@ typedef struct {
      /* general information */
      int                             min;        /* minimum possible value */
      int                             max;        /* maximum possible value */
+
+/* DIET_SENSOR */
+     DFBInputDeviceSensorIdentifier  sensor;     /* in case of a sensor event */
+     float                           sensor_data[3]; /* sensor data, depending
+                                                        on DFBInputDeviceSensorIdentifier */
 } DFBInputEvent;
 
 /*
@@ -5612,6 +5676,7 @@ typedef struct {
      unsigned int   DIET_BUTTONPRESS;
      unsigned int   DIET_BUTTONRELEASE;
      unsigned int   DIET_AXISMOTION;
+     unsigned int   DIET_SENSOR;
 
      unsigned int   DWET_POSITION;
      unsigned int   DWET_SIZE;
@@ -6774,6 +6839,14 @@ D_DEFINE_INTERFACE(   IDirectFBFont,
 )
 
 /*
+ * Flags for image providers.
+ */
+typedef enum {
+    DIPSYNCFLAGS_SYNC, /* sync, i.e. wait for the image provider to finish */
+    DIPSYNCFLAGS_TRYSYNC /* figure out if image provider is finished or still busy */
+} DFBImageProviderSyncFlags;
+
+/*
  * Capabilities of an image.
  */
 typedef enum {
@@ -6870,6 +6943,10 @@ D_DEFINE_INTERFACE(   IDirectFBImageProvider,
       * Registers a callback for progressive image loading.
       *
       * The function is called each time a chunk of the image is decoded.
+      *
+      * In case of an image provider working in the background, the
+      * callback could be called in a different thread context! So you
+      * might have to take appropriate actions to handle this.
       */
      DFBResult (*SetRenderCallback) (
           IDirectFBImageProvider   *thiz,
@@ -6882,6 +6959,30 @@ D_DEFINE_INTERFACE(   IDirectFBImageProvider,
       *
       * This is optional and might be unsupported by some image providers
       */
+     /*
+      * Set image provider flags.
+      *
+      * This allows one to switch an image provider's mode of
+      * operation, between default and background.
+      *
+      * In default (which is also the traditional) mode, a call to
+      * RenderTo() will block until the image provider has finished
+      * decoding the image. This is also the behaviour if this API
+      * is not used at all.
+      *
+      * In background mode, the image is being decoded in the background,
+      * i.e. the call to RenderTo() will return almost immediately. The
+      * application may do other useful processing while the image is being
+      * decoded. In most implementations, background decode will just use
+      * a worker thread.
+      *
+      * Not all image providers support background mode and will return
+      * DFB_UNSUPPORTED in that case.
+      *
+      * Calling SetFlags() after RenderTo() makes no sense and is
+      * unsupported.
+      *
+      */
      DFBResult (*SetRenderFlags) (
           IDirectFBImageProvider   *thiz,
           DIRenderFlags            flags
@@ -6898,6 +6999,25 @@ D_DEFINE_INTERFACE(   IDirectFBImageProvider,
           const DFBRectangle       *src_rect,
           const char               *filename
      );
+
+
+   /** Rendering **/
+
+     /*
+      * For a background image provider, waits for it to finish
+      * decoding the image.
+      *
+      * For a default image provider, does nothing.
+      *
+      * This needs to be called for background image providers
+      * before accessing the destination surface (using either the
+      * software or the hardware), to make sure that the image has been
+      * completely decoded.
+      */
+     DFBResult (*Sync) (
+          IDirectFBImageProvider    *thiz,
+          DFBImageProviderSyncFlags  flags
+     );
 )
 
 /*
diff --git a/inputdrivers/Makefile.am b/inputdrivers/Makefile.am
index d570ae4..9fbd188 100644
--- a/inputdrivers/Makefile.am
+++ b/inputdrivers/Makefile.am
@@ -84,6 +84,12 @@ if WM97XX_TS
 WM97XX_TS_DIR = wm97xx_ts
 endif
 
+if WAYLAND_CORE
+WAYLAND_DIR = wayland
+else
+WAYLAND_DIR =
+endif
+
 SUBDIRS = \
 	$(DBOX2REMOTE_DIR)	\
 	$(DIVINE_DIR)		\
@@ -105,4 +111,5 @@ SUBDIRS = \
 	$(SONYPI_DIR)		\
 	$(TSLIB_DIR)		\
 	$(UCB1X00_TS_DIR)	\
-	$(WM97XX_TS_DIR)
+	$(WM97XX_TS_DIR) \
+	$(WAYLAND_DIR)
diff --git a/inputdrivers/linux_input/Makefile.am b/inputdrivers/linux_input/Makefile.am
index 13fb48f..d0d9549 100644
--- a/inputdrivers/linux_input/Makefile.am
+++ b/inputdrivers/linux_input/Makefile.am
@@ -20,6 +20,9 @@ libdirectfb_linux_input_la_SOURCES = \
 	input_fake.h		\
 	linux_input.c
 
+libdirectfb_linux_input_la_CFLAGS = \
+	$(LIBUDEV_CFLAGS)
+
 libdirectfb_linux_input_la_LDFLAGS = \
 	-module			\
 	-avoid-version		\
@@ -27,7 +30,8 @@ libdirectfb_linux_input_la_LDFLAGS = \
 
 libdirectfb_linux_input_la_LIBADD = \
 	$(top_builddir)/lib/direct/libdirect.la \
-	$(top_builddir)/src/libdirectfb.la
+	$(top_builddir)/src/libdirectfb.la \
+	$(LIBUDEV_LIBS)
 
 
 include $(top_srcdir)/rules/libobject.make
diff --git a/inputdrivers/linux_input/linux_input.c b/inputdrivers/linux_input/linux_input.c
index 7e9a6ad..9728cc3 100644
--- a/inputdrivers/linux_input/linux_input.c
+++ b/inputdrivers/linux_input/linux_input.c
@@ -112,10 +112,13 @@ typedef unsigned long kernel_ulong_t;
 #include <sys/socket.h>
 #include <sys/un.h>
 
+#include <libudev.h>
+
 /* Exclude hot-plug stub functionality from this input provider. */
 #define DISABLE_INPUT_HOTPLUG_FUNCTION_STUB
 
 #include <fbdev/fbdev.h>
+#include <stmfbdev/stmfbdev.h>
 
 #include <core/input_driver.h>
 
@@ -201,6 +204,9 @@ static pthread_mutex_t   driver_suspended_lock;
 /* Flag that indicates if the driver is suspended when true. */
 static bool              driver_suspended = false;
 
+static struct udev *udev;
+static struct udev_monitor *mon;
+
 
 static const
 int basic_keycodes [] = {
@@ -1258,7 +1264,7 @@ driver_get_available( void )
      int   i;
      char *tsdev;
 
-     if (!(dfb_config->linux_input_force || (dfb_system_type() == CORE_FBDEV) || (dfb_system_type() == CORE_MESA) || (dfb_system_type() == CORE_DRMKMS)  ))
+     if (!(dfb_config->linux_input_force || (dfb_system_type() == CORE_FBDEV) || (dfb_system_type() == CORE_MESA) || (dfb_system_type() == CORE_DRMKMS) || (dfb_system_type() == CORE_STMFBDEV)  ))
           return 0;
 
      if (dfb_system_type() == CORE_FBDEV && !dfb_config->linux_input_force) {
@@ -1271,6 +1277,16 @@ driver_get_available( void )
           if (!dfb_fbdev->vt || dfb_fbdev->vt->fd < 0)
                return 0;
      }
+     else if (dfb_system_type() == CORE_STMFBDEV) {
+          const STMfbdev * const dfb_stm_fbdev = dfb_system_data();
+          D_ASSERT( dfb_stm_fbdev );
+
+          // Only allow USB keyboard and mouse support if the systems driver has
+          // the Virtual Terminal file ("/dev/tty0") open and available for use.
+          // FIXME:  Additional logic needed for system drivers not similar to fbdev?
+          if (!dfb_stm_fbdev->vt || dfb_stm_fbdev->vt->fd < 0)
+               return 0;
+     }
 
      /* Use the devices specified in the configuration. */
      if (fusion_vector_has_elements( &dfb_config->linux_input_devices )) {
@@ -1296,6 +1312,7 @@ driver_get_available( void )
      tsdev = getenv( "TSLIB_TSDEVICE" );
 
      /* No devices specified. Try to guess some. */
+
      for (i=0; i<MAX_LINUX_INPUT_DEVICES; i++) {
           char buf[32];
 
@@ -1475,7 +1492,7 @@ get_capability( void )
 
      InputDriverCapability   capabilities = IDC_NONE;
 
-     if (!(dfb_config->linux_input_force || (dfb_system_type() == CORE_FBDEV) || (dfb_system_type() == CORE_MESA) ))
+     if (!(dfb_config->linux_input_force || (dfb_system_type() == CORE_FBDEV) || (dfb_system_type() == CORE_MESA) || (dfb_system_type() == CORE_STMFBDEV) ))
           goto exit;
 
      if (dfb_system_type() == CORE_FBDEV) {
@@ -1490,6 +1507,16 @@ get_capability( void )
                goto exit;
           }
      }
+     if (dfb_system_type() == CORE_STMFBDEV) {
+          const STMfbdev * const dfb_stm_fbdev = dfb_system_data();
+          D_ASSERT( dfb_stm_fbdev );
+
+          // Only allow USB keyboard and mouse support if the systems driver has
+          // the Virtual Terminal file ("/dev/tty0") open and available for use.
+          // FIXME:  Additional logic needed for system drivers not similar to fbdev?
+          if (!dfb_stm_fbdev->vt || dfb_stm_fbdev->vt->fd < 0)
+               goto exit;
+     }
 
      D_DEBUG_AT( Debug_LinuxInput, "  -> returning HOTPLUG\n" );
 
@@ -1511,8 +1538,6 @@ udev_hotplug_EventThread(DirectThread *thread, void * hotplug_data)
      CoreDFB           *core;
      void              *driver;
      HotplugThreadData *data = (HotplugThreadData *)hotplug_data;
-     int                rt;
-     struct sockaddr_un sock_addr;
      int                fdmax;
 
      D_ASSERT( data != NULL );
@@ -1525,9 +1550,15 @@ udev_hotplug_EventThread(DirectThread *thread, void * hotplug_data)
      /* Free no needed data packet */
      D_FREE(data);
 
-     /* Open and bind the socket /org/kernel/udev/monitor */
+     udev = udev_new();
+
+     /* setup udev monitor to monitor input devices */
+     mon = udev_monitor_new_from_netlink(udev, "udev");
 
-     socket_fd = socket(AF_UNIX, SOCK_DGRAM, 0);
+     udev_monitor_filter_add_match_subsystem_devtype(mon, "input", NULL);
+     udev_monitor_enable_receiving(mon);
+
+     socket_fd = udev_monitor_get_fd(mon);
      if (socket_fd == -1) {
           D_PERROR( "DirectFB/linux_input: socket() failed: %s\n",
                     strerror(errno) );
@@ -1536,32 +1567,17 @@ udev_hotplug_EventThread(DirectThread *thread, void * hotplug_data)
 
      fdmax = MAX( socket_fd, hotplug_quitpipe[0] );
 
-     memset(&sock_addr, 0, sizeof(sock_addr));
-     sock_addr.sun_family = AF_UNIX;
-     strncpy(&sock_addr.sun_path[1],
-             "/org/kernel/udev/monitor",
-             sizeof(sock_addr.sun_path) - 1);
-
-     rt = bind(socket_fd, &sock_addr,
-               sizeof(sock_addr.sun_family)+1+strlen(&sock_addr.sun_path[1]));
-     if (rt < 0) {
-          D_PERROR( "DirectFB/linux_input: bind() failed: %s\n",
-                    strerror(errno) );
-          goto errorExit;
-     }
-
      while(1) {
-          char      udev_event[MAX_LENGTH_OF_EVENT_STRING];
           char     *pos;
-          char     *event_cont; //udev event content
-          int       device_num, number_file, recv_len, index;
+          int       device_num, number_file, index;
           DFBResult ret;
           fd_set    rset;
 
+
           /* get udev event */
           FD_ZERO(&rset);
-          FD_SET(socket_fd, &rset);
           FD_SET(hotplug_quitpipe[0], &rset);
+          FD_SET(socket_fd, &rset);
 
           number_file = select(fdmax+1, &rset, NULL, NULL, NULL);
 
@@ -1575,85 +1591,72 @@ udev_hotplug_EventThread(DirectThread *thread, void * hotplug_data)
           direct_thread_testcancel( thread );
 
           if (FD_ISSET(socket_fd, &rset)) {
-               recv_len = recv(socket_fd, udev_event, sizeof(udev_event), 0);
-               if (recv_len <= 0) {
-                    D_DEBUG_AT( Debug_LinuxInput,
-                                "error receiving uevent message: %s\n",
-                                strerror(errno) );
-                    continue;
-               }
-               /* check cancel thread */
                direct_thread_testcancel( thread );
-          }
-          /* analysize udev event */
+               struct udev_device *dev = udev_monitor_receive_device(mon);
 
-          pos = strchr(udev_event, '@');
-          if (pos == NULL)
-               continue;
-
-          /* replace '@' with '\0' to separate event type and event content */
-          *pos = '\0';
-
-          event_cont = pos + 1;
-
-          pos = strstr(event_cont, "/event");
-          if (pos == NULL)
-               continue;
+               if (dev) {
+                    pos = (char *)udev_device_get_devnode(dev);
+                    if (pos == NULL) {
+                         udev_device_unref(dev);
+                         continue;
+                    }
 
-          /* get event device number */
-          device_num = atoi(pos + 6);
+                    pos = strstr(pos, "/event");
+                    if (pos == NULL) {
+                         udev_device_unref(dev);
+                         continue;
+                    }
 
-          /* Attempt to lock the driver suspended mutex. */
-          pthread_mutex_lock(&driver_suspended_lock);
-          if (driver_suspended)
-          {
-               /* Release the lock and quit handling hotplug events. */
-               D_DEBUG_AT( Debug_LinuxInput, "Driver is suspended\n" );
-               pthread_mutex_unlock(&driver_suspended_lock);
-               continue;
-          }
+                    ///* get event device number */
+                    device_num = atoi(pos + 6);
 
-          /* Handle hotplug events since the driver is not suspended. */
-          if (!strcmp(udev_event, "add")) {
-               D_DEBUG_AT( Debug_LinuxInput,
-                           "Device node /dev/input/event%d is created by udev\n",
-                           device_num);
-
-               ret = register_device_node( device_num, &index);
-               if ( DFB_OK == ret) {
-                    /* Handle the event that the input device node is created */
-                    ret = dfb_input_create_device(index, core, driver);
-
-                    /* If cannot create the device within Linux Input
-                     * provider, inform the user.
-                     */
-                    if ( DFB_OK != ret) {
+                    if (!strcmp(udev_device_get_action(dev), "add")) {
                          D_DEBUG_AT( Debug_LinuxInput,
-                                     "Linux/Input: Failed to create the "
-                                     "device for /dev/input/event%d\n",
-                                     device_num );
+                                     "Device node /dev/input/event%d is created by udev\n",
+                                     device_num);
+
+                         ret = register_device_node( device_num, &index);
+                         if ( DFB_OK == ret) {
+                              /* Handle the event that the input device node is created */
+                              ret = dfb_input_create_device(index, core, driver);
+
+                              /* If cannot create the device within Linux Input
+                               * provider, inform the user.
+                               */
+                              if ( DFB_OK != ret) {
+                                   D_DEBUG_AT( Debug_LinuxInput,
+                                               "Linux/Input: Failed to create the "
+                                               "device for /dev/input/event%d\n",
+                                               device_num );
+                              }
+                         }
                     }
-               }
-          }
-          else if (!strcmp(udev_event, "remove")) {
-               D_DEBUG_AT( Debug_LinuxInput,
-                           "Device node /dev/input/event%d is removed by udev\n",
-                           device_num );
-               ret = unregister_device_node( device_num, &index );
-
-               if ( DFB_OK == ret) {
-                    /* Handle the event that the input device node is removed */
-                    ret = dfb_input_remove_device( index, driver );
-
-                    /* If unable to remove the device within the Linux Input
-                     * provider, just print the info.
-                     */
-                    if ( DFB_OK != ret) {
+                    else if (!strcmp(udev_device_get_action(dev), "remove")) {
                          D_DEBUG_AT( Debug_LinuxInput,
-                                     "Linux/Input: Failed to remove the "
-                                     "device for /dev/input/event%d\n",
+                                     "Device node /dev/input/event%d is removed by udev\n",
                                      device_num );
+                         ret = unregister_device_node( device_num, &index );
+
+                         if ( DFB_OK == ret) {
+                              /* Handle the event that the input device node is removed */
+                              ret = dfb_input_remove_device( index, driver );
+
+                              /* If unable to remove the device within the Linux Input
+                               * provider, just print the info.
+                               */
+                              if ( DFB_OK != ret) {
+                                   D_DEBUG_AT( Debug_LinuxInput,
+                                               "Linux/Input: Failed to remove the "
+                                               "device for /dev/input/event%d\n",
+                                               device_num );
+                              }
+                         }
                     }
+
+                    udev_device_unref(dev);
+               }
+               else {
+                    D_ERROR("No Device from receive_device(). An error occured.\n");
                }
           }
 
@@ -1707,19 +1710,8 @@ stop_hotplug( void )
      /* Destroy the suspended mutex. */
      pthread_mutex_destroy(&driver_suspended_lock);
 
-     /* shutdown the connection of the socket */
-     if (socket_fd > 0) {
-          int rt = shutdown(socket_fd, SHUT_RDWR);
-          if (rt < 0) {
-               D_PERROR( "DirectFB/linux_input: Socket shutdown failed: %s\n",
-                         strerror(errno) );
-               return DFB_FAILURE;
-          }
-     }
-     if (socket_fd > 0) {
-          close(socket_fd);
-          socket_fd = 0;
-     }
+     udev_monitor_unref(mon);
+     udev_unref(udev);
 
 exit:
      D_DEBUG_AT( Debug_LinuxInput, "%s() closed\n", __FUNCTION__ );
@@ -1863,6 +1855,11 @@ driver_open_device( CoreInputDevice  *device,
 
                if (dfb_fbdev->vt)
                     data->vt_fd = dup( dfb_fbdev->vt->fd );
+          } else if (dfb_system_type() == CORE_STMFBDEV) {
+               const STMfbdev * const dfb_stm_fbdev = dfb_system_data();
+
+               if (dfb_stm_fbdev->vt)
+                    data->vt_fd = dup( dfb_stm_fbdev->vt->fd );
           }
           if (data->vt_fd < 0)
                data->vt_fd = open( "/dev/tty0", O_RDWR | O_NOCTTY );
@@ -2037,6 +2034,7 @@ static void
 driver_close_device( void *driver_data )
 {
      int res;
+     int i;
      LinuxInputData *data = (LinuxInputData*) driver_data;
 
      D_DEBUG_AT( Debug_LinuxInput, "%s()\n", __FUNCTION__ );
@@ -2069,6 +2067,14 @@ driver_close_device( void *driver_data )
      /* free private data */
      D_FREE( data );
 
+     /* free device names */
+     for (i = 0; i < MAX_LINUX_INPUT_DEVICES; i++) {
+          if (device_names[i]) {
+               D_FREE( device_names[i] );
+               device_names[i] = NULL;
+          }
+     }
+
      D_DEBUG_AT( Debug_LinuxInput, "%s() closed\n", __FUNCTION__ );
 }
 
diff --git a/inputdrivers/wayland/Makefile.am b/inputdrivers/wayland/Makefile.am
new file mode 100644
index 0000000..4c3a235
--- /dev/null
+++ b/inputdrivers/wayland/Makefile.am
@@ -0,0 +1,32 @@
+## Makefile.am for DirectFB/inputdrivers/wayland
+
+INCLUDES = \
+	-I$(top_builddir)/include	\
+	-I$(top_builddir)/lib	\
+	-I$(top_srcdir)/include	\
+	-I$(top_srcdir)/lib	\
+	-I$(top_srcdir)/src
+
+wayland_LTLIBRARIES = libdirectfb_wayland.la
+
+if BUILD_STATIC
+wayland_DATA = $(wayland_LTLIBRARIES:.la=.o)
+endif
+
+waylanddir = $(MODULEDIR)/inputdrivers
+
+libdirectfb_wayland_la_SOURCES =	\
+	wayland.c
+
+libdirectfb_wayland_la_LDFLAGS = \
+	-module			\
+	-avoid-version		\
+	$(DFB_LDFLAGS)
+
+libdirectfb_wayland_la_LIBADD = \
+	$(top_builddir)/lib/direct/libdirect.la \
+	$(top_builddir)/src/libdirectfb.la
+
+
+include $(top_srcdir)/rules/libobject.make
+	
diff --git a/inputdrivers/wayland/wayland.c b/inputdrivers/wayland/wayland.c
new file mode 100644
index 0000000..400b057
--- /dev/null
+++ b/inputdrivers/wayland/wayland.c
@@ -0,0 +1,153 @@
+/*
+   (c) Copyright 2015  STMicroelectronics R&D
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Ilyes Gouta <ilyes.gouta@st.com>
+
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjälä <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+
+#include "config.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+
+#include <fcntl.h>
+
+#include <directfb.h>
+
+#include <core/core.h>
+#include <core/input.h>
+
+#include <direct/mem.h>
+#include <direct/messages.h>
+#include <direct/thread.h>
+
+#include <fusion/fusion.h>
+
+#define DFB_INPUTDRIVER_HAS_AXIS_INFO
+
+#include <core/input_driver.h>
+#include <directfb_version.h>
+
+#include "../../systems/wayland/wayland.h"
+
+DFB_INPUT_DRIVER( wayland )
+
+typedef struct {
+     CoreInputDevice        *device;
+     struct wayland_context *wayland_context;
+} WaylandData;
+
+static int
+driver_get_available()
+{
+     if (dfb_system_type() == CORE_WAYLAND)
+          return 1;
+
+     return 0;
+}
+
+static void
+driver_get_info( InputDriverInfo *info )
+{
+     snprintf( info->name,
+               DFB_INPUT_DRIVER_INFO_NAME_LENGTH, "Wayland Driver" );
+     snprintf( info->vendor,
+               DFB_INPUT_DRIVER_INFO_VENDOR_LENGTH, "STMicroelectronics" );
+
+     info->version.major = DIRECTFB_MAJOR_VERSION;
+     info->version.minor = DIRECTFB_MINOR_VERSION;
+}
+
+static DFBResult
+driver_open_device( CoreInputDevice  *device,
+                    unsigned int      number,
+                    InputDeviceInfo  *info,
+                    void            **driver_data )
+{
+     WaylandData *data;
+
+     if (dfb_system_type() != CORE_WAYLAND)
+          return DFB_FAILURE;
+
+     data = D_CALLOC( 1, sizeof(WaylandData) );
+     if (!data)
+          return D_OOM();
+
+     data->device = device;
+
+     /* set device name */
+     snprintf( info->desc.name,
+               DFB_INPUT_DEVICE_DESC_NAME_LENGTH, "Wayland Input" );
+
+     /* set device vendor */
+     snprintf( info->desc.vendor,
+               DFB_INPUT_DEVICE_DESC_VENDOR_LENGTH, "STMicroelectronics" );
+
+     info->prefered_id = DIDID_ANY;
+
+     info->desc.type = DIDTF_KEYBOARD | DIDTF_MOUSE | DIDTF_VIRTUAL;
+     info->desc.caps     = DICAPS_ALL;
+     info->desc.max_axis = DIAI_LAST;
+
+     data->wayland_context = dfb_system_data();
+
+     data->wayland_context->input_device = device; /* for input dispatch */
+
+     *driver_data = data;
+
+     return DFB_OK;
+}
+
+static DFBResult
+driver_get_keymap_entry( CoreInputDevice               *device,
+                         void                      *driver_data,
+                         DFBInputDeviceKeymapEntry *entry )
+{
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult
+driver_get_axis_info( CoreInputDevice              *device,
+                      void                         *driver_data,
+                      DFBInputDeviceAxisIdentifier  axis,
+                      DFBInputDeviceAxisInfo       *ret_info )
+{
+     return DFB_OK;
+}
+
+static void
+driver_close_device( void *driver_data )
+{
+     D_FREE( driver_data );
+}
diff --git a/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c b/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c
index fa968cb..fc56f8f 100644
--- a/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c
+++ b/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c
@@ -1,6 +1,8 @@
 /*
    (c) Copyright 2012-2013  DirectFB integrated media GmbH
    (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2006-2010  ST Microelectronics R&D
+
    (c) Copyright 2000-2004  Convergence (integrated media) GmbH
 
    All rights reserved.
@@ -38,6 +40,8 @@
 #include <errno.h>
 #include <string.h>
 #include <stdarg.h>
+#include <sys/ioctl.h>
+#include <linux/videodev2.h>
 
 #include <directfb.h>
 
@@ -48,12 +52,14 @@
 #include <core/layers.h>
 
 #include <core/CoreSurface.h>
+#include <core/palette.h>
 
 #include <misc/gfx_util.h>
 #include <misc/util.h>
 #include <direct/interface.h>
 #include <direct/mem.h>
 #include <direct/memcpy.h>
+#include <direct/thread.h>
 #include <direct/messages.h>
 
 #include <setjmp.h>
@@ -62,6 +68,23 @@
 #undef HAVE_STDLIB_H
 #include <jpeglib.h>
 
+D_DEBUG_DOMAIN (JPEG,      "JPEG",      "STM JPEG decoder");
+D_DEBUG_DOMAIN (JPEG_RAW,  "JPEG/raw",  "STM JPEG decoder (raw decode)");
+D_DEBUG_DOMAIN (JPEG_V4L2,  "JPEG/V4L2",  "STM hwJPEG decoder (V4L2)");
+
+#include "idirectfbimageprovider_jpeg.h"
+
+#if defined(JPEG_PROVIDER_HW)
+static DFBResult JPEG_HardwareRenderTo( IDirectFBImageProvider_JPEG_data *data,
+                                        CoreSurface                      *dst_surface,
+                                        DFBSurfacePixelFormat             format,
+                                        DFBRectangle                     *rect,
+                                        const DFBRegion                  *clip );
+#else
+#define JPEG_HardwareRenderTo(data,dst_surface, \
+                              format,rect,clip) DFB_NOSUCHINSTANCE
+#endif /* JPEG_PROVIDER_HW */
+
 
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx );
@@ -72,23 +95,11 @@ Construct( IDirectFBImageProvider *thiz,
 
 #include <direct/interface_implementation.h>
 
-DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, JPEG )
-
-/*
- * private data struct of IDirectFBImageProvider_JPEG
- */
-typedef struct {
-     IDirectFBImageProvider_data base;
-
-     int                  width;    /*  width of the JPEG image   */
-     int                  height;   /*  height of the JPEG image  */
-
-     u32                 *image;        /*  decoded image data    */
-     int                  image_width;  /*  width of image data   */
-     int                  image_height; /*  height of image data  */
-
-     DIRenderFlags        flags;        /*  selected idct method  */
-} IDirectFBImageProvider_JPEG_data;
+#if defined(JPEG_PROVIDER_HW)
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, hwJPEG )
+#else
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, swJPEG )
+#endif /* JPEG_PROVIDER_HW */
 
 
 static DFBResult
@@ -97,6 +108,10 @@ IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
                                       const DFBRectangle     *destination_rect );
 
 static DFBResult
+IDirectFBImageProvider_JPEG_Sync( IDirectFBImageProvider    *thiz,
+                                  DFBImageProviderSyncFlags  flags );
+
+static DFBResult
 IDirectFBImageProvider_JPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                    DFBSurfaceDescription  *dsc );
 
@@ -108,6 +123,10 @@ static DFBResult
 IDirectFBImageProvider_JPEG_SetRenderFlags( IDirectFBImageProvider *thiz,
                                             DIRenderFlags flags );
 
+static void *
+JPEGrenderThread( DirectThread *thread, void *driver_data );
+
+
 #define JPEG_PROG_BUF_SIZE    0x10000
 
 typedef struct {
@@ -228,74 +247,6 @@ jpeglib_panic(j_common_ptr cinfo)
      longjmp(myerr->setjmp_buffer, 1);
 }
 
-static inline void
-copy_line32( u32 *argb, const u8 *rgb, int width )
-{
-     while (width--) {
-          *argb++ = 0xFF000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
-
-          rgb += 3;
-     }
-}
-
-static inline void
-copy_line_nv16( u16 *yy, u16 *cbcr, const u8 *src_ycbcr, int width )
-{
-     int x;
-
-     for (x=0; x<width/2; x++) {
-#ifdef WORDS_BIGENDIAN
-          yy[x] = (src_ycbcr[0] << 8) | src_ycbcr[3];
-
-          cbcr[x] = (((src_ycbcr[1] + src_ycbcr[4]) << 7) & 0xff00) |
-                     ((src_ycbcr[2] + src_ycbcr[5]) >> 1);
-#else
-          yy[x] = (src_ycbcr[3] << 8) | src_ycbcr[0];
-
-          cbcr[x] = (((src_ycbcr[2] + src_ycbcr[5]) << 7) & 0xff00) |
-                     ((src_ycbcr[1] + src_ycbcr[4]) >> 1);
-#endif
-
-          src_ycbcr += 6;
-     }
-
-     if (width & 1) {
-          u8 *y = (u8*) yy;
-
-          y[width-1] = src_ycbcr[0];
-
-#ifdef WORDS_BIGENDIAN
-          cbcr[x] = (src_ycbcr[1] << 8) | src_ycbcr[2];
-#else
-          cbcr[x] = (src_ycbcr[2] << 8) | src_ycbcr[1];
-#endif
-     }
-}
-
-static inline void
-copy_line_uyvy( u32 *uyvy, const u8 *src_ycbcr, int width )
-{
-     int x;
-
-     for (x=0; x<width/2; x++) {
-#ifdef WORDS_BIGENDIAN
-          uyvy[x] = (src_ycbcr[1] << 24) | (src_ycbcr[0] << 16) | (src_ycbcr[5] << 8) | src_ycbcr[3];
-#else
-          uyvy[x] = (src_ycbcr[3] << 24) | (src_ycbcr[5] << 16) | (src_ycbcr[0] << 8) | src_ycbcr[1];
-#endif
-
-          src_ycbcr += 6;
-     }
-
-     if (width & 1) {
-#ifdef WORDS_BIGENDIAN
-          uyvy[x] = (src_ycbcr[1] << 24) | (src_ycbcr[0] << 16) | (src_ycbcr[1] << 8) | src_ycbcr[0];
-#else
-          uyvy[x] = (src_ycbcr[0] << 24) | (src_ycbcr[1] << 16) | (src_ycbcr[0] << 8) | src_ycbcr[1];
-#endif
-     }
-}
-
 
 static void
 IDirectFBImageProvider_JPEG_Destruct( IDirectFBImageProvider *thiz )
@@ -303,8 +254,20 @@ IDirectFBImageProvider_JPEG_Destruct( IDirectFBImageProvider *thiz )
      IDirectFBImageProvider_JPEG_data *data =
                               (IDirectFBImageProvider_JPEG_data*)thiz->priv;
 
-     if (data->image)
-          D_FREE( data->image );
+     if (data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+
+          pthread_mutex_destroy( &data->lock );
+          pthread_cond_destroy( &data->cond );
+     }
+
+     if (data->common.decode_surface) {
+          dfb_gfxcard_wait_serial( &data->common.serial );
+          dfb_surface_unref( data->common.decode_surface );
+     }
 }
 
 static DFBResult
@@ -336,6 +299,43 @@ Probe( IDirectFBImageProvider_ProbeContext *ctx )
      return DFB_UNSUPPORTED;
 }
 
+#if defined(JPEG_PROVIDER_HW)
+static int
+v4l2_open_by_name(const char * const driver,
+                  const char * const card,
+                  int flags)
+{
+     int fd;
+     struct v4l2_capability cap;
+     char name[64];
+     int ret = -1;
+     unsigned int i = 0;
+
+     do {
+          snprintf(name, sizeof(name), "/dev/video%d", i);
+          fd = open(name, flags);
+          if (fd < 0)
+               return fd;
+
+          ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
+          if (ret < 0){
+               close(fd);
+               continue;
+          }
+
+          if ((strcasecmp((char *)cap.driver, driver) == 0) &&
+              (strcasecmp((char *)cap.card, card) == 0)) {
+               break;
+          }
+
+          close(fd);
+          i++;
+     } while(i);
+
+     return fd;
+}
+#endif
+
 static DFBResult
 Construct( IDirectFBImageProvider *thiz,
            ... )
@@ -354,9 +354,9 @@ Construct( IDirectFBImageProvider *thiz,
      core = va_arg( tag, CoreDFB * );
      va_end( tag );
 
-     data->base.ref    = 1;
-     data->base.buffer = buffer;
-     data->base.core   = core;
+     data->common.base.ref    = 1;
+     data->common.base.buffer = buffer;
+     data->common.base.core   = core;
 
      buffer->AddRef( buffer );
 
@@ -377,8 +377,8 @@ Construct( IDirectFBImageProvider *thiz,
      jpeg_read_header(&cinfo, TRUE);
      jpeg_start_decompress(&cinfo);
 
-     data->width = cinfo.output_width;
-     data->height = cinfo.output_height;
+     data->common.width = cinfo.output_width;
+     data->common.height = cinfo.output_height;
 
      data->flags = DIRENDER_NONE;
 
@@ -391,9 +391,41 @@ Construct( IDirectFBImageProvider *thiz,
           return DFB_FAILURE;
      }
 
-     data->base.Destruct = IDirectFBImageProvider_JPEG_Destruct;
+#if defined(JPEG_PROVIDER_HW)
+#define V4L2_HWJPEG_DRIVER_NAME     "JPEG Decoder"
+#define VENDOR_CARD_NAME            "STMicroelectronics"
+
+     data->software_decode = dfb_config->software_only;
+
+     data->fd = v4l2_open_by_name( V4L2_HWJPEG_DRIVER_NAME,
+                                   VENDOR_CARD_NAME, O_RDWR );
+     if (data->fd < 0) {
+         D_DEBUG_AT( JPEG_V4L2, "Couldn't find h/w JPEG device\n" );
+         /* fallback to software decoding */
+         data->software_decode = 1;
+     } else {
+          struct v4l2_fmtdesc fmtdesc;
+
+          memset( &fmtdesc, 0, sizeof(fmtdesc) );
+
+          fmtdesc.index = 0; /* should be V4L2_PIX_FMT_JPEG */
+          fmtdesc.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+          ioctl( data->fd, VIDIOC_ENUM_FMT, &fmtdesc );
+          close( data->fd );
+
+          if (fmtdesc.pixelformat != V4L2_PIX_FMT_JPEG) {
+               D_DEBUG_AT( JPEG_V4L2, "Decoder doesn't accept JPEG streams\n" );
+               /* fallback to software decoding */
+               data->software_decode = 1;
+          }
+     }
+#endif
+
+     data->common.base.Destruct = IDirectFBImageProvider_JPEG_Destruct;
 
      thiz->RenderTo = IDirectFBImageProvider_JPEG_RenderTo;
+     thiz->Sync = IDirectFBImageProvider_JPEG_Sync;
      thiz->GetImageDescription =IDirectFBImageProvider_JPEG_GetImageDescription;
      thiz->SetRenderFlags = IDirectFBImageProvider_JPEG_SetRenderFlags;
      thiz->GetSurfaceDescription =
@@ -402,73 +434,594 @@ Construct( IDirectFBImageProvider *thiz,
      return DFB_OK;
 }
 
+static void
+JPEG_stretchblit( IDirectFBImageProvider_JPEG_data *data,
+                  CardState                        *state,
+                  DFBRectangle                     *src_rect,
+                  DFBRectangle                     *dst_rect )
+{
+     D_DEBUG_AT( JPEG, "StretchBlit %dx%d -> %dx%d (%s -> %s)\n",
+                 src_rect->w, src_rect->h, dst_rect->w, dst_rect->h,
+                 dfb_pixelformat_name( state->source->config.format),
+                 dfb_pixelformat_name( state->destination->config.format ) );
+
+     /* thankfully this is intelligent enough to do a simple blit if
+        possible */
+     dfb_gfxcard_stretchblit( src_rect, dst_rect, state );
+     /* we need to remember the serial in case a new surface is created
+        (and written to) at the same address as the decode_surface before the
+        blit operation is finished. This can happen if we get into the
+        destructor before the blit operation is finished, which can happen on
+        fast CPUs. */
+     data->common.serial = state->serial;
+}
+
+#define _ROUND_UP_8(x)  (((x)+ 7) & ~ 7)
+#define _ROUND_UP_16(x) (((x)+15) & ~15)
+static void
+JPEG_setup_yuv444p( const struct jpeg_decompress_struct *cinfo,
+                    CoreSurfaceConfig                   *config,
+                    int                                 *pitch_y,
+                    int                                 *pitch_cb,
+                    int                                 *pitch_cr,
+                    int                                 *offset_cb,
+                    int                                 *offset_cr )
+{
+     config->format = DSPF_YUV444P;
+
+     config->size.w = _ROUND_UP_8( cinfo->cur_comp_info[0]
+                                                        ->downsampled_width );
+     config->size.h = _ROUND_UP_8( cinfo->cur_comp_info[0]
+                                                       ->downsampled_height );
+
+     /* pad an extra (decimated) MCU row for the iDCT write-out */
+#if JPEG_LIB_VERSION >= 70
+     config->size.h += cinfo->max_v_samp_factor *
+                       cinfo->min_DCT_v_scaled_size;
+#else
+     config->size.h += cinfo->max_v_samp_factor *
+                       cinfo->min_DCT_scaled_size;
+#endif
+
+     *pitch_y  = config->size.w;
+     if (cinfo->num_components == 3) {
+          *pitch_cb = _ROUND_UP_8( cinfo->cur_comp_info[1]->downsampled_width );
+          *pitch_cr = _ROUND_UP_8( cinfo->cur_comp_info[2]->downsampled_width );
+     }
+
+     *offset_cb
+          = *offset_cr
+          = *pitch_y * config->size.h;
+}
+
 static DFBResult
-IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
-                                      IDirectFBSurface       *destination,
-                                      const DFBRectangle     *dest_rect )
+JPEG_raw_decode_common( IDirectFBImageProvider_JPEG_data *data,
+                        CoreSurface                      *dst_surface,
+                        DFBRectangle                     *rect,
+                        struct jpeg_decompress_struct    *cinfo,
+                        CardState                        *state,
+                        CoreSurfaceBufferLock            *lock,
+                        CoreSurfaceConfig                *config,
+                        CorePalette                      *palette,
+                        int                               pitch_y,
+                        int                               pitch_cb,
+                        int                               pitch_cr,
+                        int                               offset_cb,
+                        int                               offset_cr,
+                        int                               y_v_sampl,
+                        int                               cb_v_sampl,
+                        int                               cr_v_sampl)
 {
-     DFBResult              ret;
-     bool                   direct = false;
-     DFBRegion              clip;
-     DFBRectangle           rect;
-     DFBSurfacePixelFormat  format;
-     IDirectFBSurface_data *dst_data;
-     CoreSurface           *dst_surface;
-     CoreSurfaceBufferLock  lock;
+     DFBResult res;
      DIRenderCallbackResult cb_result = DIRCR_OK;
+     DFBRectangle src_rect;
 
-     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
+     int i;
 
-     dst_data = (IDirectFBSurface_data*) destination->priv;
-     if (!dst_data)
-          return DFB_DEAD;
+     /* Worst case, is 4x4 chroma subsampling where an MCU is 32 lines. libjpeg
+        won't decode more than one MCU in any one go. */
+#if JPEG_LIB_VERSION >= 70
+     const int idct_window_size = (cinfo->max_v_samp_factor
+                                   * cinfo->min_DCT_v_scaled_size);
+#else
+     const int idct_window_size = (cinfo->max_v_samp_factor
+                                   * cinfo->min_DCT_scaled_size);
+#endif
 
-     dst_surface = dst_data->surface;
-     if (!dst_surface)
-          return DFB_DESTROYED;
+#undef _NO_STACK
+#ifndef _NO_STACK
+     JSAMPROW Yrows[idct_window_size];
+     JSAMPROW Cbrows[idct_window_size];
+     JSAMPROW Crrows[idct_window_size];
+     JSAMPARRAY jpeg_buffer[3] = {
+          [0] = Yrows
+     };
+#else
+     /* valgrind can't check stack variables */
+#warning this is not for production use, as we do not clean up on errors
+     JSAMPROW *Yrows, *Cbrows, *Crrows;
+     JSAMPARRAY *jpeg_buffer;
+
+     /* over allocate, least trouble */
+     Yrows = malloc( sizeof(JSAMPROW) * idct_window_size) ;
+     Cbrows = malloc( sizeof(JSAMPROW) * idct_window_size );
+     Crrows = malloc( sizeof(JSAMPROW) * idct_window_size );
+
+     jpeg_buffer = malloc( 3 * sizeof(JSAMPARRAY) );
+     jpeg_buffer[0] = Yrows;
+#endif
 
-     ret = destination->GetPixelFormat( destination, &format );
-     if (ret)
-          return ret;
 
-     dfb_region_from_rectangle( &clip, &dst_data->area.current );
+     if (cb_v_sampl) {
+          jpeg_buffer[1] = Cbrows;
+          jpeg_buffer[2] = Crrows;
+     }
 
-     if (dest_rect) {
-          if (dest_rect->w < 1 || dest_rect->h < 1)
-               return DFB_INVARG;
+     config->flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_COLORSPACE | CSCONF_CAPS;
+     #ifdef __SH4__
+     config->caps = DSCAPS_VIDEOONLY;
+     #else
+     config->caps = 0;
+     #endif
+
+     res = dfb_surface_create( data->common.base.core, config, CSTF_NONE, 0,
+                               palette,
+                               &data->common.decode_surface );
+     if (palette)
+          /* decode_surface holds a reference to the palette now */
+          dfb_palette_unref( palette );
+
+     if (res != DFB_OK) {
+          D_ERROR( "failed to create temporary decode surface\n" );
+          return DFB_UNSUPPORTED;
+     }
+
+     if (dfb_surface_lock_buffer( data->common.decode_surface,
+                                  CSBR_BACK, CSAID_CPU, CSAF_WRITE, lock )) {
+          dfb_surface_unref( data->common.decode_surface );
+          data->common.decode_surface = NULL;
+          return DFB_UNSUPPORTED;
+     }
 
-          rect = *dest_rect;
-          rect.x += dst_data->area.wanted.x;
-          rect.y += dst_data->area.wanted.y;
+     cinfo->raw_data_out = true;
+     jpeg_start_decompress( cinfo );
 
-          if (!dfb_rectangle_region_intersects( &rect, &clip ))
-               return DFB_OK;
+     dfb_state_set_source( state, data->common.decode_surface );
+
+     /* Initialize the various pointers to build a planar YUV buffer. */
+     for (i = 0; i < idct_window_size; ++i)
+          Yrows[i] = lock->addr + i * pitch_y;
+     if (cb_v_sampl) {
+          void *cbaddr = lock->addr + offset_cb;
+          void *craddr = cbaddr + offset_cr;
+          for (i = 0; i < idct_window_size; ++i) {
+               Cbrows[i] = cbaddr + i * pitch_cb;
+               Crrows[i] = craddr + i * pitch_cr;
+          }
+     }
+
+     while (cinfo->output_scanline < data->common.decoded_height
+            && cb_result == DIRCR_OK) {
+          int x = jpeg_read_raw_data( cinfo, jpeg_buffer,
+                                      idct_window_size );
+          if (x <= 0)
+               /* Actually, x == 0 means that we don't have enough data to
+                  continue decoding the picture. */
+               break;
+
+          D_DEBUG_AT( JPEG_RAW,
+                      "  -> decoded %d scanlines (out of %d (%d))\n",
+                      cinfo->output_scanline, data->common.decoded_height,
+                      config->size.h );
+
+          /* increment the pointers by the number of decoded (luma)
+             scanlines. */
+          for (i = 0; i < idct_window_size; ++i)
+               Yrows[i] += (x * pitch_y) / y_v_sampl;
+          if (cb_v_sampl) {
+               for (i = 0; i < idct_window_size; ++i) {
+                    Cbrows[i] += (x * pitch_cb) / cb_v_sampl;
+                    Crrows[i] += (x * pitch_cr) / cr_v_sampl;
+               }
+          }
+
+          if (data->common.base.render_callback) {
+               DFBRectangle r;
+               DFBRectangle dst_rect;
+               float factor;
+
+               src_rect = (DFBRectangle) {
+                    .x = 0,
+                    .y = cinfo->output_scanline - x,
+                    .w = data->common.decoded_width,
+                    .h = x,
+               };
+               r = src_rect;
+               factor = (rect->h / (float) data->common.decoded_height);
+               dst_rect = (DFBRectangle) {
+                    .x = rect->x,
+                    .y = (int) (src_rect.y * factor),
+                    .w = rect->w,
+                    .h = (int) (src_rect.h * factor),
+               };
+
+               D_DEBUG_AT( JPEG_RAW,
+                           "  -> render callback %d,%d %dx%d -> %d,%d %dx%d\n",
+                           src_rect.x, src_rect.y, src_rect.w,
+                           src_rect.h, dst_rect.x, dst_rect.y,
+                           dst_rect.w, dst_rect.h );
+
+               JPEG_stretchblit( data, state, &src_rect, &dst_rect );
+
+               cb_result = data->common.base.render_callback( &r,
+                                                              data->common.base.render_callback_context );
+          }
+     }
+
+     D_DEBUG_AT( JPEG_RAW, "  -> decoded %d scanlines (out of %d)\n",
+                 cinfo->output_scanline, data->common.decoded_height );
+
+     if (cinfo->output_scanline < data->common.decoded_height
+         || cb_result != DIRCR_OK) {
+          if (cb_result != DIRCR_OK)
+               D_ERROR( "raw decode failed after %d of %d scanlines, "
+                        "trying pure software\n",
+                        cinfo->output_scanline, cinfo->output_height );
+          jpeg_abort_decompress( cinfo );
+          jpeg_destroy_decompress( cinfo );
+          dfb_surface_unlock_buffer( data->common.decode_surface, lock );
+          lock->pitch = 0;
+          dfb_surface_unref( data->common.decode_surface );
+          data->common.decode_surface = NULL;
+
+          if (cb_result != DIRCR_OK)
+               return DFB_INTERRUPTED;
+
+          return DFB_FAILURE; /* restart */
+     }
+
+     jpeg_finish_decompress( cinfo );
+     jpeg_destroy_decompress( cinfo );
+
+     dfb_surface_unlock_buffer( data->common.decode_surface, lock );
+     lock->pitch = 0;
+
+     /* use DFB to convert raw YCbCr to destination format, and apply any
+        necessary additional clip/stretch */
+     src_rect = (DFBRectangle) {
+          .x = 0,
+          .y = 0,
+          .w = data->common.decoded_width,
+          .h = data->common.decoded_height
+     };
+
+     JPEG_stretchblit( data, state, &src_rect, rect );
+
+     if (data->common.base.render_callback)
+          data->common.base.render_callback( &src_rect,
+                                             data->common.base.render_callback_context );
+
+#ifdef _NO_STACK
+     free( Yrows );
+     if (cb_v_sampl) {
+          free( Cbrows );
+          free( Crrows );
+     }
+     free( jpeg_buffer );
+#endif
+
+     return DFB_OK;
+}
+
+static DFBResult
+JPEG_raw_decode_YCbCr( IDirectFBImageProvider_JPEG_data *data,
+                       CoreSurface                      *dst_surface,
+                       DFBRectangle                     *rect,
+                       struct jpeg_decompress_struct    *cinfo,
+                       CardState                        *state,
+                       CoreSurfaceBufferLock            *lock )
+{
+     CoreSurfaceConfig config;
+     int pitch_y, pitch_cb, pitch_cr;
+     int offset_cb; /* cb from y */
+     int offset_cr; /* cr from cb */
+     int y_v_sampl = 1;
+     int cb_v_sampl = 1;
+     int cr_v_sampl = 1;
+
+     const int v_samp[3] = { cinfo->cur_comp_info[0]->v_samp_factor,
+                             cinfo->cur_comp_info[1]->v_samp_factor,
+                             cinfo->cur_comp_info[2]->v_samp_factor };
+
+#if JPEG_LIB_VERSION >= 70
+     const int idct_window_size = (cinfo->max_v_samp_factor
+                                   * cinfo->min_DCT_v_scaled_size);
+#else
+     const int idct_window_size = (cinfo->max_v_samp_factor
+                                   * cinfo->min_DCT_scaled_size);
+#endif
+
+     D_DEBUG_AT( JPEG_RAW, "trying YCbCr raw decode\n" );
+
+     if (cinfo->max_h_samp_factor == 1
+         && cinfo->max_v_samp_factor == 1
+         && cinfo->cur_comp_info[0]->h_samp_factor == 1
+         && v_samp[0] == 1
+         && cinfo->cur_comp_info[1]->h_samp_factor == 1
+         && v_samp[1] == 1
+         && cinfo->cur_comp_info[2]->h_samp_factor == 1
+         && v_samp[2] == 1) {
+          /* The image is YCbCr 4:4:4 */
+          D_DEBUG_AT( JPEG_RAW, "  -> 4:4:4 image\n" );
+
+          JPEG_setup_yuv444p( cinfo, &config,
+                              &pitch_y, &pitch_cb, &pitch_cr,
+                              &offset_cb, &offset_cr );
+     }
+     else if (cinfo->max_h_samp_factor == 2
+              && cinfo->max_v_samp_factor == 2
+              && cinfo->cur_comp_info[0]->h_samp_factor == 2
+              && v_samp[0] == 2
+              && cinfo->cur_comp_info[1]->h_samp_factor == 1
+              && v_samp[1] == 1
+              && cinfo->cur_comp_info[2]->h_samp_factor == 1
+              && v_samp[2] == 1) {
+          /* The image is YCbCr 4:2:0 ... */
+          D_DEBUG_AT( JPEG_RAW, "  -> 4:2:0 (I420) image\n" );
+
+          if ((cinfo->scale_num != cinfo->scale_denom)
+              && ((((float)cinfo->scale_denom / cinfo->scale_num)
+                    == (float)(cinfo->scale_denom / cinfo->scale_num))
+                  || (cinfo->scale_num < 4 && cinfo->scale_num != 1)) /* only when JPEG_LIB_VERSION >= 70 */
+              && (cinfo->cur_comp_info[1]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)
+              && (cinfo->cur_comp_info[2]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)) {
+               /* ... but because we are iDCT scaling during decompression it
+                  might end up scaled to 4:4:4, as libjpeg can (and will) apply
+                  different scaling factors for the three components. */
+               D_DEBUG_AT( JPEG_RAW, "    -> iDCT %u/%u scaled to 4:4:4\n",
+                           cinfo->scale_num, cinfo->scale_denom );
+
+               JPEG_setup_yuv444p( cinfo, &config,
+                                   &pitch_y, &pitch_cb, &pitch_cr,
+                                   &offset_cb, &offset_cr );
+          }
+          else if ((cinfo->scale_num == cinfo->scale_denom)
+                   || (((float)cinfo->scale_denom / cinfo->scale_num)
+                       != (float)(cinfo->scale_denom / cinfo->scale_num))
+                   || ((cinfo->cur_comp_info[1]->downsampled_width
+                        == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                            / 2))
+                       && (cinfo->cur_comp_info[2]->downsampled_width
+                           == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                               / 2)))) {
+               /* ... no iDCT scaling, which means it really ends up
+                  as 4:2:0. */
+               config.format = DSPF_I420;
+
+               config.size.w = _ROUND_UP_16( cinfo->cur_comp_info[0]
+                                                        ->downsampled_width );
+               config.size.h = _ROUND_UP_16( cinfo->cur_comp_info[0]
+                                                       ->downsampled_height );
+
+               /* pad an extra (decimated) MCU row for the iDCT write-out */
+               config.size.h += idct_window_size;
+
+               pitch_y = config.size.w;
+               pitch_cb
+                    = pitch_cr
+                    = pitch_y / 2;
+
+               offset_cb = pitch_y  * config.size.h;
+               offset_cr = pitch_cb * config.size.h / 2;
+
+               cb_v_sampl
+                    = cr_v_sampl
+                    = 2;
+          }
+          else {
+               /* shouldn't happen, really */
+               D_DEBUG_AT( JPEG_RAW, "  -> unsupported (unexpected)!\n" );
+               return DFB_UNSUPPORTED;
+          }
+     }
+     else if (cinfo->max_h_samp_factor == 2
+              && cinfo->max_v_samp_factor == 1
+              && cinfo->cur_comp_info[0]->h_samp_factor == 2
+              && v_samp[0] == 1
+              && cinfo->cur_comp_info[1]->h_samp_factor == 1
+              && v_samp[1] == 1
+              && cinfo->cur_comp_info[2]->h_samp_factor == 1
+              && v_samp[2] == 1) {
+          /* The image is YCbCr 4:2:2 ... */
+          D_DEBUG_AT( JPEG_RAW, "  -> 4:2:2 (YV16) image\n" );
+
+          if ((cinfo->scale_num != cinfo->scale_denom)
+              && ((((float)cinfo->scale_denom / cinfo->scale_num)
+                    == (float)(cinfo->scale_denom / cinfo->scale_num))
+                  || (cinfo->scale_num < 4 && cinfo->scale_num != 1)) /* only when JPEG_LIB_VERSION >= 70 */
+              && (cinfo->cur_comp_info[1]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)
+              && (cinfo->cur_comp_info[2]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)) {
+               /* ... iDCT scaling again, as above. */
+               D_DEBUG_AT( JPEG_RAW, "    -> iDCT %u/%u scaled to 4:4:4\n",
+                           cinfo->scale_num, cinfo->scale_denom );
+
+               JPEG_setup_yuv444p( cinfo, &config,
+                                   &pitch_y, &pitch_cb, &pitch_cr,
+                                   &offset_cb, &offset_cr );
+          }
+          else if ((cinfo->scale_num == cinfo->scale_denom)
+                   || (((float)cinfo->scale_denom / cinfo->scale_num)
+                       != (float)(cinfo->scale_denom / cinfo->scale_num))
+                   || ((cinfo->cur_comp_info[1]->downsampled_width
+                        == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                            / 2))
+                       && (cinfo->cur_comp_info[2]->downsampled_width
+                           == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                               / 2)))) {
+               /* ... no iDCT scaling, as above. */
+               config.format = DSPF_YV16;
+
+               config.size.w = _ROUND_UP_16( cinfo->cur_comp_info[0]
+                                                        ->downsampled_width );
+               config.size.h = _ROUND_UP_16( cinfo->cur_comp_info[0]
+                                                       ->downsampled_height );
+
+               /* pad an extra (decimated) MCU row for the iDCT write-out */
+               config.size.h += idct_window_size;
+
+               pitch_y = config.size.w;
+               pitch_cb
+                    = pitch_cr
+                    = pitch_y / 2;
+
+               /* YV16 has Cr/Cb planes not Cb/Cr */
+               offset_cb = (pitch_y + pitch_cr) * config.size.h;
+               offset_cr = -pitch_cr * config.size.h;
+          }
+          else {
+               /* shouldn't happen, really */
+               D_DEBUG_AT( JPEG_RAW, "  -> unsupported (unexpected)!\n" );
+               return DFB_UNSUPPORTED;
+          }
      }
      else {
-          rect = dst_data->area.wanted;
+          D_DEBUG_AT( JPEG_RAW, "  -> unsupported!\n" );
+          return DFB_UNSUPPORTED;
      }
 
-     ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
-     if (ret)
-          return ret;
+     /* FIXME: is this correct for all JPEG images? */
+     config.colorspace = DSCS_BT601_FULLRANGE;
 
-     if (data->image &&
-         (rect.x || rect.y || rect.w != data->image_width || rect.h != data->image_height)) {
-           D_FREE( data->image );
-           data->image        = NULL;
-           data->image_width  = 0;
-           data->image_height = 0;
+     /* We can handle this raw format! */
+     return JPEG_raw_decode_common( data, dst_surface, rect,
+                                    cinfo, state, lock,
+                                    &config, NULL,
+                                    pitch_y, pitch_cb, pitch_cr,
+                                    offset_cb, offset_cr,
+                                    y_v_sampl, cb_v_sampl, cr_v_sampl );
+}
+
+static DFBResult
+JPEG_raw_decode_Grayscale( IDirectFBImageProvider_JPEG_data *data,
+                           CoreSurface                      *dst_surface,
+                           DFBRectangle                     *rect,
+                           struct jpeg_decompress_struct    *cinfo,
+                           CardState                        *state,
+                           CoreSurfaceBufferLock            *lock )
+{
+     CoreSurfaceConfig config;
+     CorePalette *lut8_palette;
+     int pitch_y;
+
+     unsigned int i;
+
+     D_DEBUG_AT( JPEG_RAW, "trying grayscale raw decode\n" );
+
+     if (cinfo->max_h_samp_factor == 1
+         && cinfo->max_v_samp_factor == 1
+         && cinfo->cur_comp_info[0]->h_samp_factor == 1
+         && cinfo->cur_comp_info[0]->v_samp_factor == 1) {
+          int dummy;
+
+          /* The image is grayscale 4:4:4 */
+          D_DEBUG_AT( JPEG_RAW, "  -> 4:4:4 grayscale image\n" );
+
+          JPEG_setup_yuv444p( cinfo, &config, &pitch_y, &dummy, &dummy,
+                              &dummy, &dummy );
+
+          /* Override the YUV444P format set by JPEG_setup_yuv444p() */
+          config.format = DSPF_LUT8;
+     }
+     else {
+          D_DEBUG_AT( JPEG_RAW, "  -> unsupported grayscale image!\n" );
+          return DFB_UNSUPPORTED;
+     }
+
+     /* We can handle this raw format! */
+     if (dfb_palette_create( data->common.base.core, 256, &lut8_palette )) {
+          D_ERROR( "failed to create a palette for the decode surface\n" );
+          return DFB_UNSUPPORTED;
+     }
+
+     for (i = 0; i < lut8_palette->num_entries; i++) {
+          lut8_palette->entries[i].a = 255;
+          lut8_palette->entries[i].r = i;
+          lut8_palette->entries[i].g = i;
+          lut8_palette->entries[i].b = i;
+     }
+
+     config.colorspace = DSCS_RGB;
+
+     return JPEG_raw_decode_common( data, dst_surface, rect,
+                                    cinfo, state, lock,
+                                    &config, lut8_palette,
+                                    pitch_y, 0, 0,
+                                    0, 0,
+                                    1, 0, 0 );
+}
+
+static DFBResult
+JPEG_raw_decode( IDirectFBImageProvider_JPEG_data *data,
+                 CoreSurface                      *dst_surface,
+                 DFBRectangle                     *rect,
+                 struct jpeg_decompress_struct    *cinfo,
+                 CardState                        *state,
+                 CoreSurfaceBufferLock            *lock )
+{
+     if (cinfo->data_precision != 8)
+          return DFB_UNSUPPORTED;
+
+     if (cinfo->num_components == 3
+         && cinfo->jpeg_color_space == JCS_YCbCr)
+          return JPEG_raw_decode_YCbCr( data, dst_surface, rect,
+                                        cinfo, state, lock );
+
+     if (cinfo->num_components == 1
+         && cinfo->jpeg_color_space == JCS_GRAYSCALE)
+          return JPEG_raw_decode_Grayscale( data, dst_surface, rect,
+                                            cinfo, state, lock );
+
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult
+JPEG_SoftwareRenderTo( IDirectFBImageProvider_JPEG_data *data,
+                       CoreSurface                      *dst_surface,
+                       DFBSurfacePixelFormat             format,
+                       DFBRectangle                     *rect,
+                       const DFBRegion                  *clip )
+{
+     DFBResult              ret;
+     DIRenderCallbackResult cb_result = DIRCR_OK;
+     bool                   try_raw = true;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
+
+     if (data->common.decode_surface &&
+         (rect->x || rect->y || rect->w != data->common.decoded_width || rect->h != data->common.decoded_height)) {
+           dfb_gfxcard_wait_serial( &data->common.serial );
+           dfb_surface_unref( data->common.decode_surface );
+           data->common.decode_surface = NULL;
+           data->common.decoded_width  = 0;
+           data->common.decoded_height = 0;
      }
 
      /* actual loading and rendering */
-     if (!data->image) {
+     if (!data->common.decode_surface) {
           struct jpeg_decompress_struct cinfo;
           struct my_error_mgr jerr;
           JSAMPARRAY buffer;      /* Output row buffer */
-          int row_stride;         /* physical row width in output buffer */
-          u32 *row_ptr;
+          JSAMPLE *row_ptr;
           int y = 0;
-          int uv_offset = 0;
+          CardState state;
+          CoreSurfaceBufferLock lock_raw = { .pitch = 0 };
 
           cinfo.err = jpeg_std_error(&jerr.pub);
           jerr.pub.error_exit = jpeglib_panic;
@@ -478,28 +1031,59 @@ IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
 
                jpeg_destroy_decompress( &cinfo );
 
-               if (data->image) {
-                    dfb_scale_linear_32( data->image, data->image_width, data->image_height,
-                                         lock.addr, lock.pitch, &rect, dst_surface, &clip );
-                    dfb_surface_unlock_buffer( dst_surface, &lock );
-                    if (data->base.render_callback) {
-                         DFBRectangle r = { 0, 0, data->image_width, data->image_height };
-
-                         if (data->base.render_callback( &r,
-                                                         data->base.render_callback_context ) != DIRCR_OK)
+               if (try_raw) {
+                    dfb_state_set_source( &state, NULL );
+                    dfb_state_set_destination( &state, NULL );
+                    dfb_state_destroy( &state);
+               }
+               if (data->common.decode_surface) {
+                    CardState state;
+                    DFBRectangle src_rect = {
+                         .x = 0,
+                         .y = 0,
+                         .w = data->common.decoded_width,
+                         .h = data->common.decoded_height
+                    };
+
+                    if (lock_raw.pitch)
+                         dfb_surface_unlock_buffer( data->common.decode_surface,
+                                                    &lock_raw );
+
+                    /* use DFB to convert the raw or BGR24 to destination
+                       format, and apply any necessary additional
+                       clip/stretch */
+                    dfb_state_init( &state, data->common.base.core );
+                    dfb_state_set_source( &state, data->common.decode_surface );
+                    dfb_state_set_destination( &state, dst_surface );
+                    dfb_state_set_clip( &state, clip );
+
+                    JPEG_stretchblit( data, &state, &src_rect, rect );
+
+                    /* remove the state */
+                    dfb_state_set_source( &state, NULL );
+                    dfb_state_set_destination( &state, NULL );
+                    dfb_state_destroy( &state );
+
+                    dfb_gfxcard_wait_serial( &data->common.serial );
+                    dfb_surface_unref( data->common.decode_surface );
+                    data->common.decode_surface = NULL;
+
+                    if (data->common.base.render_callback) {
+                         DFBRectangle r = { 0, 0, data->common.decoded_width, data->common.decoded_height };
+
+                         if (data->common.base.render_callback( &r, data->common.base.render_callback_context ) != DIRCR_OK)
                               return DFB_INTERRUPTED;
                     }
 
                     return DFB_INCOMPLETE;
                }
                else
-                    dfb_surface_unlock_buffer( dst_surface, &lock );
-
-               return DFB_FAILURE;
+                    return DFB_FAILURE;
           }
 
+restart:
           jpeg_create_decompress( &cinfo );
-          jpeg_buffer_src( &cinfo, data->base.buffer, 0 );
+          jpeg_buffer_src( &cinfo, data->common.base.buffer, 0 );
           jpeg_read_header( &cinfo, TRUE );
 
 #if JPEG_LIB_VERSION >= 70
@@ -511,19 +1095,16 @@ IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
 #endif
           jpeg_calc_output_dimensions( &cinfo );
 
-          if (cinfo.output_width == (unsigned)rect.w && cinfo.output_height == (unsigned)rect.h) {
-               direct = true;
-          }
-          else if (rect.x == 0 && rect.y == 0) {
+          if (rect->x == 0 && rect->y == 0) {
 #if JPEG_LIB_VERSION >= 70
                /*  The supported scaling ratios in libjpeg 7 and 8
                 *  are N/8 with all N from 1 to 16.
                 */
                cinfo.scale_num = 1;
                jpeg_calc_output_dimensions( &cinfo );
-               while (cinfo.scale_num < 16
-                      && cinfo.output_width < (unsigned)rect.w
-                      && cinfo.output_height < (unsigned)rect.h) {
+               while (cinfo.scale_num < 8
+                      && cinfo.output_width < (unsigned)rect->w
+                      && cinfo.output_height < (unsigned)rect->h) {
                     ++cinfo.scale_num;
                     jpeg_calc_output_dimensions( &cinfo );
                }
@@ -532,8 +1113,8 @@ IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
                 *  are 1/1, 1/2, 1/4, and 1/8.
                 */
                while (cinfo.scale_denom < 8
-                      && ((cinfo.output_width >> 1) >= (unsigned)rect.w)
-                      && ((cinfo.output_height >> 1) >= (unsigned)rect.h)) {
+                      && ((cinfo.output_width >> 1) >= (unsigned)rect->w)
+                      && ((cinfo.output_height >> 1) >= (unsigned)rect->h)) {
                     cinfo.scale_denom <<= 1;
                     jpeg_calc_output_dimensions( &cinfo );
                }
@@ -542,138 +1123,147 @@ IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
 
           cinfo.output_components = 3;
 
-          switch (dst_surface->config.format) {
-               case DSPF_NV16:
-                    uv_offset = dst_surface->config.size.h * lock.pitch;
-
-                    if (direct && !rect.x && !rect.y) {
-                         D_INFO( "JPEG: Using YCbCr color space directly! (%dx%d)\n",
-                                 cinfo.output_width, cinfo.output_height );
-                         cinfo.out_color_space = JCS_YCbCr;
-                         break;
-                    }
-                    D_INFO( "JPEG: Going through RGB color space! (%dx%d -> %dx%d @%d,%d)\n",
-                            cinfo.output_width, cinfo.output_height, rect.w, rect.h, rect.x, rect.y );
-                    cinfo.out_color_space = JCS_RGB;
-                    break;
-
-               case DSPF_UYVY:
-                    if (direct && !rect.x && !rect.y) {
-                         cinfo.out_color_space = JCS_YCbCr;
+          data->common.decoded_width = cinfo.output_width;
+          data->common.decoded_height = cinfo.output_height;
+
+          cinfo.do_fancy_upsampling = FALSE;
+          cinfo.do_block_smoothing = FALSE;
+
+          if (try_raw) {
+               /* init a state, so that we can use gfxcard/blit to convert
+                  YCbCr to requested destination format */
+               dfb_state_init( &state, data->common.base.core );
+               dfb_state_set_destination( &state, dst_surface );
+               dfb_state_set_clip( &state, clip );
+
+               ret = JPEG_raw_decode( data, dst_surface, rect, &cinfo,
+                                      &state, &lock_raw );
+
+               /* remove the state */
+               dfb_state_set_source( &state, NULL );
+               dfb_state_set_destination( &state, NULL );
+               dfb_state_destroy( &state );
+
+               switch (ret) {
+                    case DFB_OK:
+                    case DFB_INTERRUPTED:
+                         /* All ok, or callback signalled abort. */
+                         return ret;
+
+                    case DFB_UNSUPPORTED:
+                         /* Not enough video memory or source image format not
+                            supported. jpeg_start_decompress() was not yet
+                            called, so we can just break.
+                            We have to reset try_raw, in case the software
+                            decode throws an exception, though. */
+                         try_raw = false;
                          break;
-                    }
-                    D_INFO( "JPEG: Going through RGB color space! (%dx%d -> %dx%d @%d,%d)\n",
-                            cinfo.output_width, cinfo.output_height, rect.w, rect.h, rect.x, rect.y );
-                    cinfo.out_color_space = JCS_RGB;
-                    break;
-
-               default:
-                    cinfo.out_color_space = JCS_RGB;
-                    break;
-          }
-
-          if (data->flags & DIRENDER_FAST)
-               cinfo.dct_method = JDCT_IFAST;
 
-          jpeg_start_decompress( &cinfo );
-
-          data->image_width = cinfo.output_width;
-          data->image_height = cinfo.output_height;
+                    default:
+                         D_BUG( "JPEG_raw_decode() returned unknown "
+                                "result %d\n", ret );
+                    case DFB_FAILURE:
+                         /* General failure during compression, we restart
+                            trying a software decoding and in for that have to
+                            reinitialise cinfo. */
+                         try_raw = false;
+                         goto restart;
+               }
+          }
 
-          row_stride = cinfo.output_width * 3;
 
-          buffer = (*cinfo.mem->alloc_sarray)( (j_common_ptr) &cinfo,
-                                               JPOOL_IMAGE, row_stride, 1 );
+          /* start using the full software decode path */
+          cinfo.out_color_space = JCS_RGB;
 
-          data->image = D_CALLOC( data->image_height, data->image_width * 4 );
-          if (!data->image) {
-               dfb_surface_unlock_buffer( dst_surface, &lock );
-               return D_OOM();
+          if (data->flags & DIRENDER_FAST)
+               cinfo.dct_method = JDCT_FASTEST;
+
+          CoreSurfaceConfig config = { .flags = (CSCONF_SIZE
+                                                 | CSCONF_FORMAT
+                                                 | CSCONF_COLORSPACE),
+                                       .format = DSPF_BGR24,
+                                       .colorspace = DSCS_RGB,
+                                       .size.w = data->common.decoded_width,
+                                       .size.h = data->common.decoded_height };
+          if (dfb_surface_create( data->common.base.core, &config, CSTF_NONE,
+                                  0, NULL, &data->common.decode_surface )) {
+               D_ERROR( "failed to create temporary decode surface\n" );
+               return DFB_UNSUPPORTED;
           }
-          row_ptr = data->image;
-
-          while (cinfo.output_scanline < cinfo.output_height && cb_result == DIRCR_OK) {
-               jpeg_read_scanlines( &cinfo, buffer, 1 );
 
-               switch (dst_surface->config.format) {
-                    case DSPF_NV16:
-                    case DSPF_UYVY:
-                         if (direct) {
-                              switch (dst_surface->config.format) {
-                                   case DSPF_NV16:
-                                        copy_line_nv16( lock.addr, (u16*)lock.addr + uv_offset, *buffer, rect.w );
-                                        break;
+          if ((ret = dfb_surface_lock_buffer( data->common.decode_surface,
+                                              CSBR_BACK, CSAID_CPU,
+                                              CSAF_WRITE, &lock_raw ))) {
+               dfb_surface_unref( data->common.decode_surface );
+               data->common.decode_surface = NULL;
 
-                                   case DSPF_UYVY:
-                                        copy_line_uyvy( lock.addr, *buffer, rect.w );
-                                        break;
+               jpeg_abort_decompress( &cinfo );
+               jpeg_destroy_decompress( &cinfo );
 
-                                   default:
-                                        break;
-                              }
+               return ret;
+          }
 
-                              lock.addr = (u8*)lock.addr + lock.pitch;
+          jpeg_start_decompress( &cinfo );
 
-                              if (data->base.render_callback) {
-                                   DFBRectangle r = { 0, y, data->image_width, 1 };
+          row_ptr = lock_raw.addr;
+          buffer = &row_ptr;
 
-                                   cb_result = data->base.render_callback( &r,
-                                                                           data->base.render_callback_context );
-                              }
-                              break;
-                         }
+          while (cinfo.output_scanline < cinfo.output_height && cb_result == DIRCR_OK) {
+               jpeg_read_scanlines( &cinfo, buffer, 1 );
 
-                    default:
-                         copy_line32( row_ptr, *buffer, data->image_width );
-
-                         if (direct) {
-                              DFBRectangle r = { rect.x, rect.y+y, rect.w, 1 };
-                              dfb_copy_buffer_32( row_ptr, lock.addr, lock.pitch,
-                                                  &r, dst_surface, &clip );
-                              if (data->base.render_callback) {
-                                   r = (DFBRectangle){ 0, y, data->image_width, 1 };
-                                   cb_result = data->base.render_callback( &r,
-                                                                           data->base.render_callback_context );
-                              }
-                         }
-                         break;
+               if (data->common.base.render_callback) {
+                    DFBRectangle r =
+                              (DFBRectangle){ 0, y, data->common.decoded_width, 1 };
+                    cb_result = data->common.base.render_callback( &r,
+                                                                   data->common.base.render_callback_context );
                }
 
-               row_ptr += data->image_width;
+               row_ptr += lock_raw.pitch;
                y++;
           }
 
-          if (!direct) {
-               dfb_scale_linear_32( data->image, data->image_width, data->image_height,
-                                    lock.addr, lock.pitch, &rect, dst_surface, &clip );
-               if (data->base.render_callback) {
-                    DFBRectangle r = { 0, 0, data->image_width, data->image_height };
-                    cb_result = data->base.render_callback( &r,
-                                                            data->base.render_callback_context );
-               }
-          }
+          dfb_surface_unlock_buffer( data->common.decode_surface, &lock_raw );
 
           if (cb_result != DIRCR_OK) {
                jpeg_abort_decompress( &cinfo );
-               D_FREE( data->image );
-               data->image = NULL;
           }
           else {
                jpeg_finish_decompress( &cinfo );
           }
           jpeg_destroy_decompress( &cinfo );
      }
-     else {
-          dfb_scale_linear_32( data->image, data->image_width, data->image_height,
-                               lock.addr, lock.pitch, &rect, dst_surface, &clip );
-          if (data->base.render_callback) {
-               DFBRectangle r = { 0, 0, data->image_width, data->image_height };
-               data->base.render_callback( &r,
-                                           data->base.render_callback_context );
+
+     if (data->common.decode_surface) {
+          CardState    state;
+          DFBRectangle src_rect = {
+               .x = 0,
+               .y = 0,
+               .w = data->common.decoded_width,
+               .h = data->common.decoded_height
+          };
+
+          /* use DFB to convert the YCbCr or BGR24 to destination format and
+             apply any necessary additional clip/stretch */
+          dfb_state_init( &state, data->common.base.core );
+          dfb_state_set_source( &state, data->common.decode_surface );
+          dfb_state_set_destination( &state, dst_surface );
+          dfb_state_set_clip( &state, clip );
+
+          JPEG_stretchblit( data, &state, &src_rect, rect );
+
+          /* remove the state */
+          dfb_state_set_source( &state, NULL );
+          dfb_state_set_destination( &state, NULL );
+          dfb_state_destroy( &state );
+
+          if (data->common.base.render_callback) {
+               DFBRectangle r = { 0, 0, data->common.decoded_width, data->common.decoded_height };
+               data->common.base.render_callback( &r,
+                                                  data->common.base.render_callback_context );
           }
      }
 
-     dfb_surface_unlock_buffer( dst_surface, &lock );
+     D_DEBUG_AT( JPEG, "software decoding finished\n" );
 
      if (cb_result != DIRCR_OK)
           return DFB_INTERRUPTED;
@@ -681,6 +1271,167 @@ IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
      return DFB_OK;
 }
 
+
+
+static DFBResult
+JPEG_RenderTo( IDirectFBImageProvider_JPEG_data *data,
+               CoreSurface                      *dst_surface,
+               DFBSurfacePixelFormat             format,
+               DFBRectangle                     *rect,
+               const DFBRegion                  *clip )
+{
+     DFBResult res;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
+
+     res = JPEG_HardwareRenderTo( data, dst_surface, format, rect, clip );
+     if (res != DFB_OK) {
+          if (res == DFB_IO) {
+               /* IO error - there's no point in retrying */
+               D_DEBUG_AT( JPEG, "hardware decode failed: %d (%s)\n",
+                           res, DirectFBErrorString( res ) );
+               return res;
+          }
+
+          D_DEBUG_AT( JPEG, "hardware decode failed: %d (%s) - "
+                      "attempting software fallback\n",
+                      res, DirectFBErrorString( res ) );
+
+          res = JPEG_SoftwareRenderTo( data, dst_surface, format, rect, clip );
+          if (unlikely (res != DFB_OK))
+               D_DEBUG_AT( JPEG, "software decode failed: %d (%s)\n",
+                           res, DirectFBErrorString( res ) );
+     }
+
+     return res;
+}
+
+static DFBResult
+IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
+                                      IDirectFBSurface       *destination,
+                                      const DFBRectangle     *dest_rect )
+{
+     IDirectFBSurface_data *dst_data;
+     CoreSurface           *dst_surface;
+     DFBSurfacePixelFormat  format;
+     DFBResult              ret;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
+
+     dst_data = (IDirectFBSurface_data*) destination->priv;
+     if (!dst_data)
+          return DFB_DEAD;
+
+     dst_surface = dst_data->surface;
+     if (!dst_surface)
+          return DFB_DESTROYED;
+
+     ret = destination->GetPixelFormat( destination, &format );
+     if (ret)
+          return ret;
+
+     if (data->thread)
+          pthread_mutex_lock( &data->lock );
+
+     dfb_region_from_rectangle( &data->clip, &dst_data->area.current );
+
+     if (dest_rect) {
+          if (dest_rect->w < 1 || dest_rect->h < 1) {
+               if (data->thread)
+                    pthread_mutex_unlock( &data->lock );
+               return DFB_INVARG;
+          }
+
+          data->rect = *dest_rect;
+          data->rect.x += dst_data->area.wanted.x;
+          data->rect.y += dst_data->area.wanted.y;
+
+          if (!dfb_rectangle_region_intersects( &data->rect, &data->clip )) {
+               if (data->thread)
+                    pthread_mutex_unlock( &data->lock );
+               return DFB_OK;
+          }
+     }
+     else {
+          data->rect = dst_data->area.wanted;
+     }
+
+     if (!D_FLAGS_IS_SET (data->flags, DIRENDER_BACKGROUND)) {
+          /* threaded operation was not requested */
+          data->thread_res = JPEG_RenderTo( data, dst_surface, format,
+                                            &data->rect, &data->clip );
+          if (data->thread)
+               pthread_mutex_unlock( &data->lock );
+          return data->thread_res;
+     }
+
+     if (!data->thread) {
+          /* for the case that somebody does a RenderTo() twice on us, we
+             have to create new thread, because the initial thread will have
+             finished already */
+
+          D_ASSERT( data->destination == NULL );
+
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, JPEGrenderThread,
+                                               thiz, "JPEG" );
+     }
+
+     D_ASSERT( data->destination == NULL );
+
+     destination->AddRef( destination );
+     data->destination = destination;
+
+     pthread_cond_signal( &data->cond );
+     pthread_mutex_unlock( &data->lock );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBImageProvider_JPEG_Sync( IDirectFBImageProvider    *thiz,
+                                  DFBImageProviderSyncFlags  flags )
+{
+     DFBResult res;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
+
+     switch (flags)
+       {
+       case DIPSYNCFLAGS_TRYSYNC:
+            if (data->thread) {
+                 if (data->thread_res == DFB_INIT
+                     || data->thread_res == DFB_BUSY) {
+                      /* DFB_INIT (user didn't call RenderTo() yet)
+                         DFB_BUSY (still busy decoding) */
+                      return data->thread_res;
+                 }
+                 /* else we are done, either because of some error or because
+                    we have processed all the data already */
+            }
+            /* fall through */
+
+       case DIPSYNCFLAGS_SYNC:
+            if (data->thread) {
+                 direct_thread_join( data->thread );
+                 direct_thread_destroy( data->thread );
+                 data->thread = NULL;
+            }
+            break;
+
+       default:
+            return DFB_OK;
+       }
+
+     res = data->thread_res;
+     data->thread_res = DFB_OK;
+     return res;
+}
+
 static DFBResult
 IDirectFBImageProvider_JPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                    DFBSurfaceDescription  *dsc )
@@ -691,8 +1442,8 @@ IDirectFBImageProvider_JPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
           return DFB_INVARG;
 
      dsc->flags  = DSDESC_WIDTH |  DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
-     dsc->height = data->height;
-     dsc->width  = data->width;
+     dsc->width  = data->common.width;
+     dsc->height = data->common.height;
      dsc->pixelformat = dfb_primary_layer_pixelformat();
 
      return DFB_OK;
@@ -703,6 +1454,30 @@ IDirectFBImageProvider_JPEG_SetRenderFlags( IDirectFBImageProvider *thiz,
 {
      DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
 
+     /* if we have decoded the image already, don't do anything... */
+     if (data->common.decode_surface)
+          return DFB_UNSUPPORTED;
+
+     if (!(flags & DIRENDER_BACKGROUND) && data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+          data->thread = NULL;
+
+          pthread_cond_destroy( &data->cond );
+          pthread_mutex_destroy( &data->lock );
+     }
+     else if (flags & DIRENDER_BACKGROUND && !data->thread) {
+          /* or create it */
+          pthread_cond_init( &data->cond, NULL );
+          pthread_mutex_init( &data->lock, NULL );
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, JPEGrenderThread,
+                                               thiz, "JPEG_DECODER?" );
+     }
+
      data->flags = flags;
 
      return DFB_OK;
@@ -721,3 +1496,402 @@ IDirectFBImageProvider_JPEG_GetImageDescription( IDirectFBImageProvider *thiz,
 
      return DFB_OK;
 }
+
+static void
+render_cleanup( void *cleanup_data )
+{
+     IDirectFBImageProvider           *thiz = cleanup_data;
+     IDirectFBImageProvider_JPEG_data *data;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_JPEG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     if (data->destination) {
+          data->destination->Release( data->destination );
+          data->destination = NULL;
+     }
+
+     /* in case we get terminated from outside, set the state to DFB_DEAD */
+     data->thread_res = DFB_DEAD;
+
+     pthread_mutex_unlock( &data->lock );
+}
+
+static void *
+JPEGrenderThread( DirectThread *thread, void *driver_data )
+{
+     IDirectFBImageProvider           *thiz = driver_data;
+     IDirectFBImageProvider_JPEG_data *data;
+     IDirectFBSurface_data            *dst_data;
+     CoreSurface                      *dst_surface;
+     DFBSurfacePixelFormat             format;
+     DFBResult                         res;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_JPEG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     pthread_mutex_lock( &data->lock );
+
+     pthread_cleanup_push( render_cleanup, thiz );
+
+     while (!data->destination) {
+          pthread_cond_wait( &data->cond, &data->lock );
+     }
+
+     dst_data = (IDirectFBSurface_data*) data->destination->priv;
+     D_ASSERT( dst_data != NULL );
+
+     dst_surface = dst_data->surface;
+     D_ASSERT( dst_surface != NULL );
+
+     res = data->destination->GetPixelFormat( data->destination, &format );
+     D_ASSERT( res == DFB_OK );
+
+     /* as long as we haven't finished decoding we are busy */
+     data->thread_res = DFB_BUSY;
+
+     res = JPEG_RenderTo( data, dst_surface, format, &data->rect, &data->clip );
+
+     pthread_cleanup_pop( 1 );
+
+     /* in case we exit normally, apply the real return value */
+     data->thread_res = res;
+
+     return NULL;
+}
+
+#if defined(JPEG_PROVIDER_HW)
+static DFBResult
+JPEG_HardwareRenderTo( IDirectFBImageProvider_JPEG_data *data,
+                       CoreSurface                      *dst_surface,
+                       DFBSurfacePixelFormat             format,
+                       DFBRectangle                     *rect,
+                       const DFBRegion                  *clip )
+{
+     DFBResult              ret = DFB_OK;
+     unsigned int           length;
+     unsigned int           ret_read;
+     int                    type;
+     int                    size = 0;
+
+     CoreSurfaceConfig      config;
+
+     IDirectFBDataBuffer   *buffer;
+
+     struct v4l2_requestbuffers reqbufs;
+
+     struct v4l2_format src_format;
+     struct v4l2_format dst_format;
+
+     struct v4l2_buffer srcbuf;
+     struct v4l2_buffer dstbuf;
+
+     CoreSurfaceBufferLock src_lock = { .pitch = 0 };
+     CoreSurfaceBufferLock dst_lock = { .pitch = 0 };
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( clip != NULL );
+
+     D_ASSERT( data->common.base.core != NULL );
+
+     /* Construct() has already determined the decoder isn't available. */
+     if (data->software_decode)
+          return DFB_FAILURE;
+
+     if (data->common.decode_surface) {
+           dfb_gfxcard_wait_serial( &data->common.serial );
+           dfb_surface_unref( data->common.decode_surface );
+           data->common.decode_surface = NULL;
+     }
+
+     D_ASSERT( data->source_surface == NULL );
+     D_ASSERT( data->common.decode_surface == NULL );
+
+     data->fd = v4l2_open_by_name( V4L2_HWJPEG_DRIVER_NAME,
+                                   VENDOR_CARD_NAME, O_RDWR );
+
+     if (data->fd < 0) {
+          D_DEBUG_AT( JPEG_V4L2, "Couldn't open h/w JPEG device\n" );
+          return DFB_FAILURE;
+     }
+
+     data->source_surface = NULL;
+
+     buffer = data->common.base.buffer;
+
+     if (buffer->GetLength( buffer, &length )) {
+          close( data->fd );
+          return DFB_UNSUPPORTED;
+     }
+
+     config.size.w = 16 * sysconf(_SC_PAGESIZE);
+     config.size.h = length / config.size.w + 1;
+
+     if ((ret = dfb_surface_create_simple( data->common.base.core,
+                                           config.size.w,
+                                           config.size.h,
+                                           DSPF_A8, DSCS_BT601,
+                                           DSCAPS_VIDEOONLY, CSTF_EXTERNAL,
+                                           0, NULL,
+                                           &data->source_surface ))) {
+          close( data->fd );
+          return ret;
+     }
+
+     D_DEBUG_AT( JPEG_V4L2, " -> Allocated a (%dx%d) surface for JPEG data\n",
+                 config.size.w, config.size.h );
+
+     if ((ret = dfb_surface_lock_buffer( data->source_surface,
+                                         CSBR_BACK, CSAID_CPU,
+                                         CSAF_WRITE, &src_lock ))) {
+          dfb_surface_unref( data->source_surface );
+          data->source_surface = NULL;
+          close( data->fd );
+          return ret;
+     }
+
+     buffer->SeekTo( buffer, 0 );
+
+     if ((ret = buffer->GetData( buffer, length, src_lock.addr, &ret_read )))
+          goto fini;
+
+     memset( &reqbufs, 0, sizeof(reqbufs) );
+
+     reqbufs.count = 1;
+     reqbufs.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     reqbufs.memory = V4L2_MEMORY_USERPTR;
+
+     if (ioctl( data->fd, VIDIOC_REQBUFS, &reqbufs ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     reqbufs.count = 1;
+     reqbufs.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+     reqbufs.memory = V4L2_MEMORY_USERPTR;
+
+     if (ioctl( data->fd, VIDIOC_REQBUFS, &reqbufs ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+     if (ioctl( data->fd, VIDIOC_STREAMON, &type ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+     if (ioctl( data->fd, VIDIOC_STREAMON, &type ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &src_format, 0, sizeof( src_format ) );
+
+     src_format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+     src_format.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG;
+
+     if (ioctl( data->fd, VIDIOC_S_FMT, &src_format ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &srcbuf, 0, sizeof( srcbuf ) );
+
+     srcbuf.index = 0;
+     srcbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+     srcbuf.memory = V4L2_MEMORY_USERPTR;
+     srcbuf.m.userptr = (unsigned long)src_lock.addr;
+     srcbuf.length = length;
+
+     if (ioctl( data->fd, VIDIOC_QBUF, &srcbuf ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &src_format, 0, sizeof( src_format ) );
+
+     src_format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+     if (ioctl( data->fd, VIDIOC_G_FMT, &src_format ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     src_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+     src_format.fmt.pix.width = rect ? rect->w : src_format.fmt.pix.width;
+     src_format.fmt.pix.height = rect ? rect->h : src_format.fmt.pix.height;
+
+     dst_format = src_format;
+
+     if (ioctl( data->fd, VIDIOC_TRY_FMT, &dst_format ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     if (dst_format.fmt.pix.pixelformat != V4L2_PIX_FMT_NV12
+         && dst_format.fmt.pix.pixelformat != V4L2_PIX_FMT_NV16
+         && dst_format.fmt.pix.pixelformat != V4L2_PIX_FMT_NV24) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     config.flags = CSCONF_SIZE | CSCONF_FORMAT;
+
+     switch (dst_format.fmt.pix.pixelformat) {
+     case V4L2_PIX_FMT_NV12:
+          config.format = DSPF_NV12;
+          break;
+     case V4L2_PIX_FMT_NV16:
+          config.format = DSPF_NV16;
+          break;
+     case V4L2_PIX_FMT_NV24:
+          config.format = DSPF_NV24;
+          break;
+     default:
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     D_DEBUG_AT( JPEG_V4L2, " -> h/w JPEG decoder suggested a %dx%d %s buffer "
+                 ", %dx%d requested\n",
+                 dst_format.fmt.pix.width, dst_format.fmt.pix.height,
+                 dfb_pixelformat_name( config.format ),
+                 src_format.fmt.pix.width, src_format.fmt.pix.height );
+
+     /* No decoding, just return information about the h/w buffer. */
+     if (!dst_surface) {
+          data->common.decoded_width = dst_format.fmt.pix.width;
+          data->common.decoded_height = dst_format.fmt.pix.height;
+          data->pixelformat = config.format;
+          ret = DFB_OK;
+          goto fini;
+     }
+
+     config.size.w = dst_format.fmt.pix.bytesperline;
+     config.size.h = dst_format.fmt.pix.height;
+
+     if ((ret = dfb_surface_create_simple( data->common.base.core,
+                                           config.size.w, config.size.h,
+                                           config.format, DSCS_BT601,
+                                           DSCAPS_VIDEOONLY, CSTF_EXTERNAL,
+                                           0, NULL,
+                                           &data->common.decode_surface )))
+          goto fini;
+
+     dfb_surface_calc_buffer_size( data->common.decode_surface, 1, 1, NULL, &size );
+
+     src_format.fmt.pix.sizeimage = size;
+     src_format.fmt.pix.pixelformat = dst_format.fmt.pix.pixelformat;
+
+     if (ioctl( data->fd, VIDIOC_S_FMT, &src_format ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     if ((ret = dfb_surface_lock_buffer( data->common.decode_surface,
+                                         CSBR_BACK, CSAID_GPU,
+                                         CSAF_WRITE, &dst_lock )))
+          goto fini;
+
+     if (dst_lock.pitch != dst_format.fmt.pix.bytesperline) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &dstbuf, 0, sizeof( dstbuf ) );
+
+     dstbuf.index = 0;
+     dstbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     dstbuf.memory = V4L2_MEMORY_USERPTR;
+     dstbuf.m.userptr = (unsigned long)dst_lock.addr;
+     dstbuf.length = dst_format.fmt.pix.sizeimage;
+
+     if (ioctl( data->fd, VIDIOC_QBUF, &dstbuf ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     if (ioctl( data->fd, VIDIOC_DQBUF, &dstbuf ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &dst_format, 0, sizeof( dst_format ) );
+
+     dst_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+     if (ioctl( data->fd, VIDIOC_G_FMT, &dst_format ) < 0) {
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     D_DEBUG_AT( JPEG_V4L2, " -> Decoded image is a %dx%d %s buffer "
+                 ", pitch: %d\n", dst_format.fmt.pix.width,
+                 dst_format.fmt.pix.height,
+                 (dst_format.fmt.pix.pixelformat == V4L2_PIX_FMT_NV12) ? "NV12"
+                 : ((dst_format.fmt.pix.pixelformat == V4L2_PIX_FMT_NV16)
+                    ? "NV16" : "NV24"),
+                 dst_format.fmt.pix.bytesperline );
+
+fini:
+     if (data->common.decode_surface && dst_lock.pitch)
+          dfb_surface_unlock_buffer( data->common.decode_surface, &dst_lock );
+
+     type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+     ioctl( data->fd, VIDIOC_STREAMOFF, &type );
+
+     type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     ioctl( data->fd, VIDIOC_STREAMOFF, &type );
+
+     if (data->source_surface) {
+          if (src_lock.pitch)
+               dfb_surface_unlock_buffer( data->source_surface, &src_lock );
+
+          dfb_surface_unref( data->source_surface );
+          data->source_surface = NULL;
+     }
+
+     close( data->fd );
+
+     if (data->common.decode_surface && ret == DFB_OK) {
+          CardState    state;
+          DFBRectangle src_rect = {
+               .x = 0,
+               .y = 0,
+               .w = dst_format.fmt.pix.width,
+               .h = dst_format.fmt.pix.height
+          };
+
+          /* use DFB to convert the intermediary NV format to the
+             final destination format, applying any necessary additional
+             clip/stretch */
+          dfb_state_init( &state, data->common.base.core );
+          dfb_state_set_source( &state, data->common.decode_surface );
+          dfb_state_set_destination( &state, dst_surface );
+          dfb_state_set_clip( &state, clip );
+
+          JPEG_stretchblit( data, &state, &src_rect, rect );
+
+          dfb_state_set_source( &state, NULL );
+          dfb_state_set_destination( &state, NULL );
+          dfb_state_destroy( &state );
+
+          if (data->common.base.render_callback) {
+               DFBRectangle r = { 0, 0,
+                                  dst_format.fmt.pix.width,
+                                  dst_format.fmt.pix.height };
+               data->common.base.render_callback( &r,
+                                           data->common.base.render_callback_context );
+          }
+     }
+
+     return ret;
+}
+#endif
diff --git a/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h b/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h
new file mode 100644
index 0000000..7f76b36
--- /dev/null
+++ b/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h
@@ -0,0 +1,54 @@
+#ifndef __IDIRECTFBIMAGEPROVIDER_JPEG_H__
+#define __IDIRECTFBIMAGEPROVIDER_JPEG_H__
+
+#define likely(x)       __builtin_expect(!!(x),1)
+#define unlikely(x)     __builtin_expect(!!(x),0)
+
+struct _hwCommon
+{
+  IDirectFBImageProvider_data base;
+
+  const char *name;
+
+  void         *image; /* decoded image data */
+  unsigned int  width; /* width of the JPEG/PNG image */
+  unsigned int  height; /* height of the JPEG/PNG image */
+
+#ifdef DIRECT_BUILD_DEBUG
+  /* performance monitoring */
+  struct timeval starttime, endtime;
+#endif /* DIRECT_BUILD_DEBUG */
+
+  CoreSurface        *decode_surface;
+  CoreGraphicsSerial  serial;
+
+  unsigned int decoded_width;
+  unsigned int decoded_height;
+};
+
+/* private data struct of IDirectFBImageProvider_JPEG */
+typedef struct
+{
+  /* hardware decode specifics */
+  struct _hwCommon common;
+
+  DFBRectangle      rect;
+  DFBRegion         clip;
+
+  /* thread stuff */
+  DIRenderFlags     flags;
+  pthread_mutex_t   lock;
+  pthread_cond_t    cond;
+  DirectThread     *thread;
+  IDirectFBSurface *destination;
+  DFBResult         thread_res;
+
+#if defined(JPEG_PROVIDER_HW)
+  int                   fd;
+  CoreSurface          *source_surface;
+  int                   software_decode;
+  DFBSurfacePixelFormat pixelformat;
+#endif
+} IDirectFBImageProvider_JPEG_data;
+
+#endif /* __IDIRECTFBIMAGEPROVIDER_JPEG_H__ */
diff --git a/interfaces/IDirectFBImageProvider/idirectfbimageprovider_tiff.c b/interfaces/IDirectFBImageProvider/idirectfbimageprovider_tiff.c
index 4faab3a..a294853 100644
--- a/interfaces/IDirectFBImageProvider/idirectfbimageprovider_tiff.c
+++ b/interfaces/IDirectFBImageProvider/idirectfbimageprovider_tiff.c
@@ -224,6 +224,9 @@ IDirectFBImageProvider_TIFF_Destruct( IDirectFBImageProvider *thiz )
      if (data->base.buffer)
           data->base.buffer->Release( data->base.buffer );
 
+     if (data->tif)
+          TIFFClose( data->tif );
+
      DIRECT_DEALLOCATE_INTERFACE( thiz );
 }
 
@@ -309,6 +312,8 @@ IDirectFBImageProvider_TIFF_RenderTo( IDirectFBImageProvider *thiz,
           goto error;
      }
 
+     data->base.buffer->SeekTo( data->base.buffer, 0 );
+
      TIFFReadRGBAImageOriented( data->tif, lock.pitch / 4, data->image_height, (uint32 *)(lock.addr), ORIENTATION_TOPLEFT, 0 );
 
      dfb_surface_unlock_buffer( data->decode_surface, &lock );
diff --git a/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c b/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c
index 2b4ad9e..0bf600b 100644
--- a/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c
+++ b/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c
@@ -36,7 +36,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <stdarg.h>
 #include <sys/time.h>
+#include <assert.h>
 
 #include <pthread.h>
 
@@ -64,7 +66,7 @@
 static DFBResult Probe( IDirectFBVideoProvider_ProbeContext *ctx );
 
 static DFBResult Construct( IDirectFBVideoProvider *thiz,
-                            IDirectFBDataBuffer    *buffer );
+                            ... );
 
 
 #include <direct/interface_implementation.h>
@@ -97,19 +99,28 @@ typedef struct {
      IDirectFBSurface              *destination;
      IDirectFBSurface_data         *dst_data;
      DFBRectangle                   dst_rect;
-     
-     u32                           *image;
-     
+
+     DFBColor                       palette[MAXCOLORMAPSIZE];
+
+     CoreSurface                   *decode_surface;
+     CoreSurfaceBufferLock          buffer_lock;
+
      DirectThread                  *thread;
      pthread_mutex_t                lock;
      pthread_cond_t                 cond;
      
+     int                            paused;
+
      DFBVideoProviderStatus         status;
      DFBVideoProviderPlaybackFlags  flags;
      double                         speed;
      
      unsigned int                   start_pos;
 
+     unsigned int                   frame;
+     unsigned int                   target_frame; /* only in DVPLAY_PACED */
+     unsigned int                   last_frame; /* only in DVPLAY_PACED */
+
      char                           Version[4];
      unsigned int                   Width;
      unsigned int                   Height;
@@ -137,6 +148,8 @@ typedef struct {
 
      DVFrameCallback                callback;
      void                          *callback_ctx;
+
+     CoreDFB                       *core;
 } IDirectFBVideoProvider_GIF_data;
 
 #define GIFERRORMSG(x, ...) \
@@ -171,7 +184,7 @@ FetchData( IDirectFBDataBuffer *buffer, void *data, unsigned int len )
 }
 
 static int ReadColorMap( IDirectFBDataBuffer *buffer, int number,
-                         u8 buf[3][MAXCOLORMAPSIZE] )
+                         DFBColor palette[MAXCOLORMAPSIZE] )
 {
      int  i;
      u8   rgb[3*number];
@@ -182,9 +195,10 @@ static int ReadColorMap( IDirectFBDataBuffer *buffer, int number,
      }
 
      for (i = 0; i < number; ++i) {
-          buf[CM_RED][i]   = rgb[i*3+0];
-          buf[CM_GREEN][i] = rgb[i*3+1];
-          buf[CM_BLUE][i]  = rgb[i*3+2];
+          palette[i].r = rgb[i*3+0];
+          palette[i].g = rgb[i*3+1];
+          palette[i].b = rgb[i*3+2];
+          palette[i].a = 0xff;
      }
      
      return 0;
@@ -407,12 +421,13 @@ static int LWZReadByte( IDirectFBVideoProvider_GIF_data *data, int flag, int inp
 
 static int ReadImage( IDirectFBVideoProvider_GIF_data *data, 
                       int left, int top, int width, int height,
-                      u8 cmap[3][MAXCOLORMAPSIZE], bool interlace, bool ignore )
+                      int pitch, DFBColor palette[MAXCOLORMAPSIZE],
+                      bool interlace, bool ignore )
 {
      u8   c;
      int  v;
      int  xpos = 0, ypos = 0, pass = 0;
-     u32 *image, *dst;
+     u32 *image = image, *dst = dst;
 
      /*
      **  Initialize the decompression routines
@@ -426,7 +441,7 @@ static int ReadImage( IDirectFBVideoProvider_GIF_data *data,
      /*
      **  If this is an "uninteresting picture" ignore it.
      */
-     if (ignore) {
+     if (ignore && !data->disposal) {
           GIFDEBUGMSG("skipping image...");
 
           while (LWZReadByte( data, false, c ) >= 0)
@@ -435,10 +450,6 @@ static int ReadImage( IDirectFBVideoProvider_GIF_data *data,
      }
      
      switch (data->disposal) {
-          case 2:
-               GIFDEBUGMSG("restoring to background color...");
-               memset( data->image, 0, data->Width * data->Height * 4 );
-               break;
           case 3:
                GIFERRORMSG("restoring to previous frame is unsupported");
                break;
@@ -446,17 +457,18 @@ static int ReadImage( IDirectFBVideoProvider_GIF_data *data,
                break;
      }
      
-     dst = image = data->image + (top * data->Width + left);
+     dst = image = ((u32 *)(data->buffer_lock.addr)
+                    + (top * (pitch / 4) + left));
 
      GIFDEBUGMSG("reading %dx%d at %dx%d %sGIF image",
                  width, height, left, top, interlace ? " interlaced " : "" );
 
      while ((v = LWZReadByte( data, false, c )) >= 0 ) {
           if (v != data->transparent) {
-               dst[xpos] = (0xFF000000              |
-                            cmap[CM_RED][v]   << 16 |
-                            cmap[CM_GREEN][v] << 8  |
-                            cmap[CM_BLUE][v]);
+               dst[xpos] = (0xFF000000         |
+                            palette[v].r << 16 |
+                            palette[v].g << 8  |
+                            palette[v].b);
           }
 
           ++xpos;
@@ -496,8 +508,10 @@ static int ReadImage( IDirectFBVideoProvider_GIF_data *data,
                else {
                     ++ypos;
                }
-               dst = image + ypos * data->Width;
-          } 
+
+               dst = image + ypos * (pitch >> 2);
+          }
+
           if (ypos >= height) {
                break;
           }
@@ -519,9 +533,6 @@ static void GIFReset( IDirectFBVideoProvider_GIF_data *data )
      data->delayTime   = 1000000; /* default: 1s */
      data->inputFlag   = -1;
      data->disposal    = 0;
-     
-     if (data->image)
-          memset( data->image, 0, data->Width*data->Height*4 );
 }
 
 static DFBResult GIFReadHeader( IDirectFBVideoProvider_GIF_data *data )
@@ -561,7 +572,7 @@ static DFBResult GIFReadHeader( IDirectFBVideoProvider_GIF_data *data )
           data->AspectRatio = (data->Width << 8) / data->Height;
 
      if (BitSet(buf[4], LOCALCOLORMAP)) {    /* Global Colormap */
-          if (ReadColorMap( data->buffer, data->BitPixel, data->ColorMap )) {
+          if (ReadColorMap( data->buffer, data->BitPixel, data->palette )) {
                GIFERRORMSG("error reading global colormap");
                return DFB_FAILURE;
           }
@@ -575,8 +586,10 @@ static DFBResult GIFReadFrame( IDirectFBVideoProvider_GIF_data *data )
      u8    buf[16], c;
      int   top, left;
      int   width, height;
-     u8    localColorMap[3][MAXCOLORMAPSIZE];
+     DFBColor  local_palette[MAXCOLORMAPSIZE];
      bool  useGlobalColormap;
+     int   ignore = 0;
+     int   num_frames = 0;
 
      data->curbit = data->lastbit = data->done = data->last_byte = 0;
 
@@ -586,21 +599,41 @@ static DFBResult GIFReadFrame( IDirectFBVideoProvider_GIF_data *data )
      data->firstcode = data->oldcode =
      data->clear_code = data->end_code = 0;
 
-     for (;;) {
+     dfb_surface_lock_buffer( data->decode_surface,
+                              CSBR_BACK, CSAID_CPU, CSAF_WRITE,
+                              &data->buffer_lock );
+
+     if (data->flags & DVPLAY_PACED
+         && data->target_frame != -1) {
+          ignore = data->target_frame != (data->frame + 1);
+          num_frames = data->target_frame - data->frame - 1;
+     }
+
+     if (!data->frame)
+          num_frames++;
+
+     for (; num_frames >= 0;) {
           DFBResult ret;
           
           ret = FetchData( data->buffer, &c, 1);
           if (ret) {
                GIFERRORMSG("EOF / read error on image data" );
+               dfb_surface_unlock_buffer( data->decode_surface,
+                                          &data->buffer_lock );
                return DFB_EOF;
           }
 
-          if (c == ';') /* GIF terminator */
+          if (c == ';') { /* GIF terminator */
+               dfb_surface_unlock_buffer( data->decode_surface,
+                                          &data->buffer_lock );
                return DFB_EOF;
+          }
 
           if (c == '!') { /* Extension */
                if (FetchData( data->buffer, &c, 1)) {
                     GIFERRORMSG("EOF / read error on extention function code");
+                    dfb_surface_unlock_buffer( data->decode_surface,
+                                               &data->buffer_lock );
                     return DFB_EOF;
                }
                DoExtension( data, c );
@@ -615,6 +648,8 @@ static DFBResult GIFReadFrame( IDirectFBVideoProvider_GIF_data *data )
           ret = FetchData( data->buffer, buf, 9 );
           if (ret) {
                GIFERRORMSG("couldn't read left/top/width/height");
+               dfb_surface_unlock_buffer( data->decode_surface,
+                                          &data->buffer_lock );
                return ret;
           }
                
@@ -627,21 +662,28 @@ static DFBResult GIFReadFrame( IDirectFBVideoProvider_GIF_data *data )
 
           if (!useGlobalColormap) {
                int bitPixel = 2 << (buf[8] & 0x07);
-               if (ReadColorMap( data->buffer, bitPixel, localColorMap ))
+               if (ReadColorMap( data->buffer, bitPixel, local_palette ))
                     GIFERRORMSG("error reading local colormap");
           }
 
+          data->frame++;
+          num_frames--;
+
+
           if (ReadImage( data, left, top, width, height,
-                        (useGlobalColormap ?
-                         data->ColorMap : localColorMap),
-                         BitSet( buf[8], INTERLACE ), 0 )) {
+                         data->buffer_lock.pitch,
+                         (useGlobalColormap ?
+                         data->palette : local_palette),
+                         BitSet( buf[8], INTERLACE ), ignore )) {
                GIFERRORMSG("error reading image");
+               dfb_surface_unlock_buffer( data->decode_surface,
+                                          &data->buffer_lock );
                return DFB_FAILURE;
           }
-          
-          break;
      }
      
+     dfb_surface_unlock_buffer( data->decode_surface, &data->buffer_lock );
+
      return DFB_OK;
 }
 
@@ -653,13 +695,31 @@ IDirectFBVideoProvider_GIF_Destruct( IDirectFBVideoProvider *thiz )
      IDirectFBVideoProvider_GIF_data *data = thiz->priv;
      
      thiz->Stop( thiz );
-     
-     if (data->image)
-          D_FREE( data->image );
-     
+    
+     if (data->thread) {
+          direct_thread_cancel( data->thread );
+          pthread_mutex_lock( &data->lock );
+          pthread_cond_signal( &data->cond );
+          pthread_mutex_unlock( &data->lock );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+          data->thread = NULL;
+     }
+
      if (data->buffer)
           data->buffer->Release( data->buffer );
-    
+
+     if (data->destination) {
+          data->destination->Release( data->destination );
+          data->destination = NULL;
+          data->dst_data    = NULL;
+     }
+
+     if (data->decode_surface) {
+          dfb_surface_unref( data->decode_surface );
+          data->decode_surface = NULL;
+     }
+
      pthread_cond_destroy( &data->cond );
      pthread_mutex_destroy( &data->lock );
           
@@ -709,12 +769,11 @@ IDirectFBVideoProvider_GIF_GetSurfaceDescription( IDirectFBVideoProvider *thiz,
      
      if (!desc)
           return DFB_INVARG;
-          
-     desc->flags       = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
-     desc->width       = data->Width;
-     desc->height      = data->Height;
-     desc->pixelformat = DSPF_ARGB;
      
+     desc->width = data->Width;
+     desc->height = data->Height;
+     desc->pixelformat = DSPF_ARGB;
+
      return DFB_OK;
 }
 
@@ -742,19 +801,58 @@ IDirectFBVideoProvider_GIF_GetStreamDescription( IDirectFBVideoProvider *thiz,
      return DFB_OK;
 }
 
+static void
+clear_decode_surface(IDirectFBVideoProvider_GIF_data *data)
+{
+     CardState     state;
+     DFBRectangle  rect = { .x = 0,
+                            .y = 0,
+                            .w = data->Width,
+                            .h = data->Height };
+
+     DFBColor      color = { .r = 0,
+                             .g = 0,
+                             .b = 0,
+                             .a = 0 };
+
+     DFBRegion     clip  = { .x1 = 0,
+                             .y1 = 0,
+                             .x2 = data->Width - 1,
+                             .y2 = data->Height - 1 };
+
+     /* init a fillrect state */
+     dfb_state_init( &state, data->core );
+     dfb_state_set_color( &state, &color );
+     dfb_state_set_source( &state, NULL );
+     dfb_state_set_destination( &state, data->decode_surface );
+     dfb_state_set_clip( &state, &clip );
+
+     dfb_gfxcard_fillrectangles( &rect, 1, &state );
+
+     /* wait for the h/w to complete */
+     dfb_gfxcard_wait_serial( &state.serial );
+
+     /* remove the state */
+     dfb_state_set_source( &state, NULL );
+     dfb_state_set_destination( &state, NULL );
+     dfb_state_destroy( &state );
+}
+
 static void*
 GIFVideo( DirectThread *self, void *arg )
 {
      IDirectFBVideoProvider_GIF_data *data = arg;
      
      pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, NULL );
-     
+
+     data->frame = 0;
+
+     clear_decode_surface( data );
+
      while (!direct_thread_is_canceled( self )) {
           DFBResult              ret;
           DFBRectangle           rect;
           DFBRegion              clip;
-          CoreSurface           *surface;
-          CoreSurfaceBufferLock  lock;
           
           pthread_mutex_lock( &data->lock );
           
@@ -763,10 +861,39 @@ GIFVideo( DirectThread *self, void *arg )
                break;
           }
           
+          /* check if the requested frame doesn't exist */
+          if (data->flags & DVPLAY_PACED
+              && data->last_frame
+              && data->target_frame > data->last_frame) {
+               /* notify the caller */
+               data->target_frame = -1;
+               data->callback( data->callback_ctx );
+               /* wait for the next call */
+               data->status = DVSTATE_STOP;
+               pthread_cond_wait( &data->cond, &data->lock );
+               pthread_mutex_unlock( &data->lock );
+               continue;
+          }
+
+          /* restart decoding if the newly requested frame precedes or is
+             the last decoded one when in DVPLAY_PACED mode */
+          if (data->flags & DVPLAY_PACED
+              && data->target_frame != -1
+              && data->target_frame < data->frame) {
+               GIFReset( data );
+               data->frame = 0;
+               data->buffer->SeekTo( data->buffer, data->start_pos );
+          }
+
+          if (data->disposal == 2)
+               clear_decode_surface( data );
+
           ret = GIFReadFrame( data );
           if (ret) { 
                if (ret == DFB_EOF) {
+                    data->last_frame = data->frame;
                     GIFReset( data );
+                    data->frame = 0;
                     if (data->flags & DVPLAY_LOOPING) {
                          data->buffer->SeekTo( data->buffer, data->start_pos );
                     }
@@ -776,6 +903,15 @@ GIFVideo( DirectThread *self, void *arg )
                          break;
                     }
                }
+               /* bail out if stream is invalid */
+               if (data->flags & DVPLAY_PACED) {
+                    /* notify the caller */
+                    data->target_frame = -1; /* error */
+                    data->callback( data->callback_ctx );
+                    /* wait for the next call */
+                    data->status = DVSTATE_STOP;
+                    pthread_cond_wait( &data->cond, &data->lock );
+               }
                pthread_mutex_unlock( &data->lock );
                continue;
           }
@@ -784,41 +920,58 @@ GIFVideo( DirectThread *self, void *arg )
                  ? data->dst_data->area.wanted : data->dst_rect;          
           dfb_region_from_rectangle( &clip, &data->dst_data->area.current );
           
-          surface = data->dst_data->surface;
-          D_MAGIC_ASSERT( surface, CoreSurface );
-
-          if (dfb_rectangle_region_intersects( &rect, &clip ) &&
-              dfb_surface_lock_buffer( surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock ) == DFB_OK)
+          CardState     state;
+          CoreSurface  *dst_surface;
+          DFBRectangle  srect = { .x = 0,
+                                  .y = 0,
+                                  .w = data->Width,
+                                  .h = data->Height, };
+
+          dst_surface = data->dst_data->surface;
+          D_MAGIC_ASSERT( dst_surface, CoreSurface );
+
+          /* init a state, so that we can use gfxcard/blit to do the
+             format conversion. */
+          dfb_state_init( &state, data->core );
+          dfb_state_set_source( &state, data->decode_surface );
+          dfb_state_set_destination( &state, dst_surface );
+          dfb_state_set_clip( &state, &clip );
+
+          dfb_gfxcard_stretchblit( &srect, &rect, &state );
+
+          /* remove the state */
+          dfb_state_set_source( &state, NULL );
+          dfb_state_set_destination( &state, NULL );
+          dfb_state_destroy( &state );
+
+          if (data->callback)
+               data->callback( data->callback_ctx );
+
+          if (!(data->flags & DVPLAY_PACED))
           {
-               dfb_scale_linear_32( data->image, data->Width, data->Height,
-                                    lock.addr, lock.pitch, &rect, data->dst_data->surface, &clip );
-                                    
-               dfb_surface_unlock_buffer( surface, &lock );
-               
-               if (data->callback)
-                    data->callback( data->callback_ctx );
-          }
+               if (!data->speed)
+                    pthread_cond_wait( &data->cond, &data->lock );
+               else {
+                    struct timespec ts;
+                    struct timeval  tv;
+                    unsigned long   us;
+
+                    gettimeofday( &tv, NULL );
 
-          if (!data->speed) {
+                    us = data->delayTime;
+                    if (data->speed != 1.0)
+                         us = ((double)us / data->speed + .5);
+                    us += tv.tv_usec;
+
+                    ts.tv_sec  = tv.tv_sec + us/1000000;
+                    ts.tv_nsec = (us%1000000) * 1000;
+
+                    pthread_cond_timedwait( &data->cond, &data->lock, &ts );
+               }
+          } else {
+               data->status = DVSTATE_STOP;
                pthread_cond_wait( &data->cond, &data->lock );
           }
-          else {
-               struct timespec ts;
-               struct timeval  tv;
-               unsigned long   us;
-               
-               gettimeofday( &tv, NULL );
-                    
-               us = data->delayTime;
-               if (data->speed != 1.0)
-                    us = ((double)us / data->speed + .5);
-               us += tv.tv_usec;                 
-                    
-               ts.tv_sec  = tv.tv_sec + us/1000000;
-               ts.tv_nsec = (us%1000000) * 1000;
-                    
-               pthread_cond_timedwait( &data->cond, &data->lock, &ts );
-          }
           
           pthread_mutex_unlock( &data->lock );
      }
@@ -836,7 +989,10 @@ IDirectFBVideoProvider_GIF_PlayTo( IDirectFBVideoProvider *thiz,
      IDirectFBSurface_data *dst_data;
      DFBRectangle           rect = { 0, 0, 0, 0 };
      DFBResult              ret;
-     
+
+     DFBVideoProviderPacedPlaybackCtx *Ctx =
+               (DFBVideoProviderPacedPlaybackCtx *)ctx;
+
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
      
      if (!destination)
@@ -845,7 +1001,7 @@ IDirectFBVideoProvider_GIF_PlayTo( IDirectFBVideoProvider *thiz,
      dst_data = destination->priv;
      if (!dst_data || !dst_data->surface)
           return DFB_DESTROYED;
-          
+
      if (dest_rect) {
           if (dest_rect->w < 1 || dest_rect->h < 1)
                return DFB_INVARG;
@@ -855,6 +1011,11 @@ IDirectFBVideoProvider_GIF_PlayTo( IDirectFBVideoProvider *thiz,
           rect.y += dst_data->area.wanted.y;
      }          
      
+     if (data->flags & DVPLAY_PACED) {
+          if (!Ctx || !callback)
+               return DFB_INVARG;
+     }
+
      pthread_mutex_lock( &data->lock );
      
      if (data->status == DVSTATE_FINISHED) {
@@ -866,14 +1027,6 @@ IDirectFBVideoProvider_GIF_PlayTo( IDirectFBVideoProvider *thiz,
      }
      data->status = DVSTATE_PLAY;
      
-     if (!data->image) {          
-          data->image = D_CALLOC( 4, data->Width * data->Height );
-          if (!data->image) {
-               pthread_mutex_unlock( &data->lock );
-               return D_OOM();
-          }
-     }
-     
      if (data->destination)
           data->destination->Release( data->destination );
      
@@ -881,10 +1034,32 @@ IDirectFBVideoProvider_GIF_PlayTo( IDirectFBVideoProvider *thiz,
      data->destination = destination;
      data->dst_data    = dst_data;
      data->dst_rect    = rect;
-     
+
      data->callback     = callback;
      data->callback_ctx = ctx;
+     if (data->flags & DVPLAY_PACED)
+          data->target_frame = Ctx->num_frame;
      
+     if (!data->decode_surface) {
+          ret = dfb_surface_create_simple( data->core,
+                                           data->Width, data->Height,
+                                           DSPF_ARGB, DSCS_RGB,
+                                           DSCAPS_NONE, CSTF_NONE, 0,
+                                           NULL, &data->decode_surface );
+          if (ret != DFB_OK) {
+               pthread_mutex_unlock( &data->lock );
+               return ret;
+          }
+     }
+
+     /* Playback has already been started by a previous call to PlayTo() */
+     if (data->thread && (data->flags & DVPLAY_PACED)) {
+          data->paused = 0;
+          pthread_cond_signal( &data->cond );
+          pthread_mutex_unlock( &data->lock );
+          return DFB_OK;
+     }
+
      if (!data->thread) {
           data->thread = direct_thread_create( DTT_DEFAULT, GIFVideo,
                                               (void*)data, "GIF Video" );
@@ -899,25 +1074,33 @@ static DFBResult
 IDirectFBVideoProvider_GIF_Stop( IDirectFBVideoProvider *thiz )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
-     if (data->thread) {
-          direct_thread_cancel( data->thread );
-          pthread_mutex_lock( &data->lock );
-          pthread_cond_signal( &data->cond );
-          pthread_mutex_unlock( &data->lock );
-          direct_thread_join( data->thread );
-          direct_thread_destroy( data->thread );
-          data->thread = NULL;
-     }
-     
-     if (data->destination) {
-          data->destination->Release( data->destination );
-          data->destination = NULL;
-          data->dst_data    = NULL;
+
+     if (data->flags & DVPLAY_PACED) {
+        /* sync with the decoding thread */
+        pthread_mutex_lock( &data->lock );
+        assert( data->status == DVSTATE_STOP );
+        pthread_mutex_unlock( &data->lock );
+        return DFB_OK;
+     } else {
+          if (data->thread) {
+               direct_thread_cancel( data->thread );
+               pthread_mutex_lock( &data->lock );
+               pthread_cond_signal( &data->cond );
+               pthread_mutex_unlock( &data->lock );
+               direct_thread_join( data->thread );
+               direct_thread_destroy( data->thread );
+               data->thread = NULL;
+          }
+
+          if (data->destination) {
+               data->destination->Release( data->destination );
+               data->destination = NULL;
+               data->dst_data = NULL;
+          }
+
+          data->status = DVSTATE_STOP;
      }
      
-     data->status = DVSTATE_STOP;
-     
      return DFB_OK;
 }
 
@@ -981,11 +1164,14 @@ IDirectFBVideoProvider_GIF_SetPlaybackFlags( IDirectFBVideoProvider        *thiz
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
      
-     if (flags & ~DVPLAY_LOOPING)
+     if (flags & ~(DVPLAY_LOOPING | DVPLAY_PACED))
           return DFB_UNSUPPORTED;
           
      if (flags & DVPLAY_LOOPING && !data->seekable)
           return DFB_UNSUPPORTED;
+
+     if (flags & DVPLAY_PACED)
+          data->target_frame = -1;
           
      data->flags = flags;
      
@@ -1037,12 +1223,22 @@ Probe( IDirectFBVideoProvider_ProbeContext *ctx )
 
 static DFBResult
 Construct( IDirectFBVideoProvider *thiz,
-           IDirectFBDataBuffer    *buffer )
+           ... )
 {
      DFBResult ret;
 
+     IDirectFBDataBuffer *buffer;
+     CoreDFB             *core;
+     va_list              tag;
+
      DIRECT_ALLOCATE_INTERFACE_DATA( thiz, IDirectFBVideoProvider_GIF )
 
+     va_start( tag, thiz );
+     buffer = va_arg( tag, IDirectFBDataBuffer * );
+     core = va_arg( tag, CoreDFB * );
+     va_end( tag );
+
+     data->core   = core;
      data->ref    = 1;
      data->status = DVSTATE_STOP;
      data->buffer = buffer;
@@ -1060,9 +1256,13 @@ Construct( IDirectFBVideoProvider *thiz,
      
      data->buffer->GetPosition( data->buffer, &data->start_pos );
      
-     direct_util_recursive_pthread_mutex_init( &data->lock );
+     pthread_mutex_init( &data->lock, NULL );
      pthread_cond_init( &data->cond, NULL );
      
+     data->paused = 0;
+     data->decode_surface = NULL;
+     data->last_frame = 0;
+
      thiz->AddRef                = IDirectFBVideoProvider_GIF_AddRef;
      thiz->Release               = IDirectFBVideoProvider_GIF_Release;
      thiz->GetCapabilities       = IDirectFBVideoProvider_GIF_GetCapabilities;
diff --git a/lib/Makefile.am b/lib/Makefile.am
index ae0a199..8794ac1 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -19,5 +19,8 @@ if ENABLE_FUSIONSOUND
 FUSIONSOUND_DIRS = fusionsound fusionsound/drivers
 endif
 
-SUBDIRS = direct fusion $(ONE_DIR) $(VOODOO_DIR) $(FUSIONDALE_DIRS) $(FUSIONSOUND_DIRS)
+if ENABLE_WAYLAND
+WAYLAND_DIRS = wayland-dfb
+endif
 
+SUBDIRS = direct fusion $(ONE_DIR) $(VOODOO_DIR) $(FUSIONDALE_DIRS) $(FUSIONSOUND_DIRS)
diff --git a/lib/direct/interface.c b/lib/direct/interface.c
index 83196af..92d0d40 100644
--- a/lib/direct/interface.c
+++ b/lib/direct/interface.c
@@ -172,6 +172,9 @@ DirectUnregisterInterface( DirectInterfaceFuncs *funcs )
 
      D_DEBUG_AT( Direct_Interface, "  -> %p\n", impl );
 
+     if (impl->filename)
+          D_FREE( impl->filename );
+
      D_MAGIC_CLEAR( impl );
 
      D_FREE( impl );
diff --git a/lib/direct/modules.c b/lib/direct/modules.c
index bcf443a..89440c5 100644
--- a/lib/direct/modules.c
+++ b/lib/direct/modules.c
@@ -173,6 +173,8 @@ direct_modules_unregister( DirectModuleDir *directory,
      D_MAGIC_ASSERT( entry, DirectModuleEntry );
 
      D_FREE( entry->name );
+     if (entry->file)
+          D_FREE( entry->file );
 
      direct_list_remove( &directory->entries, &entry->link );
 
diff --git a/lib/fusion/fusion.c b/lib/fusion/fusion.c
index a7fd7c0..5420b19 100644
--- a/lib/fusion/fusion.c
+++ b/lib/fusion/fusion.c
@@ -509,6 +509,11 @@ fusion_fork_handler_child( void )
 
 /**********************************************************************************************************************/
 
+#if defined(__SH4__)
+#  define shm_align_mask  (0x3fff)
+#else
+#  define shm_align_mask  (direct_pagesize()-1)
+#endif
 static DirectResult
 map_shared_root( void               *shm_base,
                  int                 world_index,
@@ -523,6 +528,7 @@ map_shared_root( void               *shm_base,
      int            flags = O_RDONLY;
      int            prot  = PROT_READ;
      unsigned long  size = direct_page_align(sizeof(FusionWorldShared));
+     size = (size + shm_align_mask) & ~shm_align_mask;
      unsigned long  base = (unsigned long) shm_base + (size + direct_pagesize()) * world_index;
 
      if (master || !fusion_config->secure_fusion) {
@@ -3216,6 +3222,159 @@ fusion_dispatch_loop( DirectThread *self, void *arg )
      return NULL;
 }
 
+DirectResult
+fusion_dispatch( FusionWorld *world,
+                 size_t       buf_size )
+{
+     ssize_t  len = 0;
+     char    *buf;
+     char    *buf_p;
+
+     struct sockaddr_un  addr;
+     socklen_t           addr_len = sizeof(addr);
+     fd_set              set;
+
+     int     result;
+     ssize_t msg_size;
+
+     D_DEBUG_AT( Fusion_Main_Dispatch, "%s( world %p, buf_size %zu )\n", __FUNCTION__, world, buf_size );
+
+     D_MAGIC_ASSERT( world, FusionWorld );
+
+     if (buf_size == 0)
+          buf_size = FUSION_MESSAGE_SIZE * 4;
+     else
+          D_ASSUME( buf_size >= FUSION_MESSAGE_SIZE );
+
+     buf = buf_p = malloc( buf_size );
+
+//     if (world->dispatch_stop) {
+//          D_DEBUG_AT( Fusion_Main_Dispatch, "  -> IGNORING (dispatch_stop!)\n" );
+//          return DR_SUSPENDED;
+//     }
+
+     D_DEBUG_AT( Fusion_Main_Dispatch, "  = = dispatch -> reading up to %zu bytes...\n", buf_size );
+
+     D_MAGIC_ASSERT( world, FusionWorld );
+
+     FD_ZERO( &set );
+     FD_SET( world->fusion_fd, &set );
+
+     while (true) {
+          result = select( world->fusion_fd + 1, &set, NULL, NULL, NULL );
+          if (result < 0) {
+               switch (errno) {
+                    case EINTR:
+                         continue;
+
+                    default:
+                         D_PERROR( "Fusion/Dispatcher: select() failed!\n" );
+                         return DR_IO;
+               }
+          } else
+               break;
+     }
+
+     D_MAGIC_ASSERT( world, FusionWorld );
+
+     if (world->dispatch_loop)
+          direct_thread_lock( world->dispatch_loop );
+
+     if (FD_ISSET( world->fusion_fd, &set ) &&
+         (msg_size = recvfrom( world->fusion_fd, buf, buf_size, 0, (struct sockaddr*)&addr, &addr_len )) > 0) {
+          FusionMessage *msg = (FusionMessage*)buf;
+
+          D_DEBUG_AT( Fusion_Main_Dispatch, "  = = dispatch -> got %zu bytes (of up to %zu)\n", msg_size, buf_size );
+
+          pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, NULL );
+
+          D_DEBUG_AT( Fusion_Main_Dispatch, " -> message from '%s'...\n", addr.sun_path );
+
+          if (world->dispatch_stop) {
+               D_DEBUG_AT( Fusion_Main_Dispatch, "  -> IGNORING (dispatch_stop!)\n" );
+          }
+          else {
+               switch (msg->type) {
+                    case FMT_SEND:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_SEND...\n" );
+                         break;
+
+                    case FMT_ENTER:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_ENTER...\n" );
+                         if (!fusion_master( world )) {
+                              D_ERROR( "Fusion/Dispatch: Got ENTER request, but I'm not master!\n" );
+                              break;
+                         }
+                         if (msg->enter.fusion_id == world->fusion_id) {
+                              D_ERROR( "Fusion/Dispatch: Received ENTER request from myself!\n" );
+                              break;
+                         }
+                         /* Nothing to do here. Send back message. */
+                         _fusion_send_message( world->fusion_fd, msg, sizeof(FusionEnter), &addr );
+                         break;
+
+                    case FMT_LEAVE:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_LEAVE...\n" );
+                         if (!fusion_master( world )) {
+                              D_ERROR( "Fusion/Dispatch: Got LEAVE request, but I'm not master!\n" );
+                              break;
+                         }
+                         if (world->fusion_id == FUSION_ID_MASTER) {
+                              direct_mutex_lock( &world->refs_lock );
+                              direct_map_iterate( world->refs_map, refs_iterate, &msg->leave.fusion_id );
+                              direct_mutex_unlock( &world->refs_lock );
+                         }
+                         if (msg->leave.fusion_id == world->fusion_id) {
+                              D_ERROR( "Fusion/Dispatch: Received LEAVE request from myself!\n" );
+                              break;
+                         }
+                         _fusion_remove_fusionee( world, msg->leave.fusion_id );
+                         break;
+
+                    case FMT_CALL:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_CALL...\n" );
+
+                         if (((FusionCallMessage*)msg)->caller == 0)    // FIXME: currently caller is set to non-zero even for ref_watch
+                              handle_dispatch_cleanups( world );
+
+                         _fusion_call_process( world, msg->call.call_id, &msg->call,
+                                               (msg_size != sizeof(FusionCallMessage)) ? (((FusionCallMessage*)msg) + 1) : NULL );
+                         break;
+
+                    case FMT_REACTOR:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_REACTOR...\n" );
+                         _fusion_reactor_process_message( world, msg->reactor.id, msg->reactor.channel,
+                                                          &buf[sizeof(FusionReactorMessage)] );
+                         if (msg->reactor.ref) {
+                              fusion_ref_down( msg->reactor.ref, true );
+                              if (fusion_ref_zero_trylock( msg->reactor.ref ) == DR_OK) {
+                                   fusion_ref_destroy( msg->reactor.ref );
+                                   SHFREE( world->shared->main_pool, msg->reactor.ref );
+                              }
+                         }
+                         break;
+
+                    default:
+                         D_BUG( "unexpected message type (%d)", msg->type );
+                         break;
+               }
+          }
+
+          handle_dispatch_cleanups( world );
+
+          D_DEBUG_AT( Fusion_Main_Dispatch, " ...done\n" );
+
+          pthread_setcancelstate( PTHREAD_CANCEL_ENABLE, NULL );
+     }
+
+     if (world->dispatch_loop)
+          direct_thread_unlock( world->dispatch_loop );
+
+     free( buf );
+
+     return DR_OK;
+}
+
 /*
  * Wait until all pending messages are processed.
  */
diff --git a/lib/fusion/lock.c b/lib/fusion/lock.c
index eb838a9..88c5b47 100644
--- a/lib/fusion/lock.c
+++ b/lib/fusion/lock.c
@@ -226,11 +226,10 @@ fusion_skirmish_prevail( FusionSkirmish *skirmish )
                     continue;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
-          D_PERROR ("FUSION_SKIRMISH_PREVAIL");
           return DR_FUSION;
      }
 
@@ -266,7 +265,7 @@ fusion_skirmish_swoop( FusionSkirmish *skirmish )
                     return DR_BUSY;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
@@ -312,7 +311,7 @@ fusion_skirmish_lock_count( FusionSkirmish *skirmish, int *lock_count )
                     continue;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
            }
 
@@ -350,7 +349,7 @@ fusion_skirmish_dismiss (FusionSkirmish *skirmish)
                     continue;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
@@ -393,7 +392,7 @@ fusion_skirmish_destroy (FusionSkirmish *skirmish)
                     continue;
                     
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
@@ -438,7 +437,7 @@ fusion_skirmish_wait( FusionSkirmish *skirmish, unsigned int timeout )
                     return DR_TIMEOUT;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
@@ -472,7 +471,7 @@ fusion_skirmish_notify( FusionSkirmish *skirmish )
                     continue;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
diff --git a/lib/fusion/object.c b/lib/fusion/object.c
index f5a1828..4f3ec5a 100644
--- a/lib/fusion/object.c
+++ b/lib/fusion/object.c
@@ -84,8 +84,6 @@ object_reference_watcher( int caller, int call_arg, void *call_ptr, void *ctx, u
      }
 #endif
 
-     D_MAGIC_ASSERT( pool, FusionObjectPool );
-
      /* Lock the pool. */
      if (fusion_skirmish_prevail( &pool->lock ))
           return FCHR_RETURN;
diff --git a/lib/fusion/object.h b/lib/fusion/object.h
index 44adbce..f75a44a 100644
--- a/lib/fusion/object.h
+++ b/lib/fusion/object.h
@@ -55,7 +55,6 @@ typedef u32 FusionObjectID;
 
 
 #ifdef __cplusplus
-}
 
 #include <map>
 
@@ -364,5 +363,9 @@ prefix##_globalize( type *object )                                             \
 
 FUSION_OBJECT_METHODS( void, fusion_object )
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif
 
diff --git a/lib/fusion/reactor.c b/lib/fusion/reactor.c
index 2b46835..afb1d0c 100644
--- a/lib/fusion/reactor.c
+++ b/lib/fusion/reactor.c
@@ -1698,7 +1698,9 @@ fusion_reactor_detach (FusionReactor *reactor,
 
      pthread_mutex_lock( &reactor->reactions_lock );
 
-     direct_list_remove( &reactor->reactions, &reaction->link );
+     /* reaction->link might be invalidated in fusion's event_dispatcher_loop() */
+     if (reaction->link.prev || reaction->link.next)
+          direct_list_remove( &reactor->reactions, &reaction->link );
 
      pthread_mutex_unlock( &reactor->reactions_lock );
 
diff --git a/lib/fusion/ref.c b/lib/fusion/ref.c
index 67dc49c..1d4008e 100644
--- a/lib/fusion/ref.c
+++ b/lib/fusion/ref.c
@@ -239,8 +239,10 @@ fusion_ref_up (FusionRef *ref, bool global)
                return DR_FAILURE;
           }
 
+#if 0
           D_DEBUG_AT( Fusion_Ref, "  -> %d references now\n",
                       ioctl( _fusion_fd( ref->multi.shared ), FUSION_REF_STAT, &ref->multi.id ) );
+#endif
      }
 
      return ret;
@@ -1704,7 +1706,7 @@ fusion_ref_down (FusionRef *ref, bool global)
 
                     direct_mutex_unlock( &ref->single.lock );
 
-                    fusion_call_execute( &copy_call, FCEF_NODIRECT | FCEF_ONEWAY, copy_arg, NULL, NULL );
+                    fusion_call_execute( &copy_call, FCEF_ONEWAY, copy_arg, NULL, NULL );
 
                     return DR_OK;
                }
diff --git a/lib/fusion/shm/heap.c b/lib/fusion/shm/heap.c
index 6592a04..c4482da 100644
--- a/lib/fusion/shm/heap.c
+++ b/lib/fusion/shm/heap.c
@@ -657,7 +657,7 @@ __shmalloc_init_heap( FusionSHM  *shm,
           goto error;
      }
 
-     D_DEBUG_AT( Fusion_SHMHeap, "  -> mmaping shared memory file... (%d bytes)\n", size );
+     D_DEBUG_AT( Fusion_SHMHeap, "  -> mmaping shared memory file... (%p %d bytes)\n", addr_base, size );
 
      /* map it shared */
      heap = mmap( addr_base, size + space, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, 0 );
@@ -716,7 +716,6 @@ __shmalloc_join_heap( FusionSHM  *shm,
      shmalloc_heap   *heap = NULL;
      int              open_flags = write ? O_RDWR : O_RDONLY;
      int              prot_flags = PROT_READ;
-     int              heapsize   = (size + BLOCKSIZE-1) / BLOCKSIZE;
 
      (void)shared;
 
@@ -729,8 +728,7 @@ __shmalloc_join_heap( FusionSHM  *shm,
      D_MAGIC_ASSERT( shm, FusionSHM );
      D_ASSERT( filename != NULL );
      D_ASSERT( addr_base != NULL );
-
-     size += BLOCKALIGN(sizeof(shmalloc_heap)) + BLOCKALIGN( heapsize * sizeof(shmalloc_info) );
+     D_ASSERT( size >= sizeof(shmalloc_heap) );
 
      shared = shm->shared;
 
diff --git a/lib/fusion/shm/pool.c b/lib/fusion/shm/pool.c
index 15c1f26..8ebcd6b 100644
--- a/lib/fusion/shm/pool.c
+++ b/lib/fusion/shm/pool.c
@@ -716,7 +716,12 @@ init_pool( FusionSHM           *shm,
                                 BLOCKALIGN( (max_size + BLOCKSIZE-1) / BLOCKSIZE * sizeof(shmalloc_info) );
 
      pool_addr_base = world->shared->pool_base;
-     world->shared->pool_base += ((pool_max_size + page_size - 1) & ~(page_size - 1)) + page_size;
+#ifdef __SH4__
+  #define SHM_ALIGN_SIZE 0x4000
+#else
+  #define SHM_ALIGN_SIZE page_size
+#endif
+     world->shared->pool_base += ((pool_max_size + page_size - 1) & ~(SHM_ALIGN_SIZE - 1)) + SHM_ALIGN_SIZE;
      /* Exceeded limit? */
      if (world->shared->pool_base > world->shared->pool_max)
           return DR_NOSHAREDMEMORY;
diff --git a/lib/fusiondale/one/ifusiondale_one.c b/lib/fusiondale/one/ifusiondale_one.c
index 0d3b970..cb17734 100644
--- a/lib/fusiondale/one/ifusiondale_one.c
+++ b/lib/fusiondale/one/ifusiondale_one.c
@@ -1147,6 +1147,8 @@ Construct( IFusionDale *thiz, const char *host, int session )
 
      D_DEBUG_AT( IFusionDale_One, "  -> TLS registered\n" );
 
+     data->base.core = data->core;
+
      thiz->AddRef          = IFusionDale_One_AddRef;
      thiz->Release         = IFusionDale_One_Release;
      thiz->EnterComa       = IFusionDale_One_EnterComa;
diff --git a/lib/wayland-dfb/Makefile.am b/lib/wayland-dfb/Makefile.am
new file mode 100644
index 0000000..6acff94
--- /dev/null
+++ b/lib/wayland-dfb/Makefile.am
@@ -0,0 +1,52 @@
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = wayland-dfb.pc
+
+INCLUDES = \
+	-I$(top_builddir)/include	\
+	-I$(top_builddir)/lib		\
+	-I$(top_srcdir)/include		\
+	-I$(top_srcdir)/lib		\
+	$(WAYLAND_CFLAGS)
+
+AM_CPPFLAGS = \
+	-DDATADIR=\"${RUNTIME_SYSROOT}@DATADIR@\"	\
+	-DMODULEDIR=\"${RUNTIME_SYSROOT}@MODULEDIR@\"
+
+
+includedir = @INCLUDEDIR@
+
+include_HEADERS = \
+	wayland-dfb-client-protocol.h	\
+	wayland-dfb-server-protocol.h	\
+	wayland-dfb.h
+
+
+lib_LTLIBRARIES = libwayland-dfb.la
+
+libwayland_dfb_la_SOURCES = wayland-dfb.cpp wayland-dfb-protocol.c
+libwayland_dfb_la_LDFLAGS = \
+	-version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)	\
+	-release $(LT_RELEASE)					\
+	$(DFB_LDFLAGS)
+libwayland_dfb_la_LIBADD = $(WAYLAND_LIBS) $(DFB_BASE_LIBS)
+
+
+BUILT_SOURCES = wayland-dfb-protocol.c \
+		wayland-dfb-client-protocol.h \
+		wayland-dfb-server-protocol.h
+
+CLEANFILES = $(BUILT_SOURCES)
+
+%-protocol.c : %.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) code < $< > $@
+
+%-server-protocol.h : %.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) server-header < $< > $@
+
+%-client-protocol.h : %.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header < $< > $@
+
+
+include $(top_srcdir)/rules/nmfile.make
+include $(top_srcdir)/rules/libs_deps.make
+
diff --git a/lib/wayland-dfb/wayland-dfb-protocol.c b/lib/wayland-dfb/wayland-dfb-protocol.c
new file mode 100644
index 0000000..8546049
--- /dev/null
+++ b/lib/wayland-dfb/wayland-dfb-protocol.c
@@ -0,0 +1,67 @@
+/* 
+ * (c) Copyright 2012-2013  DirectFB integrated media GmbH
+ * (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)
+ * (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+ * 
+ * All rights reserved.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_dfb_buffer_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	NULL,
+	&wl_dfb_buffer_interface,
+	NULL,
+	NULL,
+	NULL,
+};
+
+static const struct wl_message wl_dfb_requests[] = {
+	{ "create_buffer", "nuuu", types + 2 },
+};
+
+static const struct wl_message wl_dfb_events[] = {
+	{ "surface_id", "ou", types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_dfb_interface = {
+	"wl_dfb", 1,
+	1, wl_dfb_requests,
+	1, wl_dfb_events,
+};
+
+static const struct wl_message wl_dfb_buffer_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "set_display_timestamp", "uu", types + 0 },
+};
+
+static const struct wl_message wl_dfb_buffer_events[] = {
+	{ "release", "", types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_dfb_buffer_interface = {
+	"wl_dfb_buffer", 1,
+	2, wl_dfb_buffer_requests,
+	1, wl_dfb_buffer_events,
+};
+
diff --git a/lib/wayland-dfb/wayland-dfb.cpp b/lib/wayland-dfb/wayland-dfb.cpp
new file mode 100644
index 0000000..081572f
--- /dev/null
+++ b/lib/wayland-dfb/wayland-dfb.cpp
@@ -0,0 +1,305 @@
+/*
+ * Copyright © 2011 Kristian Høgsberg
+ * Copyright © 2011 Benjamin Franzke
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Kristian Høgsberg <krh@bitplanet.net>
+ *    Benjamin Franzke <benjaminfranzke@googlemail.com>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stddef.h>
+#include <unistd.h>
+
+#include <wayland-server.h>
+
+#include <directfb_util.h>
+
+#include "wayland-dfb.h"
+#include "wayland-dfb-server-protocol.h"
+
+
+D_LOG_DOMAIN( DFBWayland_wl_dfb,      "DFBWayland/wl_dfb",      "DirectFB Wayland extension" );
+D_LOG_DOMAIN( DFBWayland_Buffer,      "DFBWayland/Buffer",      "DirectFB Wayland Buffer" );
+
+/**********************************************************************************************************************/
+
+namespace WL {
+
+wl_dfb::wl_dfb()
+     :
+     global( NULL ),
+     display( NULL ),
+     dfb( NULL )
+{
+     D_DEBUG_AT( DFBWayland_wl_dfb, "wl_dfb::%s( %p )\n", __FUNCTION__, this );
+}
+
+wl_dfb::~wl_dfb()
+{
+     D_DEBUG_AT( DFBWayland_wl_dfb, "wl_dfb::%s( %p )\n", __FUNCTION__, this );
+
+     if (global)
+          wl_global_destroy( global );
+
+     if (dfb)
+          dfb->Release( dfb );
+}
+
+void
+wl_dfb::HandleSurfaceEvent( const DFBSurfaceEvent &event )
+{
+     D_DEBUG_AT( DFBWayland_wl_dfb, "wl_dfb::%s( %p, event %p ) <- type 0x%04x\n", __FUNCTION__, this, &event, event.type );
+
+     switch (event.type) {
+          case DSEVT_UPDATE: {
+               D_DEBUG_AT( DFBWayland_wl_dfb, "  -> UPDATE %u %d,%d-%dx%d %d\n",
+                           event.surface_id, DFB_RECTANGLE_VALS_FROM_REGION( &event.update ), event.flip_count );
+
+	       Buffer *buffer = surfaces[event.surface_id];
+
+	       if (buffer) {
+		    buffer->flip_count = event.flip_count;
+
+		    if (buffer->_surface)
+			    updates.push_back(buffer);
+               }
+               else
+                    D_LOG( DFBWayland_wl_dfb, VERBOSE, "  -> SURFACE WITH ID %u NOT FOUND\n", event.surface_id );
+
+               break;
+          }
+
+          default:
+               break;
+     }
+}
+
+/**********************************************************************************************************************/
+
+Buffer::Buffer()
+     :
+     flip_count( 0 ),
+     _surface( 0 )
+{
+     D_DEBUG_AT( DFBWayland_Buffer, "Buffer::%s( %p )\n", __FUNCTION__, this );
+}
+
+Buffer::~Buffer()
+{
+     D_DEBUG_AT( DFBWayland_Buffer, "Buffer::%s( %p )\n", __FUNCTION__, this );
+
+     surface->DetachEventBuffer( surface, wl_dfb->events );
+     surface->Release( surface );
+
+     _surface = 0;
+}
+
+/**********************************************************************************************************************/
+/**********************************************************************************************************************/
+
+static void
+destroy_buffer( struct wl_resource *resource )
+{
+     D_DEBUG_AT( DFBWayland_Buffer, "%s( resource %p )\n", __FUNCTION__, resource );
+
+     Buffer *buffer = (Buffer *) resource->data;
+
+     buffer->wl_dfb->surfaces.erase( buffer->surface_id );
+
+     delete buffer;
+}
+
+/**********************************************************************************************************************/
+
+static void
+buffer_destroy( struct wl_client *client, struct wl_resource *resource )
+{
+     D_DEBUG_AT( DFBWayland_Buffer, "%s( client %p, resource %p )\n", __FUNCTION__, client, resource );
+
+     wl_resource_destroy( resource );
+}
+
+const struct wl_buffer_interface dfb_buffer_interface = {
+     buffer_destroy
+};
+
+/**********************************************************************************************************************/
+/**********************************************************************************************************************/
+
+static void
+destroy_dfb( struct wl_resource *resource )
+{
+     D_DEBUG_AT( DFBWayland_wl_dfb, "%s( resource %p )\n", __FUNCTION__, resource );
+}
+
+/**********************************************************************************************************************/
+
+static void
+dfb_create_buffer(struct wl_client   *client,
+                  struct wl_resource *resource,
+                  uint32_t            id,
+                  uint32_t            surface_id,
+                  uint32_t            buffer_id,
+                  uint32_t            allocation_id)
+{
+     D_DEBUG_AT( DFBWayland_Buffer, "%s( client %p, resource %p, id %u, surface_id %u, buffer_id %u, allocation_id %u )\n",
+                 __FUNCTION__, client, resource, id, surface_id, buffer_id, allocation_id );
+
+     struct wl_dfb *wl_dfb = (struct wl_dfb*) resource->data;
+
+     DFBResult  ret;
+     Buffer    *buffer = new Buffer();
+
+     buffer->wl_dfb = wl_dfb;
+     buffer->surface_id = surface_id;
+
+     ret = wl_dfb->dfb->GetSurface( wl_dfb->dfb, surface_id, &buffer->surface );
+     if (ret) {
+          D_DERROR( ret, "DFBWayland/Buffer: IDirectFB::GetSurface( %u ) failed!\n", surface_id );
+          return;
+     }
+
+     D_DEBUG_AT( DFBWayland_Buffer, "  -> surface %p\n", buffer->surface );
+
+     ret = buffer->surface->GetSize( buffer->surface, &buffer->size.w, &buffer->size.h );
+     if (ret) {
+          D_DERROR( ret, "DFBWayland/Buffer: IDirectFBSurface::GetSize( surface_id %u ) failed!\n", surface_id );
+          return;
+     }
+
+     ret = buffer->surface->GetPixelFormat( buffer->surface, &buffer->format );
+     if (ret) {
+          D_DERROR( ret, "DFBWayland/Buffer: IDirectFBSurface::GetPixelFormat( surface_id %u ) failed!\n", surface_id );
+          return;
+     }
+
+     buffer->resource = wl_resource_create( client, &wl_buffer_interface, 1, id );
+     if (buffer->resource == NULL) {
+          wl_client_post_no_memory(client);
+          delete buffer;
+          return;
+     }
+
+     wl_resource_set_implementation( buffer->resource, &dfb_buffer_interface, buffer, destroy_buffer );
+
+
+     wl_dfb->surfaces[surface_id] = buffer;
+
+     buffer->surface->AttachEventBuffer( buffer->surface, wl_dfb->events );
+     buffer->surface->MakeClient( buffer->surface );
+}
+
+const static struct wl_dfb_interface dfb_interface = {
+     dfb_create_buffer
+};
+
+/**********************************************************************************************************************/
+/**********************************************************************************************************************/
+
+static void
+bind_dfb(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+     D_DEBUG_AT( DFBWayland_wl_dfb, "%s( client %p, data %p, version %u, id %u )\n", __FUNCTION__, client, data, version, id );
+
+     struct wl_dfb      *wl_dfb = (struct wl_dfb *) data;
+     struct wl_resource *resource;
+
+     resource = wl_resource_create( client, &wl_dfb_interface, 1, id );
+     if (resource == NULL) {
+          wl_client_post_no_memory(client);
+          return;
+     }
+
+     wl_resource_set_implementation( resource, &dfb_interface, wl_dfb, destroy_dfb );
+
+     if (wl_dfb->callback)
+          wl_dfb->callback( wl_dfb->callback_context, client );
+}
+
+/**********************************************************************************************************************/
+
+extern "C" {
+
+struct wl_dfb *
+wayland_dfb_init( struct wl_display      *display,
+                  IDirectFB              *directfb,
+                  wl_dfb_client_callback  callback,
+                  void                   *callback_context,
+                  IDirectFBEventBuffer   *events )
+{
+     D_DEBUG_AT( DFBWayland_wl_dfb, "%s( display %p, directfb %p )\n", __FUNCTION__, display, directfb );
+
+     wl_dfb *wldfb = new wl_dfb();
+
+     directfb->AddRef( directfb );
+     events->AddRef( events );
+
+     wldfb->display          = display;
+     wldfb->dfb              = directfb;
+     wldfb->events           = events;
+     wldfb->callback         = callback;
+     wldfb->callback_context = callback_context;
+     wldfb->global           = wl_global_create( display, &wl_dfb_interface, 1, wldfb, bind_dfb );
+
+     if (!wldfb->global) {
+          delete wldfb;
+          return NULL;
+     }
+
+     return wldfb;
+}
+
+void
+wayland_dfb_uninit(wl_dfb *wl_dfb)
+{
+     D_DEBUG_AT( DFBWayland_wl_dfb, "%s( wl_dfb %p )\n", __FUNCTION__, wl_dfb );
+
+     delete wl_dfb;
+}
+
+void
+wayland_dfb_handle_surface_event( struct wl_dfb         *dfb,
+                                  const DFBSurfaceEvent *event )
+{
+     D_DEBUG_AT( DFBWayland_wl_dfb, "%s( wl_dfb %p, event %p )\n", __FUNCTION__, dfb, event );
+
+     dfb->HandleSurfaceEvent( *event );
+}
+
+int
+wayland_is_dfb_buffer(struct wl_resource *resource)
+{
+     D_DEBUG_AT( DFBWayland_wl_dfb, "%s( resource %p )\n", __FUNCTION__, resource );
+
+     return resource->object.implementation == (void (**)(void)) &dfb_buffer_interface;
+}
+
+}
+
+
+
+}
+
diff --git a/lib/wayland-dfb/wayland-dfb.h b/lib/wayland-dfb/wayland-dfb.h
new file mode 100644
index 0000000..7d902ae
--- /dev/null
+++ b/lib/wayland-dfb/wayland-dfb.h
@@ -0,0 +1,165 @@
+#ifndef WAYLAND_DFB_H
+#define WAYLAND_DFB_H
+
+/*
+
+     Wayland Compositor                                                    Wayland Client
+          - CreateWindow           <- create_surface
+          - GetSurface, AttachEventBuffer
+                                                                           - wl_surface id
+
+                                                                      wl_shm              wl_egl_create_window
+                                                                      - create pool       eglCreateWindowSurface
+                                                                      - create buffer     -> wayland_dfb_get_surface( wl_surface_id )
+          - Allocate               <- attach buffer (wl_shm)
+                                   <- damage / commit
+          - Flip
+
+
+
+                                                                                          SurfacePeer
+                                                                                          -> GetAllocations
+
+                                                                                          eglSwapBuffers
+                                                                                          -> Flip
+                                   Update Event             <--
+                                   - flags
+          - lookup surface         - surface_id
+          - get buffer             - buffer_id
+                                   - allocation_id
+          - release buffer         - rectangle
+                                                            -->                           - FrameAck
+
+
+
+          GL Renderer (attach buffer)
+ 
+          - eglDestroyImageKHR (prev)
+          - eglCreateImageKHR (buffer)
+               -> GetAllocation/Allocate
+               -> Update?
+          - glEGLImageTargetTexture2D
+
+
+
+
+          - wlc-pid                IDirectFBWindows
+
+            pid != wlc-pid         <- window added (window_id)
+
+            - GetWindow
+            - GetSurface, AttachEventBuffer
+            - create_surface
+                                   Update Events
+                                   - flags
+                                   - surface_id
+                                   - buffer_id
+                                   - allocation_id
+                                   - rectangle
+
+
+
+
+
+
+     DirectFB Compositor
+
+
+
+*/
+
+#include <directfb.h>
+
+#include <wayland-server.h>
+
+
+#ifdef  __cplusplus
+
+#include <list>
+namespace WL {
+
+
+extern "C" {
+#else
+
+struct wl_dfb;
+#endif
+
+
+typedef void (*wl_dfb_client_callback)( void             *context,
+                                        struct wl_client *client );
+
+struct wl_dfb *
+wayland_dfb_init( struct wl_display      *display,
+                  IDirectFB              *dfb,
+                  wl_dfb_client_callback  callback,
+                  void                   *callback_context,
+                  IDirectFBEventBuffer   *events );
+
+void
+wayland_dfb_uninit(struct wl_dfb *dfb);
+
+void
+wayland_dfb_handle_surface_event( struct wl_dfb         *dfb,
+                                  const DFBSurfaceEvent *event );
+
+int
+wayland_is_dfb_buffer(struct wl_resource *resource);
+
+
+
+#ifdef  __cplusplus
+}
+
+
+struct Buffer
+{
+     Buffer();
+
+     virtual ~Buffer();
+
+     struct wl_resource            *resource;
+
+     struct wl_dfb                 *wl_dfb;
+
+     DFBSurfaceID                   surface_id;
+
+     IDirectFBSurface              *surface;
+     DFBDimension                   size;
+     DFBSurfacePixelFormat          format;
+
+     unsigned int                   flip_count;
+
+     void                          *_surface;
+};
+
+struct wl_dfb {
+public:
+     wl_dfb();
+     ~wl_dfb();
+
+     struct wl_global                  *global;
+
+     struct wl_display                 *display;
+     IDirectFB                         *dfb;
+     IDirectFBEventBuffer              *events;
+
+     wl_dfb_client_callback             callback;
+     void                              *callback_context;
+
+     std::map<DFBSurfaceID,Buffer*>     surfaces;
+
+     std::list<Buffer*>                 updates;
+
+     void HandleSurfaceEvent( const DFBSurfaceEvent &event );
+};
+
+}
+
+
+
+#endif
+
+
+#endif
+
diff --git a/lib/wayland-dfb/wayland-dfb.pc.in b/lib/wayland-dfb/wayland-dfb.pc.in
new file mode 100644
index 0000000..445acfb
--- /dev/null
+++ b/lib/wayland-dfb/wayland-dfb.pc.in
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: wayland-dfb
+Description: DirectFB wayland interface library
+Version: @VERSION@
+Requires: directfb wayland-client wayland-server
+Libs: -L${libdir} -lwayland-dfb
+Cflags: -I${includedir}
diff --git a/lib/wayland-dfb/wayland-dfb.xml b/lib/wayland-dfb/wayland-dfb.xml
new file mode 100644
index 0000000..bd740a8
--- /dev/null
+++ b/lib/wayland-dfb/wayland-dfb.xml
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="dfb">
+
+  <copyright>
+   (c) Copyright 2012-2013  DirectFB integrated media GmbH
+   (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+  </copyright>
+
+  <!-- DirectFB support. This object is created by the server and published
+       using the display's global event. -->
+  <interface name="wl_dfb" version="1">
+    <enum name="error">
+      <entry name="authenticate_fail" value="0"/>
+      <entry name="invalid_format" value="1"/>
+      <entry name="invalid_name" value="2"/>
+    </enum>
+
+    <!-- Create a wayland buffer for the surface buffer -->
+    <request name="create_buffer">
+      <arg name="id" type="new_id" interface="wl_dfb_buffer"/>
+      <arg name="surface_id" type="uint"/>
+      <arg name="buffer_id" type="uint"/>
+      <arg name="allocation_id" type="uint"/>
+    </request>
+
+    <!-- Get the surface ID of a wayland surface -->
+    <event name="surface_id">
+      <arg name="surface" type="object"/>
+      <arg name="surface_id" type="uint"/>
+    </event>
+  </interface>
+
+
+  <!-- DirectFB buffers. -->
+  <interface name="wl_dfb_buffer" version="1">
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy a buffer">
+      Destroy a buffer. If and how you need to release the backing
+      storage is defined by the buffer factory interface.
+
+      For possible side-effects to a surface, see wl_surface.attach.
+      </description>
+    </request>
+
+    <!-- Set the timestamp at which the DirectFB buffer should be made visible -->
+    <request name="set_display_timestamp">
+      <arg name="ts_low" type="uint"/>
+      <arg name="ts_high" type="uint"/>
+    </request>
+
+    <event name="release">
+      <description summary="compositor releases buffer">
+  Sent when this wl_buffer is no longer used by the compositor.
+  The client is now free to re-use or destroy this buffer and its
+  backing storage.
+
+  If a client receives a release event before the frame callback
+  requested in the same wl_surface.commit that attaches this
+  wl_buffer to a surface, then the client is immediately free to
+  re-use the buffer and its backing storage, and does not need a
+  second buffer for the next surface content update. Typically
+  this is possible, when the compositor maintains a copy of the
+  wl_surface contents, e.g. as a GL texture. This is an important
+  optimization for GL(ES) compositors with wl_shm clients.
+      </description>
+    </event>
+  </interface>
+
+</protocol>
diff --git a/rules/libs_deps.make b/rules/libs_deps.make
index be37eda..8d4fdd6 100644
--- a/rules/libs_deps.make
+++ b/rules/libs_deps.make
@@ -8,6 +8,7 @@ libdivine = $(top_builddir)/lib/divine/libdivine.la
 libfusiondale = $(top_builddir)/lib/fusiondale/libfusiondale.la
 libfusionsound = $(top_builddir)/lib/fusionsound/libfusionsound.la
 libppdfb = $(top_builddir)/lib/++dfb/lib++dfb.la
+libwayland_dfb = $(top_builddir)/lib/wayland-dfb/libwayland-dfb.la
 
 
 if DIRECTFB_BUILD_VOODOO
diff --git a/src/core/CoreSurfaceAllocation.flux b/src/core/CoreSurfaceAllocation.flux
new file mode 100644
index 0000000..4c931aa
--- /dev/null
+++ b/src/core/CoreSurfaceAllocation.flux
@@ -0,0 +1,40 @@
+interface {
+	name        ISurfaceAllocation
+	version     1.0
+	object      CoreSurfaceAllocation
+
+
+        method {
+               name	Update
+
+               arg {
+                       name        region
+                       direction   input
+                       type        struct
+                       typename    DFBRegion
+                       optional    yes
+               }
+        }
+
+
+        method {
+               name	Updated
+
+               arg {
+                       name        updates
+                       direction   input
+                       type        struct
+                       typename    DFBBox
+                       optional    yes
+                       count       num_updates
+               }
+
+               arg {
+                       name        num_updates
+                       direction   input
+                       type        int
+                       typename    u32
+               }
+        }
+}
+
diff --git a/src/core/CoreSurfaceAllocation_includes.h b/src/core/CoreSurfaceAllocation_includes.h
new file mode 100644
index 0000000..f1ba095
--- /dev/null
+++ b/src/core/CoreSurfaceAllocation_includes.h
@@ -0,0 +1,30 @@
+#include "CoreDFB_includes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include <core/surface.h>
+#include <core/surface_allocation.h>
+
+
+static __inline__ DirectResult
+CoreSurfaceAllocation_Call( CoreSurfaceAllocation *allocation,
+                            FusionCallExecFlags    flags,
+                            int                    call_arg,
+                            void                  *ptr,
+                            unsigned int           length,
+                            void                  *ret_ptr,
+                            unsigned int           ret_size,
+                            unsigned int          *ret_length )
+{
+     return fusion_call_execute3( &allocation->call,
+                                  (FusionCallExecFlags)(dfb_config->call_nodirect | flags),
+                                  call_arg, ptr, length, ret_ptr, ret_size, ret_length );
+}
+
+#ifdef __cplusplus
+}
+#endif
+
diff --git a/src/core/CoreSurfaceAllocation_real.cpp b/src/core/CoreSurfaceAllocation_real.cpp
new file mode 100644
index 0000000..6b5b47e
--- /dev/null
+++ b/src/core/CoreSurfaceAllocation_real.cpp
@@ -0,0 +1,110 @@
+/*
+   (c) Copyright 2001-2011  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjälä <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <directfb.h>
+
+
+extern "C" {
+#include <direct/debug.h>
+#include <direct/mem.h>
+#include <direct/messages.h>
+}
+
+#include <direct/ToString.h>
+
+#include <core/CoreSurfaceAllocation.h>
+
+
+D_DEBUG_DOMAIN( DirectFB_CoreSurfaceAllocation, "DirectFB/CoreSurfaceAllocation", "DirectFB CoreSurfaceAllocation" );
+
+/*********************************************************************************************************************/
+
+namespace DirectFB {
+
+
+DFBResult
+ISurfaceAllocation_Real::Update(
+                   const DFBRegion                              *region
+                   )
+{
+     D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "ISurfaceAllocation_Real::%s( region %p )\n", __FUNCTION__, region );
+
+     D_UNIMPLEMENTED();
+
+     return DFB_UNIMPLEMENTED;
+}
+
+DFBResult
+ISurfaceAllocation_Real::Updated( const DFBBox *updates,
+                                  u32           num_updates )
+{
+     DFBResult          ret;
+     CoreSurfaceBuffer *buffer;
+
+     D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "ISurfaceAllocation_Real::%s( obj %p, updates %p, num %u )\n", __FUNCTION__, obj, updates, num_updates );
+
+     ret = (DFBResult) fusion_object_get( core->shared->surface_buffer_pool, obj->buffer_id, (FusionObject**) &buffer );
+     if (ret && ret != DFB_DEAD)
+          return ret;
+
+     if (ret == DFB_DEAD) {
+          D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  -> dead object!\n" );
+     }
+     else {
+          if (obj->buffer) {
+               D_ASSERT( obj->buffer == buffer );
+          
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  <- buffer  %s\n", *ToString<CoreSurfaceBuffer>( *buffer ) );
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  <- written %p\n", buffer->written );
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  <- read    %p\n", buffer->read );
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  <- serial  %lu (this %lu)\n", buffer->serial.value, obj->serial.value );
+               
+               direct_serial_increase( &buffer->serial );
+               
+               direct_serial_copy( &obj->serial, &buffer->serial );
+               
+               buffer->written = obj;
+               buffer->read    = NULL;
+               
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  -> serial  %lu\n", buffer->serial.value );
+          }
+          else {
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  -> already decoupled!\n" );
+          }
+
+          dfb_surface_buffer_unref( buffer );
+     }
+
+     return DFB_OK;
+}
+
+
+}
+
diff --git a/src/core/core.c b/src/core/core.c
index 6676bee..985cc3e 100644
--- a/src/core/core.c
+++ b/src/core/core.c
@@ -1349,7 +1349,7 @@ dfb_core_shmpool( CoreDFB *core )
 {
      CoreDFBShared *shared;
 
-     D_ASSUME( core != NULL );
+//     D_ASSUME( core != NULL );
 
      if (!core)
           core = core_dfb;
@@ -1368,7 +1368,7 @@ dfb_core_shmpool_data( CoreDFB *core )
 {
      CoreDFBShared *shared;
 
-     D_ASSUME( core != NULL );
+//     D_ASSUME( core != NULL );
 
      if (!core)
           core = core_dfb;
@@ -1737,7 +1737,7 @@ dfb_core_shutdown( CoreDFB *core, bool emergency )
      dfb_gfx_cleanup();
 
      while (loops--) {
-          fusion_dispatch( core->world, 16384 );
+          fusion_dispatch( core->world, FUSION_MESSAGE_SIZE );
 
           ret = dfb_core_wait_all( core, 10000 );
           if (ret == DFB_OK)
diff --git a/src/core/input.c b/src/core/input.c
index d77bc9f..ff04877 100644
--- a/src/core/input.c
+++ b/src/core/input.c
@@ -587,6 +587,11 @@ dfb_input_core_shutdown( DFBInputCore *data,
                          D_ERROR( "DirectFB/Input: StopHotplug() failed with %s\n",
                                   driver->module->name );
                     }
+                    /* No attached devices, e.g. unused Input Hub Driver */
+                    if (!driver->nr_devices) {
+                         direct_module_unref( driver->module );
+                         D_FREE( driver );
+                    }
                }
           }
      }
diff --git a/src/core/layer_context.c b/src/core/layer_context.c
index ef178b6..bd4665a 100644
--- a/src/core/layer_context.c
+++ b/src/core/layer_context.c
@@ -788,8 +788,12 @@ wait:
 
                region->state |= configured;
 
+               /* Don't freeze for Surfaceless layers. */
+               if (surface)
+                  flags |= CLRCF_FREEZE;
+
                /* Set the new region configuration. */
-               dfb_layer_region_set_configuration( region, &region_config, flags | CLRCF_FREEZE );
+               dfb_layer_region_set_configuration( region, &region_config, flags );
 
                /* Enable the primary region. */
                if (! D_FLAGS_IS_SET( region->state, CLRSF_ENABLED ))
@@ -908,7 +912,7 @@ update_primary_region_config( CoreLayerContext           *context,
      D_ASSERT( config != NULL );
 
      if (context->primary.region) {
-          if (flags != CLRCF_DEST)
+          if ((flags != CLRCF_DEST) && (flags != CLRCF_OPACITY))
                flags |= CLRCF_FREEZE;
 
           /* Set the new configuration. */
diff --git a/src/core/shared_surface_pool.c b/src/core/shared_surface_pool.c
index 8a42ded..22b2082 100644
--- a/src/core/shared_surface_pool.c
+++ b/src/core/shared_surface_pool.c
@@ -44,6 +44,8 @@
 
 #include <misc/conf.h>
 
+D_DEBUG_DOMAIN( Core_SharedSurfacePool, "Core/SharedSurfacePool", "Core Shared Surface Pool" );
+
 /**********************************************************************************************************************/
 
 typedef struct {
@@ -94,6 +96,8 @@ sharedInitPool( CoreDFB                    *core,
      SharedPoolData      *data  = pool_data;
      SharedPoolLocalData *local = pool_local;
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_ASSERT( ret_desc != NULL );
 
@@ -145,6 +149,8 @@ sharedAllocateBuffer( CoreSurfacePool       *pool,
      SharedPoolData       *data  = pool_data;
      SharedAllocationData *alloc = alloc_data;
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
 
@@ -163,6 +169,8 @@ sharedAllocateBuffer( CoreSurfacePool       *pool,
           dfb_surface_calc_buffer_size( surface, dfb_config->system_surface_align_pitch, 0,
                                         &alloc->pitch, &alloc->size );
 
+          D_DEBUG_AT( Core_SharedSurfacePool, "Allocating %d bytes for allocation 0x%p\n", alloc->size + dfb_config->system_surface_align_base, alloc );
+
           alloc->addr = SHMALLOC( data->shmpool, alloc->size + dfb_config->system_surface_align_base );
           if ( !alloc->addr )
                return D_OOSHM();
@@ -180,6 +188,8 @@ sharedAllocateBuffer( CoreSurfacePool       *pool,
 
           dfb_surface_calc_buffer_size( surface, 8, 0, &alloc->pitch, &alloc->size );
 
+          D_DEBUG_AT( Core_SharedSurfacePool, "Allocating %d bytes for allocation 0x%p\n", alloc->size, alloc );
+
           alloc->addr = SHMALLOC( data->shmpool, alloc->size );
           if (!alloc->addr)
                return D_OOSHM();
@@ -204,8 +214,12 @@ sharedDeallocateBuffer( CoreSurfacePool       *pool,
      SharedPoolData       *data  = pool_data;
      SharedAllocationData *alloc = alloc_data;
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "Freeing %d bytes of allocation 0x%p\n", alloc->size, alloc );
+
      SHFREE( data->shmpool, alloc->addr );
 
      return DFB_OK;
@@ -221,6 +235,8 @@ sharedLock( CoreSurfacePool       *pool,
 {
      SharedAllocationData *alloc = alloc_data;
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
      D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );
@@ -244,6 +260,8 @@ sharedUnlock( CoreSurfacePool       *pool,
               void                  *alloc_data,
               CoreSurfaceBufferLock *lock )
 {
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
      D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );
diff --git a/src/core/surface.c b/src/core/surface.c
index 460f724..ee4a172 100644
--- a/src/core/surface.c
+++ b/src/core/surface.c
@@ -1396,6 +1396,7 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
      char                   head[30];
      bool                   rgb   = false;
      bool                   alpha = false;
+     bool                   IsYCbCrMb = false;
 #ifdef USE_ZLIB
      gzFile                 gz_p = NULL, gz_g = NULL;
      static const char     *gz_ext = ".gz";
@@ -1440,6 +1441,7 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
 
      /* Check pixel format. */
      switch (lock.buffer->format) {
+          case DSPF_LUT4:
           case DSPF_LUT8:
                palette = surface->palette;
 
@@ -1479,6 +1481,7 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
           case DSPF_RGB332:
           case DSPF_RGB16:
           case DSPF_RGB24:
+          case DSPF_BGR24:
           case DSPF_RGB32:
           case DSPF_YUY2:
           case DSPF_UYVY:
@@ -1488,10 +1491,16 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
           case DSPF_RGB555:
           case DSPF_BGR555:
           case DSPF_YUV444P:
+          case DSPF_NV24:
           case DSPF_VYU:
                rgb   = true;
                break;
 
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               IsYCbCrMb = true;
+               break;
+
 
           default:
                D_ERROR( "DirectFB/core/surfaces: surface dump for format "
@@ -1573,6 +1582,24 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
           }
      }
 
+     /* Create a .gam file for Omega2 MB buffers. */
+     if (IsYCbCrMb) {
+          if (prefix)
+               snprintf( filename, len, "%s/%s_%04d.gam", path, prefix, num );
+          else
+               snprintf( filename, len, "%s.gam", path );
+
+          fd_p = open( filename, O_EXCL | O_CREAT | O_WRONLY, 0644 );
+          if (fd_p < 0) {
+               D_PERROR("DirectFB/core/surfaces: "
+                        "could not open %s!\n", filename);
+               dfb_surface_buffer_unlock( &lock );
+               if (palette)
+                    dfb_palette_unref( palette );
+               return DFB_IO;
+          }
+     }
+
 #ifdef USE_ZLIB
      if (rgb)
           gz_p = gzdopen( fd_p, "wb" );
@@ -1603,6 +1630,35 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
 #endif
      }
 
+     /* Write the .gam header. */
+     if (IsYCbCrMb) {
+          struct GamPictureHeader {
+               uint16_t header_size;
+               uint16_t signature;
+               uint16_t type;
+               uint16_t properties;
+               uint32_t pictureWidth;
+               uint32_t pictureHeight;
+               uint32_t lumaSize;
+               uint32_t chromaSize;
+          } header;
+
+          unsigned int chromaHeight = surface->config.size.h;
+          if (lock.buffer->format == DSPF_NV12MB)
+               chromaHeight >>= 1;
+
+          header.header_size = 0x6;
+          header.signature = (lock.buffer->format == DSPF_NV12MB) ? 0x420f : 0x422f;
+          header.type = (lock.buffer->format == DSPF_NV12MB) ? 0x94 : 0x95;
+          header.properties = 0x10;
+          header.pictureWidth = surface->config.size.w;
+          header.pictureHeight = surface->config.size.h;
+          header.lumaSize = surface->config.size.w * surface->config.size.h;
+          header.chromaSize = surface->config.size.w * chromaHeight;
+
+          res = write( fd_p, &header, sizeof(header) );
+     }
+
      /* Write the pixmap (and graymap) data. */
      for (i=0; i<surface->config.size.h; i++) {
           int n3;
@@ -1627,6 +1683,18 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
                          buf_p[n3+2] = palette->entries[src8[n]].b;
                     }
                }
+               else if (lock.buffer->format == DSPF_LUT4) {
+                    for (n=0, n3=0; n<(surface->config.size.w>>1); n+=1, n3+=6) {
+                         int i = src8[n] & 0xf; /* 4 lsbs */
+                         buf_p[n3+0] = palette->entries[i].r;
+                         buf_p[n3+1] = palette->entries[i].g;
+                         buf_p[n3+2] = palette->entries[i].b;
+                         i = src8[n] >> 4; /* 4 msbs */
+                         buf_p[n3+3] = palette->entries[i].r;
+                         buf_p[n3+4] = palette->entries[i].g;
+                         buf_p[n3+5] = palette->entries[i].b;
+                    }
+               }
                else
                     dfb_convert_to_rgb24( lock.buffer->format,
                                           srces[0], pitches[0],
@@ -1648,6 +1716,14 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
                     for (n=0; n<surface->config.size.w; n++)
                          buf_g[n] = palette->entries[src8[n]].a;
                }
+               else if (lock.buffer->format == DSPF_LUT4) {
+                    for (n=0; n<(surface->config.size.w>>1); n++) {
+                         int i = src8[n] & 0xf; /* 4 lsbs */
+                         buf_g[2 * n] = palette->entries[i].a;
+                         i = src8[n] >> 4; /* 4 msbs */
+                         buf_g[2 * n + 1] = palette->entries[i].a;
+                    }
+               }
                else
                     dfb_convert_to_a8( lock.buffer->format, srces[0], pitches[0], surface->config.size.h,
                                        buf_g, surface->config.size.w, surface->config.size.w, 1 );
@@ -1657,6 +1733,20 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
                res = write( fd_g, buf_g, surface->config.size.w );
 #endif
           }
+
+          /* Write luma data. */
+          if (IsYCbCrMb)
+               res = write( fd_p, src8, surface->config.size.w );
+     }
+
+     /* Write chroma data. */
+     if (IsYCbCrMb) {
+          unsigned int chroma_height = surface->config.size.h;
+          if (lock.buffer->format == DSPF_NV12MB)
+               chroma_height >>= 1;
+          res = write( fd_p,
+                       lock.addr + lock.pitch * surface->config.size.h,
+                       lock.pitch * chroma_height );
      }
 
      /* Unlock the surface buffer. */
@@ -1682,6 +1772,10 @@ dfb_surface_dump_buffer2( CoreSurface           *surface,
      if (alpha)
           close( fd_g );
 
+     /* Close the .gam file. */
+     if (IsYCbCrMb)
+          close( fd_p );
+
      return DFB_OK;
 }
 
diff --git a/src/core/surface.h b/src/core/surface.h
index f285ba2..0be2803 100644
--- a/src/core/surface.h
+++ b/src/core/surface.h
@@ -501,9 +501,9 @@ dfb_surface_get_data_offsets( const CoreSurfaceConfig * const config,
      D_ASSERT( data != NULL );
      D_ASSERT( pitch > 0 );
      D_ASSERT( x >= 0 );
-     D_ASSERT( x < config->size.w );
+     D_ASSERT( config->size.w && x < config->size.w );
      D_ASSERT( y >= 0 );
-     D_ASSERT( y < config->size.h );
+     D_ASSERT( config->size.h && y < config->size.h );
      D_ASSERT( !num
                || (num && pointers && pitches) );
 
diff --git a/src/core/surface_allocation.cpp b/src/core/surface_allocation.cpp
index 7bcf445..221c8b0 100644
--- a/src/core/surface_allocation.cpp
+++ b/src/core/surface_allocation.cpp
@@ -326,6 +326,15 @@ transfer_buffer( const CoreSurfaceConfig *config,
                }
                break;
 
+          case DSPF_NV24:
+               for (i=0; i<config->size.h; i++) {
+                    direct_memcpy( dst, src,
+                                   DFB_BYTES_PER_LINE( config->format, config->size.w ) * 2 );
+                    src += srcpitch;
+                    dst += dstpitch;
+               }
+               break;
+
           case DSPF_YUV444P:
                for (i=0; i<config->size.h*2; i++) {
                     direct_memcpy( dst, src,
diff --git a/src/core/surface_buffer.c b/src/core/surface_buffer.c
index 94b876e..4b022d8 100644
--- a/src/core/surface_buffer.c
+++ b/src/core/surface_buffer.c
@@ -707,6 +707,8 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
      CoreSurface       *surface;
      CorePalette       *palette = NULL;
 
+     bool               IsYCbCrMb = false;
+
      D_DEBUG_AT( Core_SurfBuffer, "%s( %p, %p, %p )\n", __FUNCTION__, buffer, directory, prefix );
 
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
@@ -717,6 +719,7 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
 
      /* Check pixel format. */
      switch (buffer->format) {
+          case DSPF_LUT4:
           case DSPF_LUT8:
           case DSPF_ALUT8:
                palette = surface->palette;
@@ -754,6 +757,7 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
           case DSPF_RGB332:
           case DSPF_RGB16:
           case DSPF_RGB24:
+          case DSPF_BGR24:
           case DSPF_RGB32:
           case DSPF_YUY2:
           case DSPF_UYVY:
@@ -763,10 +767,16 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
           case DSPF_RGB555:
           case DSPF_BGR555:
           case DSPF_YUV444P:
+          case DSPF_NV24:
           case DSPF_VYU:
                rgb   = true;
                break;
 
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               IsYCbCrMb = true;
+               break;
+
 
           default:
                D_ERROR( "DirectFB/core/surfaces: surface dump for format "
@@ -845,6 +855,23 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
           }
      }
 
+     /* Create a .gam file for Omega2 MB buffers. */
+     if (IsYCbCrMb) {
+          if (prefix)
+               snprintf( filename, len, "%s/%s_%04d.gam", directory, prefix, num );
+          else
+               snprintf( filename, len, "%s.gam", directory );
+
+          fd_p = open( filename, O_EXCL | O_CREAT | O_WRONLY, 0644 );
+          if (fd_p < 0) {
+               D_PERROR("DirectFB/core/surfaces: "
+                        "could not open %s!\n", filename);
+               if (palette)
+                    dfb_palette_unref( palette );
+               return DFB_IO;
+          }
+     }
+
 #ifdef USE_ZLIB
      if (rgb)
           gz_p = gzdopen( fd_p, "wb" );
@@ -880,6 +907,36 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
 	 }
      }
 
+     /* Write the .gam header. */
+     if (IsYCbCrMb) {
+          struct GamPictureHeader {
+               uint16_t header_size;
+               uint16_t signature;
+               uint16_t type;
+               uint16_t properties;
+               uint32_t pictureWidth;
+               uint32_t pictureHeight;
+               uint32_t lumaSize;
+               uint32_t chromaSize;
+          } header;
+
+          unsigned int chromaHeight = surface->config.size.h;
+          if (buffer->format == DSPF_NV12MB)
+               chromaHeight >>= 1;
+
+          header.header_size = 0x6;
+          header.signature = (buffer->format == DSPF_NV12MB) ? 0x420f : 0x422f;
+          header.type = (buffer->format == DSPF_NV12MB) ? 0x94 : 0x95;
+          header.properties = 0x10;
+          header.pictureWidth = surface->config.size.w;
+          header.pictureHeight = surface->config.size.h;
+          header.lumaSize = surface->config.size.w * surface->config.size.h;
+          header.chromaSize = surface->config.size.w * chromaHeight;
+
+          res = write( fd_p, &header, sizeof(header) );
+          (void)res;
+     }
+
      /* Write the pixmap (and graymap) data. */
      for (i=0; i<surface->config.size.h; i++) {
           int n3;
@@ -929,6 +986,18 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
                          buf_p[n3+2] = palette->entries[src8[n]].b;
                     }
                }
+               else if (buffer->format == DSPF_LUT4) {
+                    for (n=0, n3=0; n<(surface->config.size.w>>1); n+=1, n3+=6) {
+                         int i = src8[n] & 0xf; /* 4 lsbs */
+                         buf_p[n3+0] = palette->entries[i].r;
+                         buf_p[n3+1] = palette->entries[i].g;
+                         buf_p[n3+2] = palette->entries[i].b;
+                         i = src8[n] >> 4; /* 4 msbs */
+                         buf_p[n3+3] = palette->entries[i].r;
+                         buf_p[n3+4] = palette->entries[i].g;
+                         buf_p[n3+5] = palette->entries[i].b;
+                    }
+               }
                else
                     dfb_convert_to_rgb24( buffer->format,
                                           srces[0], pitches[0],
@@ -952,6 +1021,14 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
                     for (n=0; n<surface->config.size.w; n++)
                          buf_g[n] = palette->entries[src8[n]].a;
                }
+               else if (buffer->format == DSPF_LUT4) {
+                    for (n=0; n<(surface->config.size.w>>1); n++) {
+                         int i = src8[n] & 0xf; /* 4 lsbs */
+                         buf_g[2 * n] = palette->entries[i].a;
+                         i = src8[n] >> 4; /* 4 msbs */
+                         buf_g[2 * n + 1] = palette->entries[i].a;
+                    }
+               }
                else
                     dfb_convert_to_a8( buffer->format, srces[0], pitches[0], surface->config.size.h,
                                        buf_g, surface->config.size.w, surface->config.size.w, 1 );
@@ -962,6 +1039,23 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
                (void)res;
 #endif
           }
+
+          /* Write luma data. */
+          if (IsYCbCrMb) {
+               res = write( fd_p, srces[0], surface->config.size.w );
+               (void)res;
+          }
+     }
+
+     /* Write chroma data. */
+     if (IsYCbCrMb) {
+          unsigned int chroma_height = surface->config.size.h;
+          if (buffer->format == DSPF_NV12MB)
+               chroma_height >>= 1;
+          res = write( fd_p,
+                       addr + pitch * surface->config.size.h,
+                       pitch * chroma_height );
+          (void)res;
      }
 
      /* Release the palette. */
@@ -984,6 +1078,10 @@ dfb_surface_buffer_dump_type_locked2( CoreSurfaceBuffer     *buffer,
      if (alpha && !raw)
           close( fd_g );
 
+     /* Close the .gam file. */
+     if (IsYCbCrMb)
+          close( fd_p );
+
      return DFB_OK;
 }
 
diff --git a/src/core/surface_pool.c b/src/core/surface_pool.c
index 72125a7..a47cb8e 100644
--- a/src/core/surface_pool.c
+++ b/src/core/surface_pool.c
@@ -876,7 +876,7 @@ fixme_retry:
      fusion_vector_foreach (allocation, i, pool->allocs) {
           CORE_SURFACE_ALLOCATION_ASSERT( allocation );
 
-          if (allocation->flags & CSALF_MUCKOUT) {
+          if (allocation->buffer && (allocation->flags & CSALF_MUCKOUT)) {
                CoreSurface       *alloc_surface;
                CoreSurfaceBuffer *alloc_buffer;
 
diff --git a/src/core/system.h b/src/core/system.h
index ca1c1be..eb207da 100644
--- a/src/core/system.h
+++ b/src/core/system.h
@@ -56,7 +56,9 @@ typedef enum {
      CORE_CARE1,
      CORE_ANDROID,
      CORE_EGL,
-     CORE_DRMKMS
+     CORE_STMFBDEV,
+     CORE_DRMKMS,
+     CORE_WAYLAND
 } CoreSystemType;
 
 typedef enum {
diff --git a/src/display/idirectfbsurface.c b/src/display/idirectfbsurface.c
index 8f7adec..876a675 100644
--- a/src/display/idirectfbsurface.c
+++ b/src/display/idirectfbsurface.c
@@ -3806,7 +3806,6 @@ IDirectFBSurface_listener( const void *msg_data, void *ctx )
 
      if (notification->flags & CSNF_DESTROY) {
           if (data->surface) {
-               D_WARN( "IDirectFBSurface surface destroyed" );
                data->surface = NULL;
           }
           return RS_REMOVE;
diff --git a/src/gfx/convert.c b/src/gfx/convert.c
index 7d112b7..5bacd9b 100644
--- a/src/gfx/convert.c
+++ b/src/gfx/convert.c
@@ -119,6 +119,7 @@ dfb_pixel_to_color( DFBSurfacePixelFormat  format,
 
           case DSPF_ABGR:
                ret_color->a = pixel >> 24;
+          case DSPF_BGR24:
                ret_color->b = (pixel & 0xff0000) >> 16;
                ret_color->g = (pixel & 0x00ff00) >>  8;
                ret_color->r = (pixel & 0x0000ff);
@@ -208,6 +209,9 @@ dfb_pixel_from_color( DFBSurfacePixelFormat  format,
           case DSPF_RGB24:
                return PIXEL_RGB32( color->r, color->g, color->b ) & 0xffffff;
 
+          case DSPF_BGR24:
+               return PIXEL_RGB32( color->b, color->g, color->r ) & 0xffffff;
+
           case DSPF_RGB32:
                return PIXEL_RGB32( color->r, color->g, color->b ) & 0xffffff;
 
@@ -336,6 +340,7 @@ dfb_pixel_to_components( DFBSurfacePixelFormat  format,
 
           case DSPF_ABGR:
                *a  = pixel >> 24;
+          case DSPF_BGR24:
                *c0 = (pixel & 0xff0000) >> 16;
                *c1 = (pixel & 0x00ff00) >>  8;
                *c2 = (pixel & 0x0000ff);
@@ -441,6 +446,28 @@ dfb_convert_to_rgb16( DFBSurfacePixelFormat  format,
                }
                break;
 
+          case DSPF_NV24:
+               while (height--) {
+                    const u8  *src8  = src;
+                    const u16 *src16 = src + surface_height * spitch;
+
+                    for (x=0; x<width; x++) {
+                         int r, g, b;
+
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[x], src16[x] >> 8, src16[x] & 0xff, r, g, b );
+#else
+                         YCBCR_TO_RGB( src8[x], src16[x] & 0xff, src16[x] >> 8, r, g, b );
+#endif
+
+                         dst[x] = PIXEL_RGB16( r, g, b );
+                    }
+
+                    src += spitch;
+                    dst += dp2;
+               }
+               break;
+
           case DSPF_UYVY:
                while (height--) {
                     const u32 *src32 = src;
@@ -753,6 +780,28 @@ dfb_convert_to_rgb555( DFBSurfacePixelFormat  format,
                }
                break;
 
+          case DSPF_NV24:
+               while (height--) {
+                    const u8  *src8  = src;
+                    const u16 *src16 = src + surface_height * spitch;
+
+                    for (x=0; x<width; x++) {
+                         int r, g, b;
+
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[x], src16[x] >> 8, src16[x] & 0xff, r, g, b );
+#else
+                         YCBCR_TO_RGB( src8[x], src16[x] & 0xff, src16[x] >> 8, r, g, b );
+#endif
+
+                         dst[x] = PIXEL_RGB555( r, g, b );
+                    }
+
+                    src += spitch;
+                    dst += dp2;
+               }
+               break;
+
           case DSPF_RGB444:
           case DSPF_ARGB4444:
                while (height--) {
@@ -1046,6 +1095,26 @@ dfb_convert_to_rgb32( DFBSurfacePixelFormat  format,
                }
                break;
 
+          case DSPF_BGR24:
+               while (height--) {
+                    const u8 *src8 = src;
+
+                    for (x=0; x<width; x++)
+#ifdef WORDS_BIGENDIAN
+                         dst[x] = ( src8[x*3+2] << 16 ) |
+                                  ( src8[x*3+1] <<  8 ) |
+                                  ( src8[x*3+0]       );
+#else
+                         dst[x] = ( src8[x*3+0] << 16 ) |
+                                  ( src8[x*3+1] <<  8 ) |
+                                  ( src8[x*3+2]       );
+#endif
+
+                    src += spitch;
+                    dst += dp4;
+               }
+               break;
+
           case DSPF_AYUV:
                while (height--) {
                     const u32 *src32 = src;
@@ -1085,6 +1154,28 @@ dfb_convert_to_rgb32( DFBSurfacePixelFormat  format,
                }
                break;
 
+          case DSPF_NV24:
+               while (height--) {
+                    const u8  *src8  = src;
+                    const u16 *src16 = src + surface_height * spitch;
+
+                    for (x=0; x<width; x++) {
+                         int r, g, b;
+
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[x], src16[x] >> 8, src16[x] & 0xff, r, g, b );
+#else
+                         YCBCR_TO_RGB( src8[x], src16[x] & 0xff, src16[x] >> 8, r, g, b );
+#endif
+
+                         dst[x] = PIXEL_RGB32( r, g, b );
+                    }
+
+                    src += spitch;
+                    dst += dp4;
+               }
+               break;
+
           case DSPF_RGB444:
           case DSPF_ARGB4444:
                while (height--) {
@@ -1364,6 +1455,26 @@ dfb_convert_to_argb( DFBSurfacePixelFormat  format,
                }
                break;
 
+          case DSPF_BGR24:
+               while (height--) {
+                    const u8 *src8 = src;
+
+                    for (x=0; x<width; x++)
+#ifdef WORDS_BIGENDIAN
+                         dst[x] = ( src8[x*3+2] << 16 ) |
+                                  ( src8[x*3+1] <<  8 ) |
+                                  ( src8[x*3+0]       ) | 0xff000000;
+#else
+                         dst[x] = ( src8[x*3+0] << 16 ) |
+                                  ( src8[x*3+1] <<  8 ) |
+                                  ( src8[x*3+2]       ) | 0xff000000;
+#endif
+
+                    src += spitch;
+                    dst += dp4;
+               }
+               break;
+
           case DSPF_AYUV:
                while (height--) {
                     const u32 *src32 = src;
@@ -1403,6 +1514,28 @@ dfb_convert_to_argb( DFBSurfacePixelFormat  format,
                }
                break;
 
+          case DSPF_NV24:
+               while (height--) {
+                    const u8  *src8  = src;
+                    const u16 *src16 = src + surface_height * spitch;
+
+                    for (x=0; x<width; x++) {
+                         int r, g, b;
+
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[x], src16[x] >> 8, src16[x] & 0xff, r, g, b );
+#else
+                         YCBCR_TO_RGB( src8[x], src16[x] & 0xff, src16[x] >> 8, r, g, b );
+#endif
+
+                         dst[x] = PIXEL_ARGB( 0xff, r, g, b );
+                    }
+
+                    src += spitch;
+                    dst += dp4;
+               }
+               break;
+
           case DSPF_ARGB4444:
                while (height--) {
                     const u16 *src16 = src;
@@ -1864,6 +1997,26 @@ dfb_convert_to_rgb24( DFBSurfacePixelFormat  format,
                     dst += dpitch;
                }
                break;
+          case DSPF_BGR24:
+               while (height--) {
+                    const u8 *src8 = src;
+
+                    for (n=0, n3=0; n<width; n++, n3+=3) {
+#ifdef WORDS_BIGENDIAN
+                         dst[n3+0] = src8[n3+2];
+                         dst[n3+1] = src8[n3+1];
+                         dst[n3+2] = src8[n3+0];
+#else
+                         dst[n3+0] = src8[n3+0];
+                         dst[n3+1] = src8[n3+1];
+                         dst[n3+2] = src8[n3+2];
+#endif
+                    }
+
+                    src += spitch;
+                    dst += dpitch;
+               }
+               break;
           case DSPF_RGB32:
                while (height--) {
                     const u32 *src32 = src;
@@ -2036,6 +2189,25 @@ dfb_convert_to_rgb24( DFBSurfacePixelFormat  format,
                     dst += dpitch;
                }
                break;
+          case DSPF_NV24:
+               while (height--) {
+                    const u16 *cbcr = src + surface_height * spitch;
+                    const u8  *src8 = src;
+
+                    for (n=0, n3=0; n<width; n++, n3+=3) {
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[n], cbcr[n] >> 8, cbcr[n] & 0xff,
+                                       dst[n3+0], dst[n3+1], dst[n3+2] );
+#else
+                         YCBCR_TO_RGB( src8[n], cbcr[n] & 0xff, cbcr[n] >> 8,
+                                       dst[n3+0], dst[n3+1], dst[n3+2] );
+#endif
+                    }
+
+                    src += spitch;
+                    dst += dpitch;
+               }
+               break;
           case DSPF_RGBA5551:
                while (height--) {
                     const u16 *src16 = src;
@@ -2255,6 +2427,7 @@ dfb_convert_to_a8( DFBSurfacePixelFormat  format,
           case DSPF_BGR555:
           case DSPF_RGB16:
           case DSPF_RGB24:
+          case DSPF_BGR24:
           case DSPF_RGB32:
           case DSPF_VYU:
           case DSPF_YUY2:
@@ -2262,6 +2435,7 @@ dfb_convert_to_a8( DFBSurfacePixelFormat  format,
           case DSPF_NV16:
           case DSPF_YV16:
           case DSPF_YUV444P:
+          case DSPF_NV24:
                while (height--) {
                     memset( dst, 0xff, width );
 
diff --git a/src/gfx/generic/generic.c b/src/gfx/generic/generic.c
index b2a3d38..16da805 100644
--- a/src/gfx/generic/generic.c
+++ b/src/gfx/generic/generic.c
@@ -124,7 +124,7 @@ static void gInit_BigEndian();
 #define Bop_PFI_OP_Aop_PFI( op ) Bop_12vv_##op##_Aop
 #include "template_colorkey_16.h"
 
-/* RGB24/VYU */
+/* RGB24/BGR24/VYU */
 #define RGB_MASK 0xffffff
 #define Cop_OP_Aop_PFI( op ) Cop_##op##_Aop_24_24
 #define Bop_PFI_OP_Aop_PFI( op ) Bop_24_24_##op##_Aop
@@ -424,6 +424,24 @@ static void gInit_BigEndian();
 #define B_MASK 0x0000ff
 #include "template_acc_24.h"
 
+/* BGR24 */
+#define EXPAND_Ato8( a ) 0xff
+#define EXPAND_Rto8( r ) (r)
+#define EXPAND_Gto8( g ) (g)
+#define EXPAND_Bto8( b ) (b)
+#define PIXEL_OUT( a, r, g, b ) PIXEL_RGB32( b, g, r )
+#define Sop_PFI_OP_Dacc( op ) Sop_bgr24_##op##_Dacc
+#define Sacc_OP_Aop_PFI( op ) Sacc_##op##_Aop_bgr24
+#define A_SHIFT 0
+#define B_SHIFT 16
+#define G_SHIFT 8
+#define R_SHIFT 0
+#define A_MASK 0
+#define B_MASK 0xff0000
+#define G_MASK 0x00ff00
+#define R_MASK 0x0000ff
+#include "template_acc_24.h"
+
 /* ARGB1666 */
 #define EXPAND_Ato8( a ) EXPAND_1to8( a )
 #define EXPAND_Rto8( r ) EXPAND_6to8( r )
@@ -516,6 +534,7 @@ static const bool is_ycbcr[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = false,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = true,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = true,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = true,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = false,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = false,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = false,
@@ -538,11 +557,21 @@ static const bool is_ycbcr[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = true,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = false,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = true,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = false,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = false,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = true,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = true,
 };
 
 
 /********************************* Cop_to_Aop_PFI *****************************/
 
+static void Cop_to_Aop_4( GenefxState *gfxs )
+{
+     u8 color = ((gfxs->Cop & 0xf) << 4) | (gfxs->Cop & 0xf);
+     memset( gfxs->Aop[0], color, gfxs->length >> 1 );
+}
+
 static void Cop_to_Aop_8( GenefxState *gfxs )
 {
      memset( gfxs->Aop[0], gfxs->Cop, gfxs->length );
@@ -753,6 +782,18 @@ static void Cop_to_Aop_nv12( GenefxState *gfxs )
      }
 }
 
+static void Cop_to_Aop_nv24( GenefxState *gfxs )
+{
+     u16   *D   = gfxs->Aop[1];
+     int    w   = gfxs->length + 1;
+     u16    Cop = gfxs->CbCop | (gfxs->CrCop << 8);
+
+     memset( gfxs->Aop[0], gfxs->YCop, gfxs->length );
+
+     while (--w)
+          *D++ = Cop;
+}
+
 static void Cop_to_Aop_nv21( GenefxState *gfxs )
 {
      memset( gfxs->Aop[0], gfxs->YCop, gfxs->length );
@@ -768,6 +809,14 @@ static void Cop_to_Aop_nv21( GenefxState *gfxs )
      }
 }
 
+static void Cop_to_Aop_nv12mb( GenefxState *gfxs )
+{
+     int y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+
+     dfb_write_nv1xmb_span( NULL, gfxs->YCop, (u8**) gfxs->Aop,
+                            gfxs->length, gfxs->AopY - y0 );
+}
+
 static void Cop_to_Aop_yuv444p( GenefxState *gfxs )
 {
      memset( gfxs->Aop[0], gfxs->YCop, gfxs->length );
@@ -794,6 +843,7 @@ static GenefxFunc Cop_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Cop_to_Aop_nv12,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Cop_to_Aop_nv12,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Cop_to_Aop_nv24,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Cop_to_Aop_16,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Cop_to_Aop_16,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Cop_to_Aop_16,
@@ -816,10 +866,36 @@ static GenefxFunc Cop_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Cop_to_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Cop_to_Aop_yv16,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Cop_to_Aop_4,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Cop_to_Aop_24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Cop_to_Aop_nv12mb,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Cop_to_Aop_nv12mb,
 };
 
 /********************************* Cop_toK_Aop_PFI ****************************/
 
+static void Cop_toK_Aop_4( GenefxState *gfxs )
+{
+     int    w    = (gfxs->length >> 1) + 1;
+     u8    *D    = gfxs->Aop[0];
+     u32    Cop  = gfxs->Cop;
+     u32    Dkey = gfxs->Dkey;
+     u8     pixel;
+
+     while (--w) {
+          pixel = *D;
+
+          if (Dkey == (*D & 0x0F))
+               pixel = Cop;
+          if (Dkey == (*D >> 4)) {
+               pixel &= 0x0F;
+               pixel |= (Cop << 4);
+          }
+
+          *D++ = pixel;
+     }
+}
+
 static void Cop_toK_Aop_8( GenefxState *gfxs )
 {
      int    w    = gfxs->length+1;
@@ -945,6 +1021,7 @@ static const GenefxFunc Cop_toK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Cop_toK_Aop_14,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Cop_toK_Aop_12,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Cop_toK_Aop_12vv,
@@ -967,6 +1044,10 @@ static const GenefxFunc Cop_toK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Cop_toK_Aop_24_24,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Cop_toK_Aop_4,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Cop_toK_Aop_24_24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_to_Aop_PFI *************************/
@@ -1019,6 +1100,17 @@ static void Bop_NV_to_Aop( GenefxState *gfxs )
           direct_memmove( gfxs->Aop[1], gfxs->Bop[1], gfxs->length&~1 );
 }
 
+static void Bop_NV24_to_Aop( GenefxState *gfxs )
+{
+     direct_memmove( gfxs->Aop[0], gfxs->Bop[0], gfxs->length );
+     direct_memmove( gfxs->Aop[1], gfxs->Bop[1], gfxs->length * 2 );
+}
+
+static void Bop_nv12mb_to_Aop( GenefxState *gfxs )
+{
+     direct_memmove( gfxs->Aop[0], gfxs->Bop[0], gfxs->length );
+}
+
 static void Bop_yuv444p_to_Aop( GenefxState *gfxs )
 {
      direct_memmove( gfxs->Aop[0], gfxs->Bop[0], gfxs->length );
@@ -1045,6 +1137,7 @@ static const GenefxFunc Bop_PFI_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Bop_NV_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Bop_NV_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Bop_NV24_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_16_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_16_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_16_to_Aop,
@@ -1067,6 +1160,10 @@ static const GenefxFunc Bop_PFI_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Bop_yv16_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Bop_4_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Bop_nv12mb_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Bop_nv12mb_to_Aop,
 };
 
 /********************************* Bop_PFI_toR_Aop_PFI *************************/
@@ -1200,6 +1297,22 @@ static void Bop_NV_toR_Aop( GenefxState *gfxs )
      }
 }
 
+static void Bop_NV24_toR_Aop( GenefxState *gfxs )
+{
+     int w = gfxs->length + 1;
+     int Dstep = gfxs->Astep;
+     u16 * S = gfxs->Bop[1];
+     u16 * D = gfxs->Aop[1];
+
+     Bop_8_toR_Aop( gfxs );
+
+     while(--w)
+     {
+          *D = *S++;
+          D += Dstep;
+     }
+}
+
 static void Bop_yuv444p_toR_Aop( GenefxState *gfxs )
 {
      int       w     = gfxs->length + 1;
@@ -1246,6 +1359,7 @@ static const GenefxFunc Bop_PFI_toR_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Bop_NV_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Bop_NV_toR_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Bop_NV24_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_16_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_16_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_16_toR_Aop,
@@ -1268,10 +1382,20 @@ static const GenefxFunc Bop_PFI_toR_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Bop_yv16_toR_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Bop_4_toR_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_toR_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_Kto_Aop_PFI ************************/
 
+static void Bop_lut4_Kto_Aop( GenefxState *gfxs )
+{
+     /* no color to key */
+     direct_memmove( gfxs->Aop[0], gfxs->Bop[0], gfxs->length >> 1 );
+}
+
 static void Bop_a8_Kto_Aop( GenefxState *gfxs )
 {
      /* no color to key */
@@ -1444,6 +1568,7 @@ static GenefxFunc Bop_PFI_Kto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_Kto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_Kto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_Kto_Aop,
@@ -1466,6 +1591,10 @@ static GenefxFunc Bop_PFI_Kto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_Kto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Bop_lut4_Kto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_Kto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_toK_Aop_PFI ************************/
@@ -1567,6 +1696,29 @@ static void Bop_yuv444p_toK_Aop( GenefxState *gfxs )
      }
 }
 
+static void Bop_4_toK_Aop( GenefxState *gfxs )
+{
+      int   w    = (gfxs->length >> 1) + 1;
+      u8   *D    = gfxs->Aop[0];
+      u8   *S    = gfxs->Bop[0];
+      u8    Dkey = gfxs->Dkey;
+      u8    pixel;
+
+      while (--w) {
+           pixel = *D;
+
+           if (Dkey == (*D & 0x0F))
+                pixel = *S & 0xF;
+           if (Dkey == (*D >> 4)) {
+                pixel &= 0x0F;
+                pixel |= *S & 0xF0;
+           }
+
+           *D++ = pixel;
+           S++;
+      }
+}
+
 static void Bop_8_toK_Aop( GenefxState *gfxs )
 {
       int   w    = gfxs->length+1;
@@ -1602,6 +1754,7 @@ static GenefxFunc Bop_PFI_toK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_toK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_toK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_toK_Aop,
@@ -1624,6 +1777,10 @@ static GenefxFunc Bop_PFI_toK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_toK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Bop_4_toK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_toK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_KtoK_Aop_PFI ***********************/
@@ -1686,6 +1843,7 @@ static const GenefxFunc Bop_PFI_KtoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_KtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_KtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_KtoK_Aop,
@@ -1708,6 +1866,10 @@ static const GenefxFunc Bop_PFI_KtoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_KtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_KtoK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_Sto_Aop_PFI ************************/
@@ -1952,6 +2114,25 @@ static void Bop_NV_Sto_Aop( GenefxState *gfxs )
      }
 }
 
+static void Bop_NV24_Sto_Aop( GenefxState *gfxs )
+{
+     int   w     = gfxs->length + 1;
+     int   i     = gfxs->Xphase;
+     u8   *Dy    = gfxs->Aop[0];
+     u8   *Sy    = gfxs->Bop[0];
+     int   SperD = gfxs->SperD;
+
+     u16 *Duv = gfxs->Aop[1];
+     u16 *Suv = gfxs->Bop[1];
+
+     while (--w) {
+          *Dy++ = Sy[i>>16];
+          *Duv++ = Suv[i>>16];
+
+          i += SperD;
+     }
+}
+
 static void Bop_yuv444p_Sto_Aop( GenefxState *gfxs )
 {
      int       w         = gfxs->length + 1;
@@ -1996,6 +2177,7 @@ static GenefxFunc Bop_PFI_Sto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Bop_NV_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Bop_NV_Sto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Bop_NV24_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_16_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_16_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_16_Sto_Aop,
@@ -2018,6 +2200,10 @@ static GenefxFunc Bop_PFI_Sto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Bop_yv16_Sto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_Sto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_SKto_Aop_PFI ***********************/
@@ -2238,6 +2424,7 @@ static const GenefxFunc Bop_PFI_SKto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_SKto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_SKto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_SKto_Aop,
@@ -2260,6 +2447,10 @@ static const GenefxFunc Bop_PFI_SKto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_SKto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_SKto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_StoK_Aop_PFI ***********************/
@@ -2316,6 +2507,7 @@ static const GenefxFunc Bop_PFI_StoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_StoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_StoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_StoK_Aop,
@@ -2338,6 +2530,10 @@ static const GenefxFunc Bop_PFI_StoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_StoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_StoK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_SKtoK_Aop_PFI **********************/
@@ -2396,6 +2592,7 @@ static const GenefxFunc Bop_PFI_SKtoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_SKtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_SKtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_SKtoK_Aop,
@@ -2418,6 +2615,10 @@ static const GenefxFunc Bop_PFI_SKtoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_SKtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_SKtoK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_TEX_to_Aop_PFI ************************/
@@ -2519,6 +2720,7 @@ static GenefxFunc Bop_PFI_TEX_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,//Bop_NV_TEX_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,//Bop_NV_TEX_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,//Bop_16_TEX_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,//Bop_16_TEX_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,//Bop_16_TEX_to_Aop,
@@ -2541,6 +2743,10 @@ static GenefxFunc Bop_PFI_TEX_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_TEX_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,//Bop_yv16_TEX_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_TEX_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sop_PFI_Sto_Dacc ***************************/
@@ -2761,6 +2967,28 @@ static void Sop_nv12_Sto_Dacc( GenefxState *gfxs )
      }
 }
 
+static void Sop_nv24_Sto_Dacc( GenefxState *gfxs )
+{
+     int w     = gfxs->length+1;
+     int i     = gfxs->Xphase;
+     int SperD = gfxs->SperD;
+
+     GenefxAccumulator *D   = gfxs->Dacc;
+     u8                *Sy  = gfxs->Sop[0];
+     u16               *Suv = gfxs->Sop[1];
+
+     while (--w) {
+          D->YUV.a = 0xFF;
+          D->YUV.y = Sy[i>>16];
+          D->YUV.u = Suv[i>>16] & 0xFF;
+          D->YUV.v = Suv[i>>16] >> 8;
+
+          i += SperD;
+
+          ++D;
+     }
+}
+
 static void Sop_nv21_Sto_Dacc( GenefxState *gfxs )
 {
      int w     = gfxs->length+1;
@@ -2929,6 +3157,7 @@ static GenefxFunc Sop_PFI_Sto_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Sop_nv12_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Sop_nv12_Sto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Sop_nv24_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_Sto_Dacc,
@@ -2951,6 +3180,10 @@ static GenefxFunc Sop_PFI_Sto_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sop_vyu_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Sop_i420_Sto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_Sto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sop_PFI_SKto_Dacc **************************/
@@ -3320,6 +3553,7 @@ static const GenefxFunc Sop_PFI_SKto_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_SKto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_SKto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_SKto_Dacc,
@@ -3342,6 +3576,10 @@ static const GenefxFunc Sop_PFI_SKto_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sop_vyu_SKto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_SKto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sop_PFI_to_Dacc ****************************/
@@ -3472,6 +3710,33 @@ static void Sop_uyvy_to_Dacc( GenefxState *gfxs )
      }
 }
 
+static void Sop_lut4_to_Dacc( GenefxState *gfxs )
+{
+     int                w = (gfxs->length >> 1) + 1;
+     GenefxAccumulator *D = gfxs->Dacc;
+     u8                *S = gfxs->Sop[0];
+
+     DFBColor *entries = gfxs->Slut->entries;
+
+     while (--w) {
+          u8 s = *S++;
+
+          D->RGB.a = entries[s & 0xF].a;
+          D->RGB.r = entries[s & 0xF].r;
+          D->RGB.g = entries[s & 0xF].g;
+          D->RGB.b = entries[s & 0xF].b;
+
+          D++;
+
+          D->RGB.a = entries[s >> 4].a;
+          D->RGB.r = entries[s >> 4].r;
+          D->RGB.g = entries[s >> 4].g;
+          D->RGB.b = entries[s >> 4].b;
+
+          D++;
+     }
+}
+
 static void Sop_lut8_to_Dacc( GenefxState *gfxs )
 {
      int                w = gfxs->length+1;
@@ -3557,6 +3822,88 @@ static void Sop_nv12_to_Dacc( GenefxState *gfxs )
      }
 }
 
+static void Sop_nv24_to_Dacc( GenefxState *gfxs )
+{
+     int                w   = gfxs->length+1;
+     GenefxAccumulator *D   = gfxs->Dacc;
+     u8                *Sy  = gfxs->Sop[0];
+     u16               *Suv = gfxs->Sop[1];
+
+     while (--w) {
+          D[0].YUV.a = 0xFF;
+          D[0].YUV.y = *Sy++;
+          D[0].YUV.u = Suv[0] & 0xFF;
+          D[0].YUV.v = Suv[0] >> 8;
+
+          ++Suv;
+          D++;
+     }
+}
+
+static void Sop_nv12mb_to_Dacc( GenefxState *gfxs )
+{
+     int i, l, idx;
+     short dy;
+     u8 *d1, *dy1;
+     int y0;
+
+     GenefxAccumulator *D = gfxs->Dacc;
+
+     int y_offet_table[32] = {
+          8, 72, 136, 200, 0, 64, 128, 192, 24, 88, 152, 216, 16,
+          80, 144, 208, 40, 104, 168, 232, 32, 96, 160, 224, 56, 120,
+          184, 248, 48, 112, 176, 240
+     };
+
+     d1 = gfxs->Sop[0];
+
+     y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+
+     if (gfxs->Sop == gfxs->Aop)
+          dy = gfxs->AopY - y0;
+     else
+          dy = gfxs->BopY - y0;
+
+     idx = (dy % 16) * 2;
+     dy1 = d1 + y_offet_table[idx];
+
+     /* gfxs->length is assumed to be always even */
+     for (i = 0, l = 0; i < (gfxs->length - 1); i += 2)
+     {
+          if (l == 16) {
+               d1 += 2 * 256;
+
+               idx = (dy % 16) * 2;
+               dy1 = d1 + y_offet_table[idx];
+
+               l = 0;
+          }
+
+          if (l < 8) {
+               D[0].YUV.y = dy1[7 - l];
+               D[1].YUV.y = dy1[7 - (l + 1)];
+
+               D[0].YUV.u = D[1].YUV.u = 127;
+               D[0].YUV.v = D[1].YUV.v = 127;
+               D[0].YUV.a = D[1].YUV.a = 255;
+          } else {
+               if (l == 8) {
+                    dy1 = d1 + y_offet_table[++idx];
+               }
+
+               D[0].YUV.y = dy1[15 - l];
+               D[1].YUV.y = dy1[15 - (l + 1)];
+
+               D[0].YUV.u = D[1].YUV.u = 127;
+               D[0].YUV.v = D[1].YUV.v = 127;
+               D[0].YUV.a = D[1].YUV.a = 255;
+          }
+
+          l += 2;
+          D += 2;
+     }
+}
+
 static void Sop_nv21_to_Dacc( GenefxState *gfxs )
 {
      int                w   = (gfxs->length>>1)+1;
@@ -3676,6 +4023,7 @@ static GenefxFunc Sop_PFI_to_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Sop_nv12_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Sop_nv12_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Sop_nv24_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_to_Dacc,
@@ -3698,6 +4046,10 @@ static GenefxFunc Sop_PFI_to_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sop_vyu_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Sop_i420_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Sop_lut4_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Sop_nv12mb_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Sop_nv12mb_to_Dacc,
 };
 
 /********************************* Sop_PFI_Kto_Dacc ***************************/
@@ -4053,6 +4405,7 @@ static const GenefxFunc Sop_PFI_Kto_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_Kto_Dacc,
@@ -4075,6 +4428,10 @@ static const GenefxFunc Sop_PFI_Kto_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sop_vyu_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_Kto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sacc_to_Aop_PFI ****************************/
@@ -4230,6 +4587,35 @@ static void Sacc_to_Aop_uyvy( GenefxState *gfxs )
      }
 }
 
+static void Sacc_to_Aop_lut4( GenefxState *gfxs )
+{
+     int                w = (gfxs->length >> 1) + 1;
+     GenefxAccumulator *S = gfxs->Sacc;
+     u8                *D = gfxs->Aop[0];
+     u8                 pixel;
+
+     while (--w) {
+          pixel = 0;
+          if (!(S->RGB.a & 0xF000)) {
+               pixel = dfb_palette_search( gfxs->Alut,
+                                           (S->RGB.r & 0xFF00) ? 0xFF : S->RGB.r,
+                                           (S->RGB.g & 0xFF00) ? 0xFF : S->RGB.g,
+                                           (S->RGB.b & 0xFF00) ? 0xFF : S->RGB.b,
+                                           (S->RGB.a & 0xFF00) ? 0xFF : S->RGB.a );
+          }
+          S++;
+          if (!(S->RGB.a & 0xF000)) {
+               pixel |= (dfb_palette_search( gfxs->Alut,
+                                             (S->RGB.r & 0xFF00) ? 0xFF : S->RGB.r,
+                                             (S->RGB.g & 0xFF00) ? 0xFF : S->RGB.g,
+                                             (S->RGB.b & 0xFF00) ? 0xFF : S->RGB.b,
+                                             (S->RGB.a & 0xFF00) ? 0xFF : S->RGB.a )) << 4;
+          }
+          *D++ = pixel;
+          S++;
+     }
+}
+
 static void Sacc_to_Aop_lut8( GenefxState *gfxs )
 {
      int                w = gfxs->length+1;
@@ -4422,6 +4808,96 @@ static void Sacc_to_Aop_nv12( GenefxState *gfxs )
      }
 }
 
+static void Sacc_to_Aop_nv24( GenefxState *gfxs )
+{
+     int                w  = gfxs->length+1;
+     GenefxAccumulator *S  = gfxs->Sacc;
+     u8                *Dy = gfxs->Aop[0];
+     u16               *Duv = gfxs->Aop[1];
+
+     while (--w) {
+          if (!(S->YUV.a & 0xF000))
+               *Dy = (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y;
+
+          ++S;
+          ++Dy;
+     }
+
+     w = gfxs->length+1;
+     S = gfxs->Sacc;
+
+     while (--w) {
+          u32 cb, cr;
+
+          if (!(S[0].YUV.a & 0xF000)) {
+               cb = ((*Duv & 0xFF) + ((S[0].YUV.u & 0xFF00) ? 0xFF : S[0].YUV.u)) >> 1;
+               cr = ((*Duv >> 8)   + ((S[0].YUV.v & 0xFF00) ? 0xFF : S[0].YUV.v)) >> 1;
+               *Duv = cb | (cr << 8);
+          }
+
+          S++;
+          ++Duv;
+     }
+}
+
+static void Sacc_to_Aop_nv12mb( GenefxState *gfxs )
+{
+     int i, l, idx;
+     short dy;
+     u8 *d1, *dy1;
+     int y0;
+
+     GenefxAccumulator *src;
+
+     int y_offet_table[32] = {
+          8, 72, 136, 200, 0, 64, 128, 192, 24, 88, 152, 216, 16,
+          80, 144, 208, 40, 104, 168, 232, 32, 96, 160, 224, 56, 120,
+          184, 248, 48, 112, 176, 240
+     };
+
+     d1 = gfxs->Aop[0];
+
+     y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+     dy = gfxs->AopY - y0;
+
+     src = gfxs->Sacc;
+
+     idx = (dy % 16) * 2;
+     dy1 = d1 + y_offet_table[idx];
+
+     /* gfxs->length is assumed to be always even */
+     for (i = 0, l = 0; i < (gfxs->length - 1); i += 2)
+     {
+          int y0, y1;
+
+          if (l == 16) {
+               d1 += 2 * 256;
+
+               idx = (dy % 16) * 2;
+               dy1 = d1 + y_offet_table[idx];
+
+               l = 0;
+          }
+
+          y0 = src[i + 0].YUV.y;
+          y1 = src[i + 1].YUV.y;
+
+          if (l < 8) {
+               dy1[7 - l] = (y0 & 0xFF00) ? 0xFF : y0;
+               dy1[7 - (l + 1)] = (y1 & 0xFF00) ? 0xFF : y1;
+          } else {
+               if (l == 8) {
+                    dy1 = d1 + y_offet_table[++idx];
+               }
+
+               dy1[15 - l] = (y0 & 0xFF00) ? 0xFF : y0;
+               dy1[15 - (l + 1)] = (y1 & 0xFF00) ? 0xFF : y1;
+          }
+
+          l += 2;
+     }
+}
+
 static void Sacc_to_Aop_nv21( GenefxState *gfxs )
 {
      int                w  = gfxs->length+1;
@@ -4607,6 +5083,7 @@ static GenefxFunc Sacc_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Sacc_to_Aop_nv12,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Sacc_to_Aop_nv12,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Sacc_to_Aop_nv24,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sacc_to_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sacc_to_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sacc_to_Aop_rgba4444,
@@ -4629,6 +5106,10 @@ static GenefxFunc Sacc_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sacc_to_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Sacc_to_Aop_yv16,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Sacc_to_Aop_lut4,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sacc_to_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Sacc_to_Aop_nv12mb,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Sacc_to_Aop_nv12mb,
 };
 
 /********************************* Sop_PFI_TEX_to_Dacc ****************************/
@@ -4674,6 +5155,7 @@ static const GenefxFunc Sop_PFI_TEX_to_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_TEX_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_TEX_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_TEX_to_Dacc,
@@ -4696,6 +5178,10 @@ static const GenefxFunc Sop_PFI_TEX_to_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,//Sop_vyu_TEX_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_TEX_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sop_PFI_TEX_Kto_Dacc ****************************/
@@ -4720,6 +5206,7 @@ static const GenefxFunc Sop_PFI_TEX_Kto_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_TEX_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_TEX_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_TEX_Kto_Dacc,
@@ -4742,6 +5229,10 @@ static const GenefxFunc Sop_PFI_TEX_Kto_Dacc[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,//Sop_vyu_TEX_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_TEX_Kto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sacc_Sto_Aop_PFI ***************************/
@@ -5142,6 +5633,44 @@ static void Sacc_Sto_Aop_nv12( GenefxState *gfxs )
      }
 }
 
+static void Sacc_Sto_Aop_nv24( GenefxState *gfxs )
+{
+     int                i     = gfxs->Xphase;
+     int                w     = gfxs->length+1;
+     GenefxAccumulator *Sacc  = gfxs->Sacc;
+     u8                *Dy    = gfxs->Aop[0];
+     int                SperD = gfxs->SperD;
+
+     while (--w) {
+          GenefxAccumulator *S = &Sacc[i>>16];
+
+          if (!(S->YUV.a & 0xF000))
+               *Dy = (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y;
+
+          ++Dy;
+          i += SperD;
+     }
+
+     u16 *Duv = gfxs->Aop[1];
+
+     w = gfxs->length+1;
+     i = gfxs->Xphase;
+
+     while (--w) {
+          GenefxAccumulator *S0 = &Sacc[i>>16];
+          u32                cb, cr;
+
+          if (!(S0->YUV.a & 0xF000)) {
+               cb = ((*Duv & 0xFF) + ((S0->YUV.u & 0xFF00) ? 0xFF : S0->YUV.u)) >> 1;
+               cr = ((*Duv >> 8)   + ((S0->YUV.v & 0xFF00) ? 0xFF : S0->YUV.v)) >> 1;
+               *Duv = cb | (cr << 8);
+          }
+
+          ++Duv;
+          i += SperD;
+     }
+}
+
 static void Sacc_Sto_Aop_nv21( GenefxState *gfxs )
 {
      int                i     = gfxs->Xphase;
@@ -5201,6 +5730,69 @@ static void Sacc_Sto_Aop_nv21( GenefxState *gfxs )
      }
 }
 
+static void Sacc_Sto_Aop_nv12mb( GenefxState *gfxs )
+{
+     int i, l, idx;
+     short dy;
+     u8 *d1, *dy1;
+     int SperD, phase;
+     int y0;
+
+     GenefxAccumulator *src;
+
+     int y_offet_table[32] = {
+          8, 72, 136, 200, 0, 64, 128, 192, 24, 88, 152, 216, 16,
+          80, 144, 208, 40, 104, 168, 232, 32, 96, 160, 224, 56, 120,
+          184, 248, 48, 112, 176, 240
+     };
+
+     d1 = gfxs->Aop[0];
+
+     y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+     dy = gfxs->AopY - y0;
+
+     src = gfxs->Sacc;
+
+     SperD = gfxs->SperD;
+     phase = gfxs->Xphase;
+
+     idx = (dy % 16) * 2;
+     dy1 = d1 + y_offet_table[idx];
+
+     /* gfxs->length is assumed to be always even */
+     for (i = 0, l = 0; i < (gfxs->length - 1); i += 2)
+     {
+          int y0, y1;
+
+          if (l == 16) {
+               d1 += 2 * 256;
+
+               idx = (dy % 16) * 2;
+               dy1 = d1 + y_offet_table[idx];
+
+               l = 0;
+          }
+
+          y0 = src[(phase >> 16)].YUV.y;
+          y1 = src[(phase + SperD) >> 16].YUV.y;
+
+          if (l < 8) {
+               dy1[7 - l] = (y0 & 0xFF00) ? 0xFF : y0;
+               dy1[7 - (l + 1)] = (y1 & 0xFF00) ? 0xFF : y1;
+          } else {
+               if (l == 8) {
+                    dy1 = d1 + y_offet_table[++idx];
+               }
+
+               dy1[15 - l] = (y0 & 0xFF00) ? 0xFF : y0;
+               dy1[15 - (l + 1)] = (y1 & 0xFF00) ? 0xFF : y1;
+          }
+
+          l += 2;
+          phase += (2 * SperD);
+     }
+}
+
 static void Sacc_Sto_Aop_ayuv( GenefxState *gfxs )
 {
      int                w     = gfxs->length+1;
@@ -5323,6 +5915,7 @@ static GenefxFunc Sacc_Sto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Sacc_Sto_Aop_nv12,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Sacc_Sto_Aop_nv12,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Sacc_Sto_Aop_nv24,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sacc_Sto_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sacc_Sto_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sacc_Sto_Aop_rgba4444,
@@ -5345,6 +5938,10 @@ static GenefxFunc Sacc_Sto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sacc_Sto_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Sacc_Sto_Aop_yv16,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sacc_Sto_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Sacc_Sto_Aop_nv12mb,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Sacc_Sto_Aop_nv12mb,
 };
 
 /********************************* Sacc_toK_Aop_PFI ***************************/
@@ -5666,6 +6263,7 @@ static const GenefxFunc Sacc_toK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sacc_toK_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sacc_toK_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sacc_toK_Aop_rgba4444,
@@ -5688,6 +6286,10 @@ static const GenefxFunc Sacc_toK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sacc_toK_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sacc_toK_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sacc_StoK_Aop_PFI **************************/
@@ -5802,6 +6404,7 @@ static const GenefxFunc Sacc_StoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sacc_StoK_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sacc_StoK_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sacc_StoK_Aop_rgba4444,
@@ -5824,6 +6427,10 @@ static const GenefxFunc Sacc_StoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sacc_StoK_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sacc_StoK_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /************** Bop_a8_set_alphapixel_Aop_PFI *********************************/
@@ -6114,6 +6721,42 @@ static void Bop_a8_set_alphapixel_Aop_rgb24( GenefxState *gfxs )
 #undef SET_PIXEL
 }
 
+static void Bop_a8_set_alphapixel_Aop_bgr24( GenefxState *gfxs )
+{
+     int       w     = gfxs->length;
+     u8       *S     = gfxs->Bop[0];
+     u8       *D     = gfxs->Aop[0];
+     DFBColor  color = gfxs->color;
+
+#define SET_PIXEL(d,r,g,b,a)\
+     switch (a) {\
+         case 0xff:\
+               d[0] = r;\
+               d[1] = g;\
+               d[2] = b;\
+          case 0: break;\
+          default: {\
+               register u16 s = a+1;\
+               d[0] = ((r-d[0]) * s + (d[0] << 8)) >> 8;\
+               d[1] = ((g-d[1]) * s + (d[1] << 8)) >> 8;\
+               d[2] = ((b-d[2]) * s + (d[2] << 8)) >> 8;\
+          }\
+     }
+
+     while (w>4) {
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3; S++;
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3; S++;
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3; S++;
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3; S++;
+          w-=4;
+     }
+     while (w--) {
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3, S++;
+     }
+
+#undef SET_PIXEL
+}
+
 static void Bop_a8_set_alphapixel_Aop_rgb32( GenefxState *gfxs )
 {
      int    w   = gfxs->length;
@@ -6524,6 +7167,7 @@ static const GenefxFunc Bop_a8_set_alphapixel_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -6546,6 +7190,10 @@ static const GenefxFunc Bop_a8_set_alphapixel_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_a8_set_alphapixel_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_a8_set_alphapixel_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /************** Bop_a1_set_alphapixel_Aop_PFI *********************************/
@@ -6701,6 +7349,25 @@ static void Bop_a1_set_alphapixel_Aop_rgb24( GenefxState *gfxs )
      }
 }
 
+static void Bop_a1_set_alphapixel_Aop_bgr24( GenefxState *gfxs )
+{
+     int       i;
+     int       w     = gfxs->length;
+     u8       *S     = gfxs->Bop[0];
+     u8       *D     = gfxs->Aop[0];
+     DFBColor  color = gfxs->color;
+
+     for (i=0; i<w; i++) {
+          if (S[i>>3] & (0x80 >> (i&7))) {
+               D[0] = color.r;
+               D[1] = color.g;
+               D[2] = color.b;
+          }
+
+          D += 3;
+     }
+}
+
 static void Bop_a1_set_alphapixel_Aop_rgb32( GenefxState *gfxs )
 {
      int    i;
@@ -6909,6 +7576,7 @@ static const GenefxFunc Bop_a1_set_alphapixel_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_a1_set_alphapixel_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_a1_set_alphapixel_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_a1_set_alphapixel_Aop_rgba4444,
@@ -6931,6 +7599,10 @@ static const GenefxFunc Bop_a1_set_alphapixel_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_a1_set_alphapixel_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /************** Bop_a1_lsb_set_alphapixel_Aop_PFI *********************************/
@@ -7045,6 +7717,25 @@ static void Bop_a1_lsb_set_alphapixel_Aop_rgb24( GenefxState *gfxs )
      }
 }
 
+static void Bop_a1_lsb_set_alphapixel_Aop_bgr24( GenefxState *gfxs )
+{
+     int       i;
+     int       w     = gfxs->length;
+     u8       *S     = gfxs->Bop[0];
+     u8       *D     = gfxs->Aop[0];
+     DFBColor  color = gfxs->color;
+
+     for (i=0; i<w; i++) {
+          if (S[i>>3] & (1 << (i&7))) {
+               D[0] = color.r;
+               D[1] = color.g;
+               D[2] = color.b;
+          }
+
+          D += 3;
+     }
+}
+
 static void Bop_a1_lsb_set_alphapixel_Aop_rgb32( GenefxState *gfxs )
 {
      int    i;
@@ -7221,6 +7912,7 @@ static const GenefxFunc Bop_a1_lsb_set_alphapixel_Aop_PFI[DFB_NUM_PIXELFORMATS]
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_a1_lsb_set_alphapixel_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_a1_lsb_set_alphapixel_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -7243,6 +7935,10 @@ static const GenefxFunc Bop_a1_lsb_set_alphapixel_Aop_PFI[DFB_NUM_PIXELFORMATS]
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_a1_lsb_set_alphapixel_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /**************************** Bop_translate_to_Aop ****************************/
@@ -8282,6 +8978,7 @@ static const GenefxFunc Bop_argb_blend_alphachannel_src_invsrc_Aop_PFI[DFB_NUM_P
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -8304,6 +9001,10 @@ static const GenefxFunc Bop_argb_blend_alphachannel_src_invsrc_Aop_PFI[DFB_NUM_P
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /**********************************************************************************************************************/
@@ -8362,6 +9063,7 @@ static const GenefxFunc Bop_argb_blend_alphachannel_one_invsrc_Aop_PFI[DFB_NUM_P
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -8384,6 +9086,10 @@ static const GenefxFunc Bop_argb_blend_alphachannel_one_invsrc_Aop_PFI[DFB_NUM_P
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /**********************************************************************************************************************/
@@ -8447,6 +9153,7 @@ static const GenefxFunc Bop_argb_blend_alphachannel_one_invsrc_premultiply_Aop_P
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -8469,6 +9176,10 @@ static const GenefxFunc Bop_argb_blend_alphachannel_one_invsrc_premultiply_Aop_P
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /**********************************************************************************************************************/
@@ -8959,6 +9670,9 @@ gAcquireSetup( CardState *state, DFBAccelerationMask accel )
           case DSPF_NV12:
           case DSPF_NV21:
           case DSPF_NV16:
+          case DSPF_NV24:
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
                gfxs->dst_org[1] = gfxs->dst_org[0] + gfxs->dst_height * gfxs->dst_pitch;
                break;
           case DSPF_YUV444P:
@@ -9004,6 +9718,9 @@ gAcquireSetup( CardState *state, DFBAccelerationMask accel )
                case DSPF_NV12:
                case DSPF_NV21:
                case DSPF_NV16:
+               case DSPF_NV24:
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
                     gfxs->src_org[1] = gfxs->src_org[0] + gfxs->src_height * gfxs->src_pitch;
                     break;
                case DSPF_YUV444P:
@@ -9085,6 +9802,9 @@ gAcquireSetup( CardState *state, DFBAccelerationMask accel )
           case DSPF_RGB24:
                gfxs->Cop = PIXEL_RGB32( color.r, color.g, color.b );
                break;
+          case DSPF_BGR24:
+               gfxs->Cop = PIXEL_RGB32( color.b, color.g, color.r );
+               break;
           case DSPF_RGB32:
                gfxs->Cop = PIXEL_RGB32( color.r, color.g, color.b );
                break;
@@ -9131,6 +9851,9 @@ gAcquireSetup( CardState *state, DFBAccelerationMask accel )
           case DSPF_NV12:
           case DSPF_NV21:
           case DSPF_NV16:
+          case DSPF_NV24:
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
           case DSPF_YUV444P:
                RGB_TO_YCBCR( color.r, color.g, color.b,
                              gfxs->YCop, gfxs->CbCop, gfxs->CrCop );
@@ -9138,6 +9861,7 @@ gAcquireSetup( CardState *state, DFBAccelerationMask accel )
                break;
           case DSPF_LUT1:
           case DSPF_LUT2:
+          case DSPF_LUT4:
           case DSPF_LUT8:
                gfxs->Cop  = state->color_index;
                gfxs->Alut = destination->palette;
@@ -9199,6 +9923,7 @@ gAcquireSetup( CardState *state, DFBAccelerationMask accel )
           switch (gfxs->src_format) {
                case DSPF_LUT1:
                case DSPF_LUT2:
+               case DSPF_LUT4:
                case DSPF_LUT8:
                case DSPF_ALUT44:
                     gfxs->Blut = source->palette;
@@ -9213,6 +9938,7 @@ gAcquireSetup( CardState *state, DFBAccelerationMask accel )
                case DSPF_RGB16:
                case DSPF_RGB18:
                case DSPF_RGB24:
+               case DSPF_BGR24:
                case DSPF_RGB32:
                case DSPF_ARGB:
                case DSPF_ABGR:
@@ -9241,6 +9967,9 @@ gAcquireSetup( CardState *state, DFBAccelerationMask accel )
                case DSPF_NV12:
                case DSPF_NV21:
                case DSPF_NV16:
+               case DSPF_NV24:
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
                     if (simpld_blittingflags & DSBLIT_SRC_COLORKEY)
                          return false;
                case DSPF_YUY2:
diff --git a/src/gfx/generic/generic_stretch_blit.c b/src/gfx/generic/generic_stretch_blit.c
index d69cef7..49a5f3c 100644
--- a/src/gfx/generic/generic_stretch_blit.c
+++ b/src/gfx/generic/generic_stretch_blit.c
@@ -300,6 +300,11 @@ static const StretchFunctionTable *stretch_tables[DFB_NUM_PIXELFORMATS] = {
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
 };
 
 /**********************************************************************************************************************/
diff --git a/src/gfx/generic/generic_util.c b/src/gfx/generic/generic_util.c
index 2cb8294..0b14bca 100644
--- a/src/gfx/generic/generic_util.c
+++ b/src/gfx/generic/generic_util.c
@@ -110,7 +110,14 @@ void Genefx_Aop_xy( GenefxState *gfxs, int x, int y )
                case DSPF_NV16:
                     x &= ~1;
                     break;
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
+                    y &= ~31L;
+                    x &= ~31L;
+                    gfxs->AopY = y;
+                    break;
                case DSPF_YUV444P: /* nothing to adjust */
+               case DSPF_NV24:
                default:
                     break;
           }
@@ -125,6 +132,25 @@ void Genefx_Aop_xy( GenefxState *gfxs, int x, int y )
 
           gfxs->Aop[1] += y * pitch + x;
           gfxs->Aop[2] += y * pitch + x;
+
+          switch (gfxs->dst_format) {
+               /* overwrite Aop[] when dst_format is a DSPF_NV1xMB */
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
+                    gfxs->Aop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->dst_org[0],
+                                                         pitch, x, y, 0);
+                    /* we don't handle chroma yet */
+                    gfxs->Aop[1] = 0;
+                    /* orignal signed coordinates */
+                    gfxs->Aop[2] = (void*)(((y & 0xffff) << 16) | (x & 0xffff));
+                    break;
+               case DSPF_NV24:
+                    /* adjust again as chroma is fully sampled */
+                    gfxs->Aop[1] += y * pitch + x;
+                    break;
+               default:
+                    break;
+          }
      }
 }
 
@@ -219,6 +245,18 @@ void Genefx_Aop_next( GenefxState *gfxs )
                     gfxs->Aop[2] += pitch;
                }
           }
+          else if (gfxs->dst_format == DSPF_NV12MB
+                   || gfxs->dst_format == DSPF_NV16MB) {
+               int x0 = ((u32)gfxs->Aop[2] & 0xffff);
+               int y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+               gfxs->Aop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->dst_org[0], pitch,
+                                                    x0, (gfxs->AopY + 1),
+                                                    (gfxs->AopY + 1) - y0);
+               gfxs->Aop[1] = 0;
+          }
+          else if (gfxs->dst_format == DSPF_NV24) {
+               gfxs->Aop[1] += pitch * 2;
+          }
           else { /* NV16 */
                if (gfxs->dst_caps & DSCAPS_SEPARATED) {
                     if (gfxs->Aop_field & 1)
@@ -314,6 +352,18 @@ void Genefx_Aop_prev( GenefxState *gfxs )
                     gfxs->Aop[2] -= pitch;
                }
           }
+          else if (gfxs->dst_format == DSPF_NV12MB
+                   || gfxs->dst_format == DSPF_NV16MB) {
+               int x0 = ((u32)gfxs->Aop[2] & 0xffff);
+               int y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+               gfxs->Aop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->dst_org[0], pitch,
+                                                    x0, (gfxs->AopY - 1),
+                                                    (gfxs->AopY - 1) - y0);
+               gfxs->Aop[1] = 0;
+          }
+          else if (gfxs->dst_format == DSPF_NV24) {
+               gfxs->Aop[1] -= pitch * 2;
+          }
           else { /* NV16 */
                if (gfxs->dst_caps & DSCAPS_SEPARATED) {
                     if (gfxs->Aop_field & 1)
@@ -373,7 +423,14 @@ void Genefx_Bop_xy( GenefxState *gfxs, int x, int y )
                case DSPF_NV16:
                     x &= ~1;
                     break;
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
+                    y &= ~31L;
+                    x &= ~31L;
+                    gfxs->BopY = y;
+                    break;
                case DSPF_YUV444P: /* nothing to adjust */
+               case DSPF_NV24:
                default:
                     break;
           }
@@ -388,6 +445,25 @@ void Genefx_Bop_xy( GenefxState *gfxs, int x, int y )
 
           gfxs->Bop[1] += y * pitch + x;
           gfxs->Bop[2] += y * pitch + x;
+
+          switch (gfxs->src_format) {
+               /* overwrite Aop[] when dst_format is & DSPF_NV1xMB */
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
+                    gfxs->Bop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->src_org[0],
+                                                         pitch, x, y, 0);
+                    /* we don't handle chroma yet */
+                    gfxs->Bop[1] = 0;
+                    /* orignal signed coordinates */
+                    gfxs->Bop[2] = (void*)(((y & 0xffff) << 16) | (x & 0xffff));
+                    break;
+               case DSPF_NV24:
+                    /* adjust again as chroma is fully sampled */
+                    gfxs->Bop[1] += y * pitch + x;
+                    break;
+               default:
+                    break;
+          }
      }
 }
 
@@ -470,6 +546,18 @@ void Genefx_Bop_next( GenefxState *gfxs )
                     gfxs->Bop[2] += pitch;
                }
           }
+          else if (gfxs->src_format == DSPF_NV12MB
+                   || gfxs->src_format == DSPF_NV16MB) {
+               int x0 = ((u32)gfxs->Bop[2] & 0xffff);
+               int y0 = (short)(((u32)gfxs->Bop[2] >> 16) & 0xffff);
+               gfxs->Bop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->src_org[0], pitch,
+                                                    x0, (gfxs->BopY + 1),
+                                                    (gfxs->BopY + 1) - y0);
+               gfxs->Bop[1] = 0;
+          }
+          else if (gfxs->src_format == DSPF_NV24) {
+               gfxs->Bop[1] += pitch * 2;
+          }
           else { /* NV16 */
                if (gfxs->src_caps & DSCAPS_SEPARATED) {
                     if (gfxs->Bop_field & 1)
@@ -565,6 +653,18 @@ void Genefx_Bop_prev( GenefxState *gfxs )
                     gfxs->Bop[2] -= pitch;
                }
           }
+          else if (gfxs->src_format == DSPF_NV12MB
+                   || gfxs->src_format == DSPF_NV16MB) {
+               int x0 = ((u32)gfxs->Bop[2] & 0xffff);
+               int y0 = (short)(((u32)gfxs->Bop[2] >> 16) & 0xffff);
+               gfxs->Bop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->src_org[0], pitch,
+                                                    x0, (gfxs->BopY - 1),
+                                                    (gfxs->BopY - 1) - y0);
+               gfxs->Bop[1] = 0;
+          }
+          else if (gfxs->src_format == DSPF_NV24) {
+               gfxs->Bop[1] -= pitch * 2;
+          }
           else { /* NV16 */
                if (gfxs->src_caps & DSCAPS_SEPARATED) {
                     if (gfxs->Bop_field & 1)
diff --git a/src/idirectfb.c b/src/idirectfb.c
index 27af66b..df22588 100644
--- a/src/idirectfb.c
+++ b/src/idirectfb.c
@@ -370,7 +370,7 @@ IDirectFB_SetCooperativeLevel( IDirectFB           *thiz,
                if (dfb_config->primary_id)
                     return DFB_ACCESSDENIED;
 
-               if (dfb_config->force_windowed || dfb_config->force_desktop)
+               if (dfb_config->force_windowed || dfb_config->force_desktop || dfb_config->force_offscreen)
                     return DFB_ACCESSDENIED;
 
                if (data->level == DFSCL_NORMAL) {
@@ -668,11 +668,13 @@ IDirectFB_CreateSurface( IDirectFB                    *thiz,
           case DSPF_I420:
           case DSPF_LUT1:
           case DSPF_LUT2:
+          case DSPF_LUT4:
           case DSPF_LUT8:
           case DSPF_ALUT44:
           case DSPF_RGB16:
           case DSPF_RGB18:
           case DSPF_RGB24:
+          case DSPF_BGR24:
           case DSPF_RGB32:
           case DSPF_RGB332:
           case DSPF_UYVY:
@@ -688,6 +690,15 @@ IDirectFB_CreateSurface( IDirectFB                    *thiz,
           case DSPF_BGR555:
           case DSPF_RGBAF88871:
           case DSPF_YUV444P:
+          case DSPF_NV24:
+               break;
+
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               if ((width & 31L) || (height & 31L)
+                   || (caps & (DSCAPS_SEPARATED
+                               | DSCAPS_INTERLACED)))
+                    return DFB_INVARG;
                break;
 
           default:
@@ -696,7 +707,11 @@ IDirectFB_CreateSurface( IDirectFB                    *thiz,
      }
 
      if (caps & DSCAPS_PRIMARY) {
+          D_DEBUG_AT( IDFB, "  -> PRIMARY\n" );
+
           if (dfb_config->primary_id) {
+               D_DEBUG_AT( IDFB, "  -> primary-id 0x%x\n", dfb_config->primary_id );
+
                ret = CoreDFB_GetSurface( data->core, dfb_config->primary_id, &surface );
                if (ret)
                     return ret;
@@ -761,12 +776,20 @@ IDirectFB_CreateSurface( IDirectFB                    *thiz,
                     or should we return an error? */
           switch (data->level) {
                case DFSCL_NORMAL:
-                    if (dfb_config->force_desktop) {
+                    D_DEBUG_AT( IDFB, "  -> level normal\n" );
+
+                    if (dfb_config->force_desktop || dfb_config->force_offscreen) {
                          CoreSurface *surface;
 
                          /* Source compatibility with older programs */
-                         if ((caps & DSCAPS_FLIPPING) == DSCAPS_FLIPPING)
-                              caps &= ~DSCAPS_TRIPLE;
+                         if (dfb_config->force_desktop) {
+                              if ((caps & DSCAPS_FLIPPING) == DSCAPS_FLIPPING)
+                                   caps &= ~DSCAPS_TRIPLE;
+                         }
+                         else {
+                              if ((caps & DSCAPS_FLIPPING) == DSCAPS_FLIPPING)
+                                   caps &= ~DSCAPS_DOUBLE;
+                         }
 
                          ret = dfb_surface_create_simple( data->core,
                                                           width, height,
@@ -775,8 +798,9 @@ IDirectFB_CreateSurface( IDirectFB                    *thiz,
                                                           NULL, &surface );
                          if (ret)
                               return ret;
-
-                         surface->notifications |= CSNF_FLIP;
+                  
+                         if (dfb_config->force_desktop)
+                              surface->notifications |= CSNF_FLIP;    // FIXME
 
                          init_palette( surface, desc );
 
@@ -785,8 +809,12 @@ IDirectFB_CreateSurface( IDirectFB                    *thiz,
                          ret = IDirectFBSurface_Construct( iface, NULL,
                                                            NULL, NULL, NULL, surface, caps, data->core, thiz );
                          if (ret == DFB_OK) {
-                              CoreWindowStack_BackgroundSetImage( data->stack, surface );
-                              CoreWindowStack_BackgroundSetMode( data->stack, DLBM_IMAGE );
+                              if (dfb_config->force_desktop) {
+                                   CoreWindowStack_BackgroundSetImage( data->stack, surface );
+                                   CoreWindowStack_BackgroundSetMode( data->stack, DLBM_IMAGE );
+                              }
+
+                              D_INFO( "Primary Surface (offscreen) with ID 0x%x\n", surface->object.id );
                          }
 
                          dfb_surface_unref( surface );
@@ -905,7 +933,8 @@ IDirectFB_CreateSurface( IDirectFB                    *thiz,
                     //if ((caps & DSCAPS_FLIPPING) == DSCAPS_FLIPPING)
                     //     caps &= ~DSCAPS_TRIPLE;
 
-                    config.surface_caps = DSCAPS_NONE;
+                    if (!(config.flags & DLCONF_SURFACE_CAPS))
+                         config.surface_caps = DSCAPS_NONE;
 
                     if (caps & DSCAPS_PREMULTIPLIED) {
                           config.flags        |= DLCONF_SURFACE_CAPS;
diff --git a/src/media/idirectfbimageprovider.c b/src/media/idirectfbimageprovider.c
index 12997c8..3f85371 100644
--- a/src/media/idirectfbimageprovider.c
+++ b/src/media/idirectfbimageprovider.c
@@ -127,6 +127,16 @@ static DFBResult
 IDirectFBImageProvider_SetRenderFlags( IDirectFBImageProvider *thiz,
                                        DIRenderFlags           flags )
 {
+     if (flags == DIRENDER_NONE)
+          return DFB_OK;
+
+     return DFB_UNIMPLEMENTED;
+}
+
+static DFBResult
+IDirectFBImageProvider_Sync( IDirectFBImageProvider    *thiz,
+                             DFBImageProviderSyncFlags  flags )
+{
      return DFB_UNIMPLEMENTED;
 }
 
@@ -149,6 +159,7 @@ IDirectFBImageProvider_Construct( IDirectFBImageProvider *thiz )
      thiz->RenderTo              = IDirectFBImageProvider_RenderTo;
      thiz->SetRenderCallback     = IDirectFBImageProvider_SetRenderCallback;
      thiz->SetRenderFlags        = IDirectFBImageProvider_SetRenderFlags;
+     thiz->Sync                  = IDirectFBImageProvider_Sync;
      thiz->WriteBack             = IDirectFBImageProvider_WriteBack;
 }
      
diff --git a/src/misc/conf.c b/src/misc/conf.c
index 1ac3d22..cbb9362 100644
--- a/src/misc/conf.c
+++ b/src/misc/conf.c
@@ -107,6 +107,7 @@ static const char *config_usage_strings[]  = {
      "  [no-]surface-sentinel          Enable surface sentinels at the end of chunks in video memory\n"
      "  [no-]force-windowed            Primary surface always is a window\n"
      "  force-desktop                  Primary surface is the desktop background\n"
+     "  force-offscreen                Primary surface is created offscreen (DFBSurfaceID will be logged)\n"
      "  [no-]hardware                  Enable/disable hardware acceleration\n"
      "  [no-]software                  Enable/disable software fallbacks\n"
      "  [no-]software-warn             Show warnings when doing/dropping software operations\n"
@@ -872,6 +873,15 @@ DFBResult dfb_config_set( const char *name, const char *value )
      if (strcmp (name, "force-desktop" ) == 0) {
           dfb_config->force_desktop = true;
      } else
+     if (strcmp (name, "no-force-desktop" ) == 0) {
+          dfb_config->force_desktop = false;
+     } else
+     if (strcmp (name, "force-offscreen" ) == 0) {
+          dfb_config->force_offscreen = true;
+     } else
+     if (strcmp (name, "no-force-offscreen" ) == 0) {
+          dfb_config->force_offscreen = false;
+     } else
      if (strcmp (name, "hardware" ) == 0) {
           dfb_config->software_only = false;
      } else
diff --git a/src/misc/conf.h b/src/misc/conf.h
index 213dcc6..a9dab60 100644
--- a/src/misc/conf.h
+++ b/src/misc/conf.h
@@ -162,6 +162,8 @@ typedef struct
 
      bool      force_desktop;                     /* Desktop background is
                                                      the primary surface. */
+     bool      force_offscreen;                   /* Creates a new surface for
+                                                     the primary surface. */
 
      bool      linux_input_ir_only;               /* Ignore non-IR devices. */
 
diff --git a/src/misc/gfx_util.c b/src/misc/gfx_util.c
index ad7f0cc..5c7555c 100644
--- a/src/misc/gfx_util.c
+++ b/src/misc/gfx_util.c
@@ -77,6 +77,68 @@ struct _PixopsFilter {
 };
 
 
+/* Only write to the 4:2:x Omega2 MB buffer's luma channel */
+void dfb_write_nv1xmb_span( u32 *src, u8 color, u8 *dst[], int len, int dy )
+{
+     int  i, l, idx;
+     u8  *d1, *dy1;
+
+     static const int y_offet_table[32] = {
+            8,  72, 136, 200,   0,  64, 128, 192,  24,  88,
+          152, 216,  16,  80, 144, 208,  40, 104, 168, 232,
+           32,  96, 160, 224,  56, 120, 184, 248,  48, 112,
+          176, 240
+     };
+
+     d1 = dst[0];
+
+     idx = (dy % 16) * 2;
+     dy1 = d1 + y_offet_table[idx];
+
+     /* len is assumed to be always even */
+     for (i = 0, l = 0; i < (len - 1); i += 2) {
+          u32 y0, u0, v0;
+          u32 y1, u1, v1;
+
+          if (l == 16) {
+               d1 += 2 * 256;
+
+               idx = (dy % 16) * 2;
+               dy1 = d1 + y_offet_table[idx];
+
+               l = 0;
+          }
+
+          if (src) {
+               RGB_TO_YCBCR( (src[i + 0] >> 16) & 0xff,
+                             (src[i + 0] >>  8) & 0xff,
+                             (src[i + 0]      ) & 0xff, y0, u0, v0 );
+               RGB_TO_YCBCR( (src[i + 1] >> 16) & 0xff,
+                             (src[i + 1] >>  8) & 0xff,
+                             (src[i + 1]      ) & 0xff, y1, u1, v1 );
+               /* we currently only handle luma */
+               (void) u0;
+               (void) v0;
+               (void) u1;
+               (void) v1;
+          } else
+               y0 = y1 = color;
+
+          if (l < 8) {
+               dy1[7 - l] = y0;
+               dy1[7 - (l + 1)] = y1;
+          } else {
+               if (l == 8)
+                    dy1 = d1 + y_offet_table[++idx];
+
+               dy1[15 - l] = y0;
+               dy1[15 - (l + 1)] = y1;
+          }
+
+          l += 2;
+     }
+}
+
 static void write_argb_span (u32 *src, u8 *dst[], int len,
                              int dx, int dy, CoreSurface *dst_surface,
                              bool premultiply)
@@ -264,6 +326,20 @@ static void write_argb_span (u32 *src, u8 *dst[], int len,
                }
                break;
 
+          case DSPF_BGR24:
+               for (i = 0; i < len; i++) {
+#ifdef WORDS_BIGENDIAN
+                    *d++ = src[i];
+                    *d++ = src[i] >> 8;
+                    *d++ = src[i] >> 16;
+#else
+                    *d++ = src[i] >> 16;
+                    *d++ = src[i] >> 8;
+                    *d++ = src[i];
+#endif
+               }
+               break;
+
           case DSPF_RGB32:
           case DSPF_ARGB:
                direct_memcpy( d, src, len*4 );
@@ -279,6 +355,25 @@ static void write_argb_span (u32 *src, u8 *dst[], int len,
                     ((u32*)d)[i] = src[i] ^ 0xff000000;
                break;
 
+          case DSPF_LUT4:
+               if (palette) {
+                    for (i = 0; i < len; i += 2) {
+                         u8 pixel = 0;
+                         pixel = dfb_palette_search( palette,
+                                                     (src[i] >> 16) & 0xff,
+                                                     (src[i] >>  8) & 0xff,
+                                                     (src[i]      ) & 0xff,
+                                                     (src[i] >> 24) & 0xff );
+                         pixel |= (dfb_palette_search( palette,
+                                                       (src[i + 1] >> 16) & 0xff,
+                                                       (src[i + 1] >>  8) & 0xff,
+                                                       (src[i + 1]      ) & 0xff,
+                                                       (src[i + 1] >> 24) & 0xff )) << 4;
+                         d[i] = pixel;
+                    }
+               }
+               break;
+
           case DSPF_LUT8:
                if (palette) {
                     for (i = 0; i < len; i++) {
@@ -524,6 +619,26 @@ static void write_argb_span (u32 *src, u8 *dst[], int len,
                }
                break;
 
+          case DSPF_NV24:
+               d1 = dst[1];
+               for (i = 0; i < len; i++) {
+                    u32 y0, u0, v0;
+
+                    RGB_TO_YCBCR( (src[i+0] >> 16) & 0xff,
+                                  (src[i+0] >>  8) & 0xff,
+                                  (src[i+0]      ) & 0xff, y0, u0, v0 );
+
+                    d[i + 0]      = y0;
+                    d1[2 * i + 0] = u0;
+                    d1[2 * i + 1] = v0;
+               }
+               break;
+
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               dfb_write_nv1xmb_span( src, 0, dst, len, dy );
+               break;
+
           case DSPF_NV21:
                d1 = dst[1];
                for (i = 0; i < (len-1); i += 2) {
@@ -724,6 +839,34 @@ void dfb_copy_buffer_32( u32 *src,
                }
                break;
 
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               dst1 = dst + dpitch * dst_surface->config.size.h;
+
+               if ((x & 31L) || (drect->y & 31L)
+                   || (drect->h & 31L) || (drect->w & 15L)) {
+                    D_WARN ("nv1xmb copy not performed because of a non 32 pixels aligned offsets.");
+                    break;
+               }
+
+               /* Clear the chroma channel for 4:2:x Omega2 MB buffers */
+               if (dst_surface->config.format == DSPF_NV12MB)
+                    memset(dst1, 127, dpitch * (dst_surface->config.size.h >> 1));
+               if (dst_surface->config.format == DSPF_NV16MB)
+                    memset(dst1, 127, dpitch * dst_surface->config.size.h);
+
+               for (y = drect->y; y < drect->y + drect->h; y++) {
+                    u8 *d[2];
+
+                    d[0] = RASTER_TO_NV1xMB_ADDR( dst, dpitch, drect->x,
+                                                  y, y - drect->y );
+
+                    write_argb_span( src, d, drect->w, x, y - drect->y, dst_surface, true );
+
+                    src += sw;
+               }
+               break;
+
           case DSPF_NV16:
                dst1 = (u8*)dst + dpitch * dst_surface->config.size.h;
 
@@ -741,6 +884,23 @@ void dfb_copy_buffer_32( u32 *src,
                }
                break;
 
+          case DSPF_NV24:
+               dst1 = (u8*)dst + dpitch * dst_surface->config.size.h;
+
+               for (y = drect->y; y < drect->y + drect->h; y++) {
+                    u8 *d[2];
+
+                    d[0] = LINE_PTR( dst, dst_surface->config.caps, y,
+                                     dst_surface->config.size.h, dpitch ) + x;
+                    d[1] = LINE_PTR( dst1, dst_surface->config.caps, y,
+                                     dst_surface->config.size.h, dpitch * 2 ) + x * 2;
+
+                    write_argb_span( src, d, drect->w, x, y, dst_surface, true );
+
+                    src += sw;
+               }
+               break;
+
           case DSPF_YUV444P:
                dst1 = (u8*)dst  + dpitch * dst_surface->config.size.h;
                dst2 = dst1 + dpitch * dst_surface->config.size.h;
@@ -1026,8 +1186,11 @@ void dfb_scale_linear_32( u32 *src, int sw, int sh,
                dst1 = dst2 + dpitch/2 * dst_surface->config.size.h;
                break;
           case DSPF_NV12:
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
           case DSPF_NV21:
           case DSPF_NV16:
+          case DSPF_NV24:
                dst1 = (u8*)dst + dpitch * dst_surface->config.size.h;
                break;
           case DSPF_YUV444P:
@@ -1038,6 +1201,12 @@ void dfb_scale_linear_32( u32 *src, int sw, int sh,
                break;
      }
 
+     /* Clear the chroma channel for 4:2:x Omega2 MB buffers */
+     if (dst_surface->config.format == DSPF_NV12MB)
+          memset(dst1, 127, dpitch * (dst_surface->config.size.h >> 1));
+     if (dst_surface->config.format == DSPF_NV16MB)
+          memset(dst1, 127, dpitch * dst_surface->config.size.h);
+
      buf = (u32*) alloca( drect->w * 4 );
 
      for (i = drect->y; i < drect->y + drect->h; i++) {
@@ -1125,6 +1294,15 @@ void dfb_scale_linear_32( u32 *src, int sw, int sh,
                     d[1] = LINE_PTR( dst1, dst_surface->config.caps, i,
                                      dst_surface->config.size.h, dpitch ) + (drect->x&~1);
                     break;
+               case DSPF_NV24:
+                    d[1] = LINE_PTR( dst1, dst_surface->config.caps, i,
+                                     dst_surface->config.size.h, dpitch * 2 ) + (drect->x * 2);
+                    break;
+               case DSPF_NV16MB:
+               case DSPF_NV12MB:
+                    d[0] = RASTER_TO_NV1xMB_ADDR( dst, dpitch, drect->x,
+                                                  i, i - drect->y );
+                    break;
                case DSPF_YUV444P:
                     d[1] = LINE_PTR( dst1, dst_surface->config.caps, i,
                                      dst_surface->config.size.h, dpitch ) + drect->x;
@@ -1135,7 +1313,11 @@ void dfb_scale_linear_32( u32 *src, int sw, int sh,
                     break;
           }
 
-          write_argb_span( buf, d, drect->w, drect->x, i, dst_surface, false );
+          if ((dst_surface->config.format == DSPF_NV12MB)
+              || (dst_surface->config.format == DSPF_NV16MB))
+               write_argb_span( buf, d, drect->w, drect->x, i - drect->y, dst_surface, false );
+          else
+               write_argb_span( buf, d, drect->w, drect->x, i, dst_surface, false );
      }
 
      D_FREE(filter.weights);
diff --git a/src/misc/gfx_util.h b/src/misc/gfx_util.h
index 3e1796f..fa5403a 100644
--- a/src/misc/gfx_util.h
+++ b/src/misc/gfx_util.h
@@ -45,5 +45,11 @@ void dfb_scale_linear_32( u32 *src, int sw, int sh,
                           void *dst, int dpitch, DFBRectangle *drect,
                           CoreSurface *dst_surface, const DFBRegion *dst_clip );
 
+#define RASTER_TO_NV1xMB_ADDR( dst, pitch, dx, y, dy ) \
+     (dst + ((y / 32) * (pitch / 16) * 256 * 2) \
+          + (((dy / 16) & 1L) ? ((dx / 16) * 2 + 1) * 256 \
+                              : (dx / 16) * 2 * 256))
+
+void dfb_write_nv1xmb_span( u32 *src, u8 color, u8 *dst[], int len, int dy );
 
 #endif
diff --git a/src/misc/util.c b/src/misc/util.c
index a1e540f..5912343 100644
--- a/src/misc/util.c
+++ b/src/misc/util.c
@@ -472,6 +472,8 @@ dfb_pixelformat_for_depth( int depth )
                return DSPF_LUT1;
           case 2:
                return DSPF_LUT2;
+          case 4:
+               return DSPF_LUT4;
           case 8:
                return DSPF_LUT8;
           case 12:
diff --git a/systems/Makefile.am b/systems/Makefile.am
index e7d68bd..26f0adb 100644
--- a/systems/Makefile.am
+++ b/systems/Makefile.am
@@ -66,6 +66,18 @@ else
 VNC_DIR =
 endif
   
+if STMFBDEV_CORE
+STMFBDEV_DIR = stmfbdev
+else
+STMFBDEV_DIR =
+endif
+
+if WAYLAND_CORE
+WAYLAND_DIR = wayland
+else
+WAYLAND_DIR =
+endif
+
 
 SUBDIRS = \
 	android \
@@ -80,4 +92,6 @@ SUBDIRS = \
 	$(X11VDPAU_DIR) \
 	$(SDL_DIR) \
 	$(OSX_DIR) \
-	$(VNC_DIR)
+	$(VNC_DIR) \
+	$(STMFBDEV_DIR) \
+	$(WAYLAND_DIR)
diff --git a/systems/devmem/surfacemanager.c b/systems/devmem/surfacemanager.c
index cd78bfd..19ae916 100644
--- a/systems/devmem/surfacemanager.c
+++ b/systems/devmem/surfacemanager.c
@@ -285,7 +285,7 @@ DFBResult dfb_surfacemanager_displace( CoreDFB           *core,
           D_MAGIC_ASSERT( chunk, Chunk );
 
           allocation = chunk->allocation;
-          if (allocation) {
+          if (allocation && allocation->buffer) {
                CoreSurfaceBuffer *other;
                int                size, locks;
 
diff --git a/systems/egl/Makefile.am b/systems/egl/Makefile.am
index 7a19783..57663fa 100644
--- a/systems/egl/Makefile.am
+++ b/systems/egl/Makefile.am
@@ -6,7 +6,7 @@ INCLUDES = \
 	-I$(top_srcdir)/include		\
 	-I$(top_srcdir)/lib		\
 	-I$(top_srcdir)/src		\
-	$(EGL_CFLAGS)
+	$(EGL_CFLAGS) $(GLES2_CFLAGS)
 
 
 internalincludedir = $(INTERNALINCLUDEDIR)/egl
@@ -36,6 +36,6 @@ libdirectfb_egl_la_LIBADD = \
 	$(top_builddir)/lib/direct/libdirect.la \
 	$(top_builddir)/lib/fusion/libfusion.la \
 	$(top_builddir)/src/libdirectfb.la	\
-	$(EGL_LIBS)
+	$(EGL_LIBS) $(GLES2_LIBS)
 
 include $(top_srcdir)/rules/libobject.make
diff --git a/systems/egl/egl_surface_pool.c b/systems/egl/egl_surface_pool.c
index 422d838..a182144 100644
--- a/systems/egl/egl_surface_pool.c
+++ b/systems/egl/egl_surface_pool.c
@@ -40,6 +40,7 @@
 #include <direct/mem.h>
 
 #include <core/surface_pool.h>
+#include <core/palette.h>
 
 #include <gfx/convert.h>
 
@@ -125,7 +126,7 @@ eglInitPool( CoreDFB                    *core,
      shared = egl->shared;
      D_ASSERT( shared != NULL );
 
-     ret_desc->caps                 = CSPCAPS_PHYSICAL | CSPCAPS_VIRTUAL;
+     ret_desc->caps                 = CSPCAPS_VIRTUAL;
 //     ret_desc->access[CSAID_CPU]    = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
      ret_desc->access[CSAID_GPU]    = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
      ret_desc->access[CSAID_LAYER0] = CSAF_READ | CSAF_SHARED;
@@ -246,6 +247,10 @@ eglTestConfig( CoreSurfacePool         *pool,
      if (surface->type & CSTF_LAYER)
           return DFB_OK;
 
+     /* can't convert YCbCr buffers to GL_RGBA textures */
+     if (DFB_COLOR_IS_YUV(config->format))
+          return DFB_UNSUPPORTED;
+
      ret = DFB_OK;//dfb_surfacemanager_allocate( local->core, data->manager, buffer, NULL, NULL );
 
      D_DEBUG_AT( EGL_Surfaces, "  -> %s\n", DirectFBErrorString(ret) );
@@ -575,6 +580,8 @@ eglWrite( CoreSurfacePool       *pool,
      EGLAllocationData *alloc = alloc_data;
      GLuint            *buff, *sline, *dline, *s, *d;
      GLuint             pixel, w, h, pixels_per_line;
+     unsigned char      *us, red, green, blue, alpha;
+     unsigned short     *ss;
 
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
@@ -631,6 +638,142 @@ eglWrite( CoreSurfacePool       *pool,
 
                glBindTexture( GL_TEXTURE_2D, tex );
                break;
+          case DSPF_RGB24:
+               glGetIntegerv( GL_TEXTURE_BINDING_2D, &tex );
+
+               glBindTexture( GL_TEXTURE_2D, alloc->texture );
+
+               buff = (GLuint *)D_MALLOC(rect->w * rect->h * 4);
+               if (!buff) {
+                    D_ERROR("EGL: failed to allocate %d bytes for texture upload!\n",
+                            rect->w * rect->h * 4);
+                    return D_OOM();
+               }
+
+               pixels_per_line = pitch/3;
+
+               sline = (GLuint *)source + rect->x + (rect->y * pixels_per_line);
+               dline = buff;
+
+               h = rect->h;
+               while (h--) {
+                    us = (unsigned char*)sline;
+                    d = dline;
+                    w = rect->w;
+                    while (w--) {
+                         blue = *us++;
+                         green = *us++;
+                         red = *us++;
+                         *d++ = 0xff000000 | (blue << 16) | (green << 8) | red;
+                    }
+                    sline = (unsigned char*)sline + pitch;
+                    dline += rect->w;
+               }
+
+               //if (rect->w == allocation->config.size.w && rect->h == allocation->config.size.h)
+               //     glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, allocation->config.size.w, allocation->config.size.h, 0, GL_RGBA, GL_UNSIGNED_BYTE, source );
+               //else
+                    glTexSubImage2D( GL_TEXTURE_2D, 0, rect->x, rect->y, rect->w, rect->h, GL_RGBA, GL_UNSIGNED_BYTE, buff );
+                    D_FREE(buff);
+               if ((err = glGetError()) != 0) {
+                    D_ERROR( "DirectFB/EGL: glTexSubImage2D() failed! (error = %x)\n", err );
+                    //return DFB_FAILURE;
+               }
+
+               glBindTexture( GL_TEXTURE_2D, tex );
+               break;
+          case DSPF_LUT8:
+               glGetIntegerv( GL_TEXTURE_BINDING_2D, &tex );
+
+               glBindTexture( GL_TEXTURE_2D, alloc->texture );
+
+               buff = (GLuint *)D_MALLOC(rect->w * rect->h * 4);
+               if (!buff) {
+                    D_ERROR("EGL: failed to allocate %d bytes for texture upload!\n",
+                            rect->w * rect->h * 4);
+                    return D_OOM();
+               }
+
+               pixels_per_line = pitch;
+
+               sline = (GLuint *)source + rect->x + (rect->y * pixels_per_line);
+               dline = buff;
+
+               h = rect->h;
+               while (h--) {
+                    us = (unsigned char*)sline;
+                    d = dline;
+                    w = rect->w;
+                    while (w--) {
+                         int index = *us++;
+                         CorePalette *palette = allocation->surface->palette;
+                         red = palette->entries[index].r;
+                         green = palette->entries[index].g;
+                         blue = palette->entries[index].b;
+                         alpha = palette->entries[index].a;
+                         *d++ = (alpha << 24) | (blue << 16) | (green << 8) | red;
+                    }
+                    sline = (unsigned char*)sline + pitch;
+                    dline += rect->w;
+               }
+
+               //if (rect->w == allocation->config.size.w && rect->h == allocation->config.size.h)
+               //     glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, allocation->config.size.w, allocation->config.size.h, 0, GL_RGBA, GL_UNSIGNED_BYTE, source );
+               //else
+                    glTexSubImage2D( GL_TEXTURE_2D, 0, rect->x, rect->y, rect->w, rect->h, GL_RGBA, GL_UNSIGNED_BYTE, buff );
+                    D_FREE(buff);
+               if ((err = glGetError()) != 0) {
+                    D_ERROR( "DirectFB/EGL: glTexSubImage2D() failed! (error = %x)\n", err );
+                    //return DFB_FAILURE;
+               }
+
+               glBindTexture( GL_TEXTURE_2D, tex );
+               break;
+          case DSPF_RGB16:
+               glGetIntegerv( GL_TEXTURE_BINDING_2D, &tex );
+
+               glBindTexture( GL_TEXTURE_2D, alloc->texture );
+
+               buff = (GLuint *)D_MALLOC(rect->w * rect->h * 4);
+               if (!buff) {
+                    D_ERROR("EGL: failed to allocate %d bytes for texture upload!\n",
+                            rect->w * rect->h * 4);
+                    return D_OOM();
+               }
+
+               pixels_per_line = pitch/2;
+
+               sline = (GLuint *)source + rect->x + (rect->y * pixels_per_line);
+               dline = buff;
+
+               h = rect->h;
+               while (h--) {
+                    ss = (unsigned short*)sline;
+                    d = dline;
+                    w = rect->w;
+                    while (w--) {
+                         unsigned short pixel = *ss++;
+                         blue = (pixel & 0x1f) << 3;
+                         green = (pixel & 0x7e0) >> 3;
+                         red = (pixel & 0xf800) >> 8;
+                         *d++ = 0xff000000 | (blue << 16) | (green << 8) | red;
+                    }
+                    sline = (unsigned char*)sline + pitch;
+                    dline += rect->w;
+               }
+
+               //if (rect->w == allocation->config.size.w && rect->h == allocation->config.size.h)
+               //     glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, allocation->config.size.w, allocation->config.size.h, 0, GL_RGBA, GL_UNSIGNED_BYTE, source );
+               //else
+                    glTexSubImage2D( GL_TEXTURE_2D, 0, rect->x, rect->y, rect->w, rect->h, GL_RGBA, GL_UNSIGNED_BYTE, buff );
+                    D_FREE(buff);
+               if ((err = glGetError()) != 0) {
+                    D_ERROR( "DirectFB/EGL: glTexSubImage2D() failed! (error = %x)\n", err );
+                    //return DFB_FAILURE;
+               }
+
+               glBindTexture( GL_TEXTURE_2D, tex );
+               break;
           default:
                break;
      }
@@ -657,8 +800,8 @@ fboRead( CoreSurfacePool       *pool,
      D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
      D_MAGIC_ASSERT( alloc, EGLAllocationData );
 
-     D_INFO( "%s( %p, %dx%d, type 0x%08x )\n", __FUNCTION__, allocation->buffer, allocation->config.size.w, allocation->config.size.h,
-             allocation->type );
+//     D_INFO( "%s( %p, %dx%d, type 0x%08x )\n", __FUNCTION__, allocation->buffer, allocation->config.size.w, allocation->config.size.h,
+//             allocation->type );
 
      D_DEBUG_AT( EGL_SurfLock, "%s( %p )\n", __FUNCTION__, allocation->buffer );
 
@@ -690,6 +833,7 @@ fboRead( CoreSurfacePool       *pool,
      sline = buff;
      dline = (GLuint *)destination;// + rect->x + (rect->y * pixels_per_line);
 
+     /* TODO: support for more RGB formats? */
      h = rect->h;
      while (h--) {
           s = sline;
@@ -792,7 +936,7 @@ static const SurfacePoolFuncs _eglSurfacePoolFuncs = {
      Unlock:             eglUnlock,
 
      Read:               fboRead,
-     Write:              fboWrite,
+     Write:              eglWrite,
 };
 
 const SurfacePoolFuncs *eglSurfacePoolFuncs = &_eglSurfacePoolFuncs;
diff --git a/systems/egl/egl_system.c b/systems/egl/egl_system.c
index dfaa305..22bac07 100644
--- a/systems/egl/egl_system.c
+++ b/systems/egl/egl_system.c
@@ -53,7 +53,7 @@
 
 #include <core/core_system.h>
 
-#define RASPBERRY_PI
+#undef RASPBERRY_PI
 
 DFB_CORE_SYSTEM( egl )
 
@@ -81,7 +81,7 @@ InitEGL( EGLData *egl )
 
      bcm_host_init();
 
-#endif     
+#endif
      egl->eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
 
      if (!eglInitialize(egl->eglDisplay, &iMajorVersion, &iMinorVersion))
@@ -146,9 +146,10 @@ InitEGL( EGLData *egl )
      nativewindow.height  = egl->DisplayHeight;
      vc_dispmanx_update_submit_sync( dispman_update );
 
-#endif
-
      egl->eglSurface = eglCreateWindowSurface( egl->eglDisplay, egl->eglConfig, &nativewindow, NULL );
+#else
+     egl->eglSurface = eglCreateWindowSurface( egl->eglDisplay, egl->eglConfig, NULL, NULL );
+#endif
      if (!TestEGLError("eglCreateWindowSurface"))
           return DFB_INIT;
 
diff --git a/systems/fbdev/Makefile.am b/systems/fbdev/Makefile.am
index 2911ad8..5aa8c7b 100644
--- a/systems/fbdev/Makefile.am
+++ b/systems/fbdev/Makefile.am
@@ -38,6 +38,12 @@ libdirectfb_fbdev_la_SOURCES = \
 	surfacemanager.c	\
 	vt.c
 
+
+if STMFB_H
+internalinclude_HEADERS += fbdev_aux_surface_pool.h
+libdirectfb_fbdev_la_SOURCES += fbdev_aux_surface_pool.c
+endif
+
 libdirectfb_fbdev_la_LIBADD = \
 	$(top_builddir)/lib/direct/libdirect.la \
 	$(top_builddir)/lib/fusion/libfusion.la \
diff --git a/systems/fbdev/fbdev.c b/systems/fbdev/fbdev.c
index aee785b..dc9cb5b 100644
--- a/systems/fbdev/fbdev.c
+++ b/systems/fbdev/fbdev.c
@@ -98,6 +98,10 @@
 
 #include <core/core_system.h>
 
+#if HAVE_STMFB_H
+#include "fbdev_aux_surface_pool.h"
+#endif
+
 DFB_CORE_SYSTEM( fbdev )
 
 
@@ -607,6 +611,10 @@ system_initialize( CoreDFB *core, void **data )
 
      dfb_surface_pool_initialize( core, &fbdevSurfacePoolFuncs, &dfb_fbdev->shared->pool );
 
+#if HAVE_STMFB_H
+     fbdev_aux_surface_pools_init( core );
+#endif
+
      /* Register primary screen functions */
      screen = dfb_screens_register( NULL, NULL, &primaryScreenFuncs );
 
@@ -705,6 +713,10 @@ system_join( CoreDFB *core, void **data )
 
      dfb_surface_pool_join( core, dfb_fbdev->shared->pool, &fbdevSurfacePoolFuncs );
 
+#if HAVE_STMFB_H
+     fbdev_aux_surface_pools_join( core );
+#endif
+
      /* Register primary screen functions */
      screen = dfb_screens_register( NULL, NULL, &primaryScreenFuncs );
 
@@ -765,7 +777,12 @@ system_shutdown( bool emergency )
 
      dfb_agp_shutdown();
 
-     dfb_surface_pool_destroy( dfb_fbdev->shared->pool );
+     if (dfb_fbdev->shared->pool)
+          dfb_surface_pool_destroy( dfb_fbdev->shared->pool );
+
+#if HAVE_STMFB_H
+     fbdev_aux_surface_pools_destroy( dfb_fbdev->core );
+#endif
 
      munmap( dfb_fbdev->framebuffer_base, shared->fix.smem_len );
 
@@ -793,6 +810,10 @@ system_leave( bool emergency )
 
      dfb_agp_leave();
 
+#if HAVE_STMFB_H
+     fbdev_aux_surface_pools_leave( dfb_fbdev->core );
+#endif
+
      dfb_surface_pool_leave( dfb_fbdev->shared->pool );
 
      munmap( dfb_fbdev->framebuffer_base,
diff --git a/systems/fbdev/fbdev.h b/systems/fbdev/fbdev.h
index 9cc66e4..b12aada 100644
--- a/systems/fbdev/fbdev.h
+++ b/systems/fbdev/fbdev.h
@@ -102,6 +102,10 @@ typedef struct {
      CoreLayerRegionConfig    config;
 
      SurfaceManager          *manager;
+
+     CoreSurfacePool         *aux_pools[5]; /* STMFBGP_GFX_LAST - STMFBGP_GFX_FIRST + 1 */
+     /* for exclusive use by fbdev_aux_surface_pool.c */
+     unsigned int             aux_pool_index;
 } FBDevShared;
 
 typedef struct {
diff --git a/systems/fbdev/fbdev_aux_surface_pool.c b/systems/fbdev/fbdev_aux_surface_pool.c
new file mode 100644
index 0000000..8f95cff
--- /dev/null
+++ b/systems/fbdev/fbdev_aux_surface_pool.c
@@ -0,0 +1,595 @@
+/*
+   FBDev system driver - auxmem surface pool memory
+
+   (c) Copyright 2009-2014  STMicroelectronics Ltd.
+
+   Based on code by André Draszik <andre.draszik@st.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <asm/types.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <directfb_util.h>
+
+#include <direct/debug.h>
+#include <direct/mem.h>
+
+#include <core/core.h>
+#include <core/surface_pool.h>
+
+#include <gfx/convert.h>
+
+#include <misc/conf.h>
+
+#include "surfacemanager.h"
+
+#include <core/system.h>
+
+#include "fbdev.h"
+#include "fbdev_aux_surface_pool.h"
+
+#include <linux/types.h>
+
+#include <linux/stmfb.h>
+
+extern FBDev *dfb_fbdev;
+
+D_DEBUG_DOMAIN (FBDev_Surfaces_Aux, "FBDev/Surfaces/Aux", "FBDev Aux Surface Pool");
+D_DEBUG_DOMAIN (FBDev_SurfLock_Aux, "FBDev/SurfLock/Aux", "FBDev Aux Surface Pool Locks");
+
+/****************************************************************************/
+
+typedef struct
+{
+  int             magic;
+
+  SurfaceManager *manager;
+
+  unsigned long   part_base;
+  unsigned int    aux_part;
+} STMFB_AuxSurfacePoolData;
+
+typedef struct
+{
+  int      magic;
+
+  CoreDFB *core;
+  void    *mem;
+} STMFB_AuxSurfacePoolLocalData;
+
+typedef struct
+{
+  int    magic;
+
+  Chunk *chunk;
+} STMFB_AuxSurfacePoolAllocationData;
+
+/****************************************************************************/
+
+static int
+fbdev_aux_PoolDataSize (void)
+{
+  return sizeof (STMFB_AuxSurfacePoolData);
+}
+
+static int
+fbdev_aux_PoolLocalDataSize (void)
+{
+  return sizeof (STMFB_AuxSurfacePoolLocalData);
+}
+
+static int
+fbdev_aux_AllocationDataSize (void)
+{
+  return sizeof (STMFB_AuxSurfacePoolAllocationData);
+}
+
+static DFBResult
+fbdev_aux_LeavePool (CoreSurfacePool *pool,
+                     void            *pool_data,
+                     void            *pool_local)
+{
+  STMFB_AuxSurfacePoolData      * const data = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d)\n", __func__, data->aux_part);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+
+  D_UNUSED_P (data);
+
+  if (local->mem && local->mem != MAP_FAILED)
+    {
+      munmap (local->mem, pool->desc.size);
+      local->mem = NULL;
+    }
+
+  D_MAGIC_CLEAR (local);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_JoinPool (CoreDFB         *core,
+                    CoreSurfacePool *pool,
+                    void            *pool_data,
+                    void            *pool_local,
+                    void            *system_data)
+{
+  STMFB_AuxSurfacePoolData      * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d)\n", __func__, data->aux_part);
+
+  D_ASSERT (core != NULL);
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_ASSERT (local != NULL);
+
+  D_MAGIC_SET (local, STMFB_AuxSurfacePoolLocalData);
+
+  local->mem = mmap (NULL, pool->desc.size, PROT_READ | PROT_WRITE,
+                     MAP_SHARED, dfb_fbdev->fd, data->part_base);
+  if (local->mem == MAP_FAILED)
+    {
+      D_PERROR ("STMfbdev/Surfaces/Aux: Could not mmap gfx part %d!\n",
+                data->aux_part);
+      return DFB_INIT;
+    }
+
+  local->core = core;
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_DestroyPool (CoreSurfacePool *pool,
+                       void            *pool_data,
+                       void            *pool_local)
+{
+  STMFB_AuxSurfacePoolData      * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d)\n", __func__, data->aux_part);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+
+  D_UNUSED_P (local);
+
+  fbdev_aux_LeavePool (pool, pool_data, pool_local);
+
+  dfb_surfacemanager_destroy (data->manager);
+
+  D_MAGIC_CLEAR (data);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_InitPool (CoreDFB                    *core,
+                    CoreSurfacePool            *pool,
+                    void                       *pool_data,
+                    void                       *pool_local,
+                    void                       *system_data,
+                    CoreSurfacePoolDescription *ret_desc)
+{
+  DFBResult                      ret;
+  STMFB_AuxSurfacePoolData      * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+  struct stmfbio_auxmem2         auxmem;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d)\n", __func__,
+              dfb_fbdev->shared->aux_pool_index);
+
+  D_ASSERT (core != NULL);
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_ASSERT (data != NULL);
+  D_ASSERT (local != NULL);
+  D_ASSERT (ret_desc != NULL);
+
+  D_UNUSED_P (local);
+
+  D_MAGIC_SET (data, STMFB_AuxSurfacePoolData);
+
+  auxmem.index = dfb_fbdev->shared->aux_pool_index;
+
+  snprintf (ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH,
+            "STMFB AuxMemory %d", auxmem.index);
+
+  /* query auxmem */
+  if (ioctl (dfb_fbdev->fd, STMFBIO_GET_AUXMEMORY2, &auxmem) != 0)
+    return DFB_IO;
+
+  if (!auxmem.size)
+    return DFB_ITEMNOTFOUND;
+
+  D_INFO ("FBDev/Surfaces/Aux: found auxmem @ %.8x (%ukB)!\n",
+          auxmem.physical, auxmem.size / 1024);
+  /* auxmem partitions will never cross a 64MB boundary, stmfb should make
+     sure that's the case. And it does in fact :-), which is why we don't need
+     to check for configuration errors. */
+
+  ret = dfb_surfacemanager_create (core, auxmem.size, &data->manager);
+  if (ret)
+    return ret;
+
+  data->aux_part  = auxmem.index;
+  data->part_base = auxmem.physical;
+
+  ret_desc->caps              = CSPCAPS_PHYSICAL | CSPCAPS_VIRTUAL;
+  ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+  ret_desc->access[CSAID_GPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+  ret_desc->types             = (0
+                                 | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT
+                                 | CSTF_SHARED | CSTF_EXTERNAL
+                                );
+  ret_desc->priority          = CSPP_DEFAULT;
+  ret_desc->size              = auxmem.size;
+
+  ret = fbdev_aux_JoinPool (core, pool, pool_data, pool_local, system_data);
+  if (ret)
+    {
+      fbdev_aux_DestroyPool (pool, pool_data, pool_local);
+      return ret;
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_TestConfig (CoreSurfacePool         *pool,
+                      void                    *pool_data,
+                      void                    *pool_local,
+                      CoreSurfaceBuffer       *buffer,
+                      const CoreSurfaceConfig *config)
+{
+  CoreSurface                   *surface;
+  STMFB_AuxSurfacePoolData      * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+  DFBResult                      ret;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_ASSERT (config != NULL);
+
+  surface = buffer->surface;
+  D_MAGIC_ASSERT (surface, CoreSurface);
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux,
+              "%s (part/buffer/type/id: %u/%p/0x%x/%lu)\n",
+              __func__, data->aux_part, buffer,
+              surface->type, surface->resource_id);
+
+  /* FIXME: this depends on the hardware, but we have no interface at the
+     moment anyway... */
+  if (surface->type & CSTF_LAYER)
+    return DFB_BUG;
+
+  ret = dfb_surfacemanager_allocate (local->core, data->manager,
+                                     buffer, NULL, NULL, false);
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "  -> %s\n", DirectFBErrorString (ret));
+
+  return ret;
+}
+
+static DFBResult
+fbdev_aux_AllocateBuffer (CoreSurfacePool       *pool,
+                          void                  *pool_data,
+                          void                  *pool_local,
+                          CoreSurfaceBuffer     *buffer,
+                          CoreSurfaceAllocation *allocation,
+                          void                  *alloc_data)
+{
+  CoreSurface                        *surface;
+  STMFB_AuxSurfacePoolData           * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData      * const local = pool_local;
+  STMFB_AuxSurfacePoolAllocationData * const alloc = alloc_data;
+  DFBResult                           ret;
+  Chunk                              *chunk;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d, %p)\n", __func__,
+              data->aux_part, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+
+  surface = buffer->surface;
+  D_MAGIC_ASSERT (surface, CoreSurface);
+
+  /* FIXME: this depends on the hardware, but we have no interface at the
+     moment anyway... */
+  if (surface->type & CSTF_LAYER)
+    return DFB_BUG;
+
+  ret = dfb_surfacemanager_allocate (local->core, data->manager, buffer,
+                                     allocation, &chunk, false);
+  if (ret)
+    return ret;
+
+  D_MAGIC_ASSERT (chunk, Chunk);
+
+  alloc->chunk = chunk;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux,
+              "  -> offset 0x%.8x (%u), format: %s, pitch %d, size %d\n",
+              chunk->offset, chunk->offset,
+              dfb_pixelformat_name (buffer->format), chunk->pitch,
+              chunk->length);
+
+  allocation->size   = chunk->length;
+  allocation->offset = chunk->offset;
+
+  D_MAGIC_SET (alloc, STMFB_AuxSurfacePoolAllocationData);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_DeallocateBuffer (CoreSurfacePool       *pool,
+                            void                  *pool_data,
+                            void                  *pool_local,
+                            CoreSurfaceBuffer     *buffer,
+                            CoreSurfaceAllocation *allocation,
+                            void                  *alloc_data)
+{
+  STMFB_AuxSurfacePoolData            * const data  = pool_data;
+  const STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+  STMFB_AuxSurfacePoolAllocationData  * const alloc = alloc_data;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d, %p)\n", __func__,
+              data->aux_part, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, STMFB_AuxSurfacePoolAllocationData);
+
+  (void) local;
+
+  D_ASSERT (alloc->chunk != NULL);
+  dfb_surfacemanager_deallocate (data->manager, alloc->chunk);
+
+  D_MAGIC_CLEAR (alloc);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_MuckOut (CoreSurfacePool   *pool,
+                   void              *pool_data,
+                   void              *pool_local,
+                   CoreSurfaceBuffer *buffer )
+{
+  STMFB_AuxSurfacePoolData            * const data  = pool_data;
+  const STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%p)\n", __func__, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+
+  return dfb_surfacemanager_displace (local->core, data->manager, buffer);
+}
+
+static DFBResult
+fbdev_aux_Lock (CoreSurfacePool       *pool,
+                void                  *pool_data,
+                void                  *pool_local,
+                CoreSurfaceAllocation *allocation,
+                void                  *alloc_data,
+                CoreSurfaceBufferLock *lock)
+{
+  const STMFB_AuxSurfacePoolData           * const data  = pool_data;
+  const STMFB_AuxSurfacePoolLocalData      * const local = pool_local;
+  const STMFB_AuxSurfacePoolAllocationData * const alloc = alloc_data;
+  const Chunk                              *chunk;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, STMFB_AuxSurfacePoolAllocationData);
+  D_MAGIC_ASSERT (lock, CoreSurfaceBufferLock);
+
+  D_DEBUG_AT (FBDev_SurfLock_Aux, "%s (%d, %p)\n", __func__,
+              data->aux_part, lock->buffer);
+
+  D_MAGIC_ASSERT (alloc->chunk, Chunk);
+  chunk = alloc->chunk;
+
+  lock->pitch  = chunk->pitch;
+  lock->offset = chunk->offset;
+  lock->addr   = local->mem + chunk->offset;
+  lock->phys   = data->part_base + chunk->offset;
+
+  D_DEBUG_AT (FBDev_SurfLock_Aux,
+              "  -> offset 0x%.8lx (%lu), pitch %d, addr %p, phys 0x%.8lx\n",
+              lock->offset, lock->offset, lock->pitch, lock->addr, lock->phys);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_Unlock (CoreSurfacePool       *pool,
+                  void                  *pool_data,
+                  void                  *pool_local,
+                  CoreSurfaceAllocation *allocation,
+                  void                  *alloc_data,
+                  CoreSurfaceBufferLock *lock)
+{
+  const STMFB_AuxSurfacePoolData           * const data  = pool_data;
+  const STMFB_AuxSurfacePoolLocalData      * const local = pool_local;
+  const STMFB_AuxSurfacePoolAllocationData * const alloc = alloc_data;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, STMFB_AuxSurfacePoolAllocationData);
+  D_MAGIC_ASSERT (lock, CoreSurfaceBufferLock);
+
+  D_DEBUG_AT (FBDev_SurfLock_Aux, "%s (%d, %p)\n", __func__,
+              data->aux_part, lock->buffer);
+
+  D_UNUSED_P (data);
+  D_UNUSED_P (local);
+  D_UNUSED_P (alloc);
+
+  return DFB_OK;
+}
+
+static const SurfacePoolFuncs fbdev_aux_SurfacePoolFuncs = {
+  .PoolDataSize       = fbdev_aux_PoolDataSize,
+  .PoolLocalDataSize  = fbdev_aux_PoolLocalDataSize,
+  .AllocationDataSize = fbdev_aux_AllocationDataSize,
+
+  .InitPool    = fbdev_aux_InitPool,
+  .JoinPool    = fbdev_aux_JoinPool,
+  .DestroyPool = fbdev_aux_DestroyPool,
+  .LeavePool   = fbdev_aux_LeavePool,
+
+  .TestConfig       = fbdev_aux_TestConfig,
+  .AllocateBuffer   = fbdev_aux_AllocateBuffer,
+  .DeallocateBuffer = fbdev_aux_DeallocateBuffer,
+
+  .MuckOut = fbdev_aux_MuckOut,
+
+  .Lock   = fbdev_aux_Lock,
+  .Unlock = fbdev_aux_Unlock,
+};
+
+void
+fbdev_aux_surface_pools_init (CoreDFB * const core)
+{
+  unsigned long           total_auxmem = 0;
+  struct stmfbio_auxmem2  auxmem;
+  int                     i;
+
+  D_ASSERT (dfb_core_is_master (core));
+
+  D_ASSUME (D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools) ==
+            (STMFBGP_GFX_LAST - STMFBGP_GFX_FIRST + 1));
+
+  for (i = -1, auxmem.index = 0;
+       auxmem.index < D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools);
+       ++auxmem.index)
+    {
+      CoreSurfacePool *pool;
+
+      if (ioctl (dfb_fbdev->fd, STMFBIO_GET_AUXMEMORY2, &auxmem) != 0)
+        break;
+
+      if (!auxmem.size)
+        continue;
+
+      dfb_fbdev->shared->aux_pool_index = auxmem.index;
+
+      if (dfb_surface_pool_initialize (core,
+                                       &fbdev_aux_SurfacePoolFuncs, &pool))
+        continue;
+
+      dfb_fbdev->shared->aux_pools[++i] = pool;
+      total_auxmem += pool->desc.size;
+    }
+
+  dfb_fbdev->shared->aux_pool_index = -1;
+
+  if (total_auxmem)
+    D_INFO ("FBDev/Surfaces/Aux: %lukB of auxmem!\n", total_auxmem / 1024);
+  else
+    D_INFO ("FBDev/Surfaces/Aux: no auxmem available!\n");
+}
+
+void
+fbdev_aux_surface_pools_destroy (CoreDFB * const core)
+{
+  int       i;
+
+  D_ASSERT (dfb_core_is_master (core));
+
+  for (i = 0; i < D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools); ++i)
+    {
+      CoreSurfacePool * const pool = dfb_fbdev->shared->aux_pools[i];
+      if (!pool)
+        continue;
+
+      if (dfb_surface_pool_destroy (pool))
+        continue;
+
+      dfb_fbdev->shared->aux_pools[i] = NULL;
+    }
+}
+
+void
+fbdev_aux_surface_pools_join (CoreDFB * const core)
+{
+  unsigned long  total_auxmem = 0;
+  int            i;
+
+  D_ASSERT (!dfb_core_is_master (core));
+
+  for (i = 0; i < D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools); ++i)
+    {
+      CoreSurfacePool * const pool = dfb_fbdev->shared->aux_pools[i];
+      if (!pool)
+        continue;
+
+      if (dfb_surface_pool_join (core, pool, &fbdev_aux_SurfacePoolFuncs))
+        continue;
+
+      total_auxmem += pool->desc.size;
+    }
+
+  if (total_auxmem)
+    D_INFO ("FBDev/Surfaces/Aux: %lukB of auxmem!\n", total_auxmem / 1024);
+  else
+    D_INFO ("FBDev/Surfaces/Aux: no auxmem available!\n");
+}
+
+void
+fbdev_aux_surface_pools_leave (CoreDFB * const core)
+{
+  int       i;
+
+  D_ASSERT (!dfb_core_is_master (core));
+
+  for (i = 0; i < D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools); ++i)
+    {
+      CoreSurfacePool * const pool = dfb_fbdev->shared->aux_pools[i];
+      if (!pool)
+        continue;
+
+      dfb_surface_pool_leave (pool);
+    }
+}
diff --git a/systems/fbdev/fbdev_aux_surface_pool.h b/systems/fbdev/fbdev_aux_surface_pool.h
new file mode 100644
index 0000000..3a64834
--- /dev/null
+++ b/systems/fbdev/fbdev_aux_surface_pool.h
@@ -0,0 +1,42 @@
+/*
+   FBDev system driver - auxmem surface pool memory
+
+   (c) Copyright 2009-2014  STMicroelectronics Ltd.
+
+   Based on code by André Draszik <andre.draszik@st.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STMFB_AUX_SURFACE_POOL_H__
+#define __STMFB_AUX_SURFACE_POOL_H__
+
+#include <core/coretypes.h>
+
+extern void
+fbdev_aux_surface_pools_init (CoreDFB * const core);
+
+extern void
+fbdev_aux_surface_pools_destroy (CoreDFB * const core);
+
+extern void
+fbdev_aux_surface_pools_join (CoreDFB * const core);
+
+extern void
+fbdev_aux_surface_pools_leave (CoreDFB * const core);
+
+
+#endif /* __STMFB_AUX_SURFACE_POOL_H__ */
diff --git a/systems/fbdev/fbdev_surface_pool.c b/systems/fbdev/fbdev_surface_pool.c
index 06bdbb1..b8220e2 100644
--- a/systems/fbdev/fbdev_surface_pool.c
+++ b/systems/fbdev/fbdev_surface_pool.c
@@ -247,7 +247,7 @@ fbdevTestConfig( CoreSurfacePool         *pool,
      if ((surface->type & CSTF_LAYER) && surface->resource_id == DLID_PRIMARY)
           return DFB_OK;
 
-     ret = dfb_surfacemanager_allocate( local->core, data->manager, buffer, NULL, NULL );
+     ret = dfb_surfacemanager_allocate( local->core, data->manager, buffer, NULL, NULL, true );
 
      D_DEBUG_AT( FBDev_Surfaces, "  -> %s\n", DirectFBErrorString(ret) );
 
@@ -284,7 +284,7 @@ fbdevAllocateBuffer( CoreSurfacePool       *pool,
           dfb_surface_calc_buffer_size( surface, 8, 1, NULL, &allocation->size );
      }
      else {
-          ret = dfb_surfacemanager_allocate( local->core, data->manager, buffer, allocation, &alloc->chunk );
+          ret = dfb_surfacemanager_allocate( local->core, data->manager, buffer, allocation, &alloc->chunk, true );
           if (ret)
                return ret;
 
diff --git a/systems/fbdev/surfacemanager.c b/systems/fbdev/surfacemanager.c
index bdb9d5d..5b66b45 100644
--- a/systems/fbdev/surfacemanager.c
+++ b/systems/fbdev/surfacemanager.c
@@ -192,7 +192,8 @@ DFBResult dfb_surfacemanager_allocate( CoreDFB                *core,
                                        SurfaceManager         *manager,
                                        CoreSurfaceBuffer      *buffer,
                                        CoreSurfaceAllocation  *allocation,
-                                       Chunk                 **ret_chunk )
+                                       Chunk                 **ret_chunk,
+                                       bool                    need_workaround )
 {
      int pitch;
      int length;
@@ -233,11 +234,11 @@ DFBResult dfb_surfacemanager_allocate( CoreDFB                *core,
      D_MAGIC_ASSERT( c, Chunk );
 
      /* FIXME_SC_2  Workaround creation happening before graphics driver initialization. */
-     if (!c->next) {
+     if (need_workaround && !c->next) {
           int length = dfb_gfxcard_memory_length();
 
           if (c->length != length - manager->offset) {
-               D_WARN( "workaround" );
+               D_WARN( "workaround due to reserved video memory" );
 
                manager->length = length;
                manager->avail  = length - manager->offset;
@@ -326,7 +327,7 @@ DFBResult dfb_surfacemanager_displace( CoreDFB           *core,
           D_MAGIC_ASSERT( chunk, Chunk );
 
           allocation = chunk->allocation;
-          if (allocation) {
+          if (allocation && allocation->buffer) {
                CoreSurfaceBuffer *other;
                int                size, locks;
 
diff --git a/systems/fbdev/surfacemanager.h b/systems/fbdev/surfacemanager.h
index 51d4fae..03f31ec 100644
--- a/systems/fbdev/surfacemanager.h
+++ b/systems/fbdev/surfacemanager.h
@@ -104,7 +104,8 @@ DFBResult dfb_surfacemanager_allocate( CoreDFB                *core,
                                        SurfaceManager         *manager,
                                        CoreSurfaceBuffer      *buffer,
                                        CoreSurfaceAllocation  *allocation,
-                                       Chunk                 **ret_chunk );
+                                       Chunk                 **ret_chunk,
+                                       bool                    need_workaround );
 
 DFBResult dfb_surfacemanager_displace( CoreDFB           *core,
                                        SurfaceManager    *manager,
diff --git a/systems/stmfbdev/Makefile.am b/systems/stmfbdev/Makefile.am
new file mode 100644
index 0000000..21e2a3d
--- /dev/null
+++ b/systems/stmfbdev/Makefile.am
@@ -0,0 +1,11 @@
+## Makefile.am for DirectFB/systems/stmfbdev
+
+internalincludedir = $(INTERNALINCLUDEDIR)/stmfbdev
+
+internalinclude_HEADERS = \
+	vt.h			\
+	stmfbdev.h
+
+systemsdir = $(MODULEDIR)/systems
+
+include $(top_srcdir)/rules/libobject.make
diff --git a/systems/stmfbdev/stmfbdev.h b/systems/stmfbdev/stmfbdev.h
new file mode 100644
index 0000000..4d5c244
--- /dev/null
+++ b/systems/stmfbdev/stmfbdev.h
@@ -0,0 +1,56 @@
+/*
+   (c) Copyright 2010       STMicroelectronics (R&D) Ltd.
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by André Draszik <andre.draszik@st.com>.
+
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjälä <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STMFBDEV__STMFBDEV_H__
+#define __STMFBDEV__STMFBDEV_H__
+
+#include <core/system.h>
+
+#include <fusion/shmalloc.h>
+
+#include <core/surface_pool.h>
+
+#include "vt.h"
+
+
+typedef struct {
+     int magic;
+
+     CoreDFB *core;
+
+     struct _STMfbdevSharedData *shared;
+     int                 fd;
+     void               *framebuffer_base;
+     VirtualTerminal    *vt;
+} STMfbdev;
+
+
+#endif /* __STMFBDEV__STMFBDEV_H__ */
diff --git a/systems/stmfbdev/vt.h b/systems/stmfbdev/vt.h
new file mode 120000
index 0000000..70958ae
--- /dev/null
+++ b/systems/stmfbdev/vt.h
@@ -0,0 +1 @@
+../fbdev/vt.h
\ No newline at end of file
diff --git a/systems/wayland/Makefile.am b/systems/wayland/Makefile.am
new file mode 100644
index 0000000..54cfabf
--- /dev/null
+++ b/systems/wayland/Makefile.am
@@ -0,0 +1,43 @@
+## Makefile.am for DirectFB/systems/wayland
+
+INCLUDES = \
+	-I$(top_builddir)/include	\
+	-I$(top_builddir)/lib		\
+	-I$(top_srcdir)/include		\
+	-I$(top_srcdir)/lib		\
+	-I$(top_srcdir)/src \
+	$(WAYLAND_CFLAGS)
+
+AM_CPPFLAGS = -D_XOPEN_SOURCE=500
+
+
+internalincludedir = $(INTERNALINCLUDEDIR)/wayland
+
+internalinclude_HEADERS = \
+	wayland.h
+
+
+systemsdir = $(MODULEDIR)/systems
+
+if BUILD_STATIC
+systems_DATA = libdirectfb_wayland.o
+endif
+systems_LTLIBRARIES = libdirectfb_wayland.la
+
+libdirectfb_wayland_la_LDFLAGS = \
+	-avoid-version	\
+	-module
+
+libdirectfb_wayland_la_SOURCES = \
+	wayland.c \
+	os-compatibility.c \
+	wayland_surface_pool.c
+
+libdirectfb_wayland_la_LIBADD = \
+	$(WAYLAND_LIBS) \
+	$(top_builddir)/lib/direct/libdirect.la \
+	$(top_builddir)/lib/fusion/libfusion.la \
+	$(top_builddir)/src/libdirectfb.la
+
+
+include $(top_srcdir)/rules/libobject.make
diff --git a/systems/wayland/keycodes.h b/systems/wayland/keycodes.h
new file mode 100644
index 0000000..e3debc7
--- /dev/null
+++ b/systems/wayland/keycodes.h
@@ -0,0 +1,171 @@
+
+#ifndef __CORE__WAYLAND_KEYCODES_H__
+#define __CORE__WAYLAND_KEYCODES_H__
+
+/* from linux_input.c */
+
+static const
+int basic_keycodes [] = {
+     DIKI_UNKNOWN, DIKI_ESCAPE, DIKI_1, DIKI_2, DIKI_3, DIKI_4, DIKI_5,
+     DIKI_6, DIKI_7, DIKI_8, DIKI_9, DIKI_0, DIKI_MINUS_SIGN,
+     DIKI_EQUALS_SIGN, DIKI_BACKSPACE,
+
+     DIKI_TAB, DIKI_Q, DIKI_W, DIKI_E, DIKI_R, DIKI_T, DIKI_Y, DIKI_U,
+     DIKI_I, DIKI_O, DIKI_P, DIKI_BRACKET_LEFT, DIKI_BRACKET_RIGHT,
+     DIKI_ENTER,
+
+     DIKI_CONTROL_L, DIKI_A, DIKI_S, DIKI_D, DIKI_F, DIKI_G, DIKI_H, DIKI_J,
+     DIKI_K, DIKI_L, DIKI_SEMICOLON, DIKI_QUOTE_RIGHT, DIKI_QUOTE_LEFT,
+
+     DIKI_SHIFT_L, DIKI_BACKSLASH, DIKI_Z, DIKI_X, DIKI_C, DIKI_V, DIKI_B,
+     DIKI_N, DIKI_M, DIKI_COMMA, DIKI_PERIOD, DIKI_SLASH, DIKI_SHIFT_R,
+     DIKI_KP_MULT, DIKI_ALT_L, DIKI_SPACE, DIKI_CAPS_LOCK,
+
+     DIKI_F1, DIKI_F2, DIKI_F3, DIKI_F4, DIKI_F5, DIKI_F6, DIKI_F7, DIKI_F8,
+     DIKI_F9, DIKI_F10, DIKI_NUM_LOCK, DIKI_SCROLL_LOCK,
+
+     DIKI_KP_7, DIKI_KP_8, DIKI_KP_9, DIKI_KP_MINUS,
+     DIKI_KP_4, DIKI_KP_5, DIKI_KP_6, DIKI_KP_PLUS,
+     DIKI_KP_1, DIKI_KP_2, DIKI_KP_3, DIKI_KP_0, DIKI_KP_DECIMAL,
+
+     /*KEY_103RD,*/ DIKI_BACKSLASH,
+     /*KEY_F13,*/ DFB_FUNCTION_KEY(13),
+     /*KEY_102ND*/ DIKI_LESS_SIGN,
+
+     DIKI_F11, DIKI_F12, DFB_FUNCTION_KEY(14), DFB_FUNCTION_KEY(15),
+     DFB_FUNCTION_KEY(16), DFB_FUNCTION_KEY(17), DFB_FUNCTION_KEY(18),
+     DFB_FUNCTION_KEY(19), DFB_FUNCTION_KEY(20),
+
+     DIKI_KP_ENTER, DIKI_CONTROL_R, DIKI_KP_DIV, DIKI_PRINT, DIKS_ALTGR,
+
+     /*KEY_LINEFEED*/ DIKI_UNKNOWN,
+
+     DIKI_HOME, DIKI_UP, DIKI_PAGE_UP, DIKI_LEFT, DIKI_RIGHT,
+     DIKI_END, DIKI_DOWN, DIKI_PAGE_DOWN, DIKI_INSERT, DIKI_DELETE,
+
+     /*KEY_MACRO,*/ DIKI_UNKNOWN,
+
+     DIKS_MUTE, DIKS_VOLUME_DOWN, DIKS_VOLUME_UP, DIKS_POWER, DIKI_KP_EQUAL,
+
+     /*KEY_KPPLUSMINUS,*/ DIKI_UNKNOWN,
+
+     DIKS_PAUSE, DFB_FUNCTION_KEY(21), DFB_FUNCTION_KEY(22),
+     DFB_FUNCTION_KEY(23), DFB_FUNCTION_KEY(24),
+
+     DIKI_KP_SEPARATOR, DIKI_META_L, DIKI_META_R, DIKI_SUPER_L,
+
+     DIKS_STOP,
+
+     /*DIKS_AGAIN, DIKS_PROPS, DIKS_UNDO, DIKS_FRONT, DIKS_COPY,
+     DIKS_OPEN, DIKS_PASTE, DIKS_FIND, DIKS_CUT,*/
+     DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN,
+     DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN,
+
+     DIKS_HELP, DIKS_MENU, DIKS_CALCULATOR, DIKS_SETUP,
+
+     /*KEY_SLEEP, KEY_WAKEUP, KEY_FILE, KEY_SENDFILE, KEY_DELETEFILE,
+     KEY_XFER,*/
+     DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN,
+     DIKI_UNKNOWN,
+
+     /*KEY_PROG1, KEY_PROG2,*/
+     DIKS_CUSTOM1, DIKS_CUSTOM2,
+
+     DIKS_INTERNET,
+
+     /*KEY_MSDOS, KEY_COFFEE, KEY_DIRECTION, KEY_CYCLEWINDOWS,*/
+     DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN,
+
+     DIKS_MAIL,
+
+     /*KEY_BOOKMARKS, KEY_COMPUTER, */
+     DIKI_UNKNOWN, DIKI_UNKNOWN,
+
+     DIKS_BACK, DIKS_FORWARD,
+
+     /*KEY_CLOSECD, KEY_EJECTCD, KEY_EJECTCLOSECD,*/
+     DIKS_EJECT, DIKS_EJECT, DIKS_EJECT,
+
+     DIKS_NEXT, DIKS_PLAYPAUSE, DIKS_PREVIOUS, DIKS_STOP, DIKS_RECORD,
+     DIKS_REWIND, DIKS_PHONE,
+
+     /*KEY_ISO,*/ DIKI_UNKNOWN,
+     /*KEY_CONFIG,*/ DIKS_SETUP,
+     /*KEY_HOMEPAGE, KEY_REFRESH,*/ DIKI_UNKNOWN, DIKS_SHUFFLE,
+
+     DIKS_EXIT, /*KEY_MOVE,*/ DIKI_UNKNOWN, DIKS_EDITOR,
+
+     /*KEY_SCROLLUP,*/ DIKS_PAGE_UP,
+     /*KEY_SCROLLDOWN,*/ DIKS_PAGE_DOWN,
+     /*KEY_KPLEFTPAREN,*/ DIKI_UNKNOWN,
+     /*KEY_KPRIGHTPAREN,*/ DIKI_UNKNOWN,
+
+     /* unused codes 181-182: */
+     DIKI_UNKNOWN, DIKI_UNKNOWN,
+
+     DFB_FUNCTION_KEY(13), DFB_FUNCTION_KEY(14), DFB_FUNCTION_KEY(15),
+     DFB_FUNCTION_KEY(16), DFB_FUNCTION_KEY(17), DFB_FUNCTION_KEY(18),
+     DFB_FUNCTION_KEY(19), DFB_FUNCTION_KEY(20), DFB_FUNCTION_KEY(21),
+     DFB_FUNCTION_KEY(22), DFB_FUNCTION_KEY(23), DFB_FUNCTION_KEY(24),
+
+     /* unused codes 195-199: */
+     DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN, DIKI_UNKNOWN,
+
+     /* KEY_PLAYCD, KEY_PAUSECD */
+     DIKS_PLAY, DIKS_PAUSE,
+
+     /*KEY_PROG3, KEY_PROG4,*/
+     DIKS_CUSTOM3, DIKS_CUSTOM4,
+
+     DIKI_UNKNOWN,
+
+     /*KEY_SUSPEND, KEY_CLOSE*/
+     DIKI_UNKNOWN, DIKI_UNKNOWN,
+
+     /* KEY_PLAY */
+     DIKS_PLAY,
+
+     /* KEY_FASTFORWARD */
+     DIKS_FASTFORWARD,
+
+     /* KEY_BASSBOOST */
+     DIKI_UNKNOWN,
+
+     /* KEY_PRINT */
+     DIKS_PRINT,
+
+     /* KEY_HP             */  DIKI_UNKNOWN,
+     /* KEY_CAMERA         */  DIKI_UNKNOWN,
+     /* KEY_SOUND          */  DIKS_AUDIO,
+     /* KEY_QUESTION       */  DIKS_HELP,
+     /* KEY_EMAIL          */  DIKS_MAIL,
+     /* KEY_CHAT           */  DIKI_UNKNOWN,
+     /* KEY_SEARCH         */  DIKI_UNKNOWN,
+     /* KEY_CONNECT        */  DIKI_UNKNOWN,
+     /* KEY_FINANCE        */  DIKI_UNKNOWN,
+     /* KEY_SPORT          */  DIKI_UNKNOWN,
+     /* KEY_SHOP           */  DIKI_UNKNOWN,
+     /* KEY_ALTERASE       */  DIKI_UNKNOWN,
+     /* KEY_CANCEL         */  DIKS_CANCEL,
+     /* KEY_BRIGHTNESSDOWN */  DIKI_UNKNOWN,
+     /* KEY_BRIGHTNESSUP   */  DIKI_UNKNOWN,
+     /* KEY_MEDIA          */  DIKI_UNKNOWN,
+};
+
+static const
+int ext_keycodes [] = {
+     DIKS_OK, DIKS_SELECT, DIKS_GOTO, DIKS_CLEAR, DIKS_POWER2, DIKS_OPTION,
+     DIKS_INFO, DIKS_TIME, DIKS_VENDOR, DIKS_ARCHIVE, DIKS_PROGRAM,
+     DIKS_CHANNEL, DIKS_FAVORITES, DIKS_EPG, DIKS_PVR, DIKS_MHP,
+     DIKS_LANGUAGE, DIKS_TITLE, DIKS_SUBTITLE, DIKS_ANGLE, DIKS_ZOOM,
+     DIKS_MODE, DIKS_KEYBOARD, DIKS_SCREEN, DIKS_PC, DIKS_TV, DIKS_TV2,
+     DIKS_VCR, DIKS_VCR2, DIKS_SAT, DIKS_SAT2, DIKS_CD, DIKS_TAPE,
+     DIKS_RADIO, DIKS_TUNER, DIKS_PLAYER, DIKS_TEXT, DIKS_DVD, DIKS_AUX,
+     DIKS_MP3, DIKS_AUDIO, DIKS_VIDEO, DIKS_DIRECTORY, DIKS_LIST, DIKS_MEMO,
+     DIKS_CALENDAR, DIKS_RED, DIKS_GREEN, DIKS_YELLOW, DIKS_BLUE,
+     DIKS_CHANNEL_UP, DIKS_CHANNEL_DOWN, DIKS_FIRST, DIKS_LAST, DIKS_AB,
+     DIKS_NEXT, DIKS_RESTART, DIKS_SLOW, DIKS_SHUFFLE, DIKS_FASTFORWARD,
+     DIKS_PREVIOUS, DIKS_NEXT, DIKS_DIGITS, DIKS_TEEN, DIKS_TWEN, DIKS_BREAK
+};
+
+#endif
diff --git a/systems/wayland/os-compatibility.c b/systems/wayland/os-compatibility.c
new file mode 100644
index 0000000..b28f2b7
--- /dev/null
+++ b/systems/wayland/os-compatibility.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright © 2012 Collabora, Ltd.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/epoll.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "os-compatibility.h"
+
+static int
+set_cloexec_or_close(int fd)
+{
+	long flags;
+
+	if (fd == -1)
+		return -1;
+
+	flags = fcntl(fd, F_GETFD);
+	if (flags == -1)
+		goto err;
+
+	if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
+		goto err;
+
+	return fd;
+
+err:
+	close(fd);
+	return -1;
+}
+
+int
+os_epoll_create_cloexec(void)
+{
+	int fd;
+
+#ifdef EPOLL_CLOEXEC
+	fd = epoll_create1(EPOLL_CLOEXEC);
+	if (fd >= 0)
+		return fd;
+	if (errno != EINVAL)
+		return -1;
+#endif
+
+	fd = epoll_create(1);
+	return set_cloexec_or_close(fd);
+}
+
+static int
+create_tmpfile_cloexec(char *tmpname)
+{
+	int fd;
+
+#ifdef HAVE_MKOSTEMP
+	fd = mkostemp(tmpname, O_CLOEXEC);
+	if (fd >= 0)
+		unlink(tmpname);
+#else
+	fd = mkstemp(tmpname);
+	if (fd >= 0) {
+		fd = set_cloexec_or_close(fd);
+		unlink(tmpname);
+	}
+#endif
+
+	return fd;
+}
+
+/*
+ * Create a new, unique, anonymous file of the given size, and
+ * return the file descriptor for it. The file descriptor is set
+ * CLOEXEC. The file is immediately suitable for mmap()'ing
+ * the given size at offset zero.
+ *
+ * The file should not have a permanent backing store like a disk,
+ * but may have if XDG_RUNTIME_DIR is not properly implemented in OS.
+ *
+ * The file name is deleted from the file system.
+ *
+ * The file is suitable for buffer sharing between processes by
+ * transmitting the file descriptor over Unix sockets using the
+ * SCM_RIGHTS methods.
+ *
+ * If the C library implements posix_fallocate(), it is used to
+ * guarantee that disk space is available for the file at the
+ * given size. If disk space is insufficent, errno is set to ENOSPC.
+ * If posix_fallocate() is not supported, program may receive
+ * SIGBUS on accessing mmap()'ed file contents instead.
+ */
+int
+os_create_anonymous_file(off_t size)
+{
+	static const char template[] = "/weston-shared-XXXXXX";
+	const char *path;
+	char *name;
+	int fd;
+	int ret;
+
+	path = getenv("XDG_RUNTIME_DIR");
+	if (!path) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	name = malloc(strlen(path) + sizeof(template));
+	if (!name)
+		return -1;
+
+	strcpy(name, path);
+	strcat(name, template);
+
+	fd = create_tmpfile_cloexec(name);
+
+	free(name);
+
+	if (fd < 0)
+		return -1;
+
+#ifdef HAVE_POSIX_FALLOCATE
+	ret = posix_fallocate(fd, 0, size);
+	if (ret != 0) {
+		close(fd);
+		errno = ret;
+		return -1;
+	}
+#else
+	ret = ftruncate(fd, size);
+	if (ret < 0) {
+		close(fd);
+		return -1;
+	}
+#endif
+
+	return fd;
+}
diff --git a/systems/wayland/os-compatibility.h b/systems/wayland/os-compatibility.h
new file mode 100644
index 0000000..9b85543
--- /dev/null
+++ b/systems/wayland/os-compatibility.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright © 2012 Collabora, Ltd.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef OS_COMPATIBILITY_H
+#define OS_COMPATIBILITY_H
+
+#include <config.h>
+
+#include <sys/types.h>
+
+int
+os_epoll_create_cloexec(void);
+
+int
+os_create_anonymous_file(off_t size);
+
+#endif /* OS_COMPATIBILITY_H */
diff --git a/systems/wayland/wayland.c b/systems/wayland/wayland.c
new file mode 100644
index 0000000..d01b8ee
--- /dev/null
+++ b/systems/wayland/wayland.c
@@ -0,0 +1,1199 @@
+/*
+   (c) Copyright 2015  STMicroelectronics R&D
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Ilyes Gouta <ilyes.gouta@st.com>
+
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjälä <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <asm/types.h>
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <strings.h>
+#if defined(HAVE_SYSIO)
+# include <sys/io.h>
+#endif
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/kd.h>
+#include <sys/timerfd.h>
+#include <sys/select.h>
+#include <sys/epoll.h>
+
+#include <directfb.h>
+
+#include <core/core.h>
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <core/layer_control.h>
+#include <core/layers.h>
+#include <core/palette.h>
+#include <core/screen.h>
+#include <core/screens.h>
+#include <core/surface.h>
+#include <core/surface_buffer.h>
+#include <core/surface_pool.h>
+#include <core/core_system.h>
+#include <core/system.h>
+#include <core/input.h>
+
+#include <direct/thread.h>
+
+#include <directfb_strings.h>
+
+#include <linux/input.h>
+
+#include "wayland.h"
+#include "keycodes.h"
+
+/* from Weston compositor source code (under BSD). */
+#include "os-compatibility.h"
+
+DFB_CORE_SYSTEM( wayland )
+
+D_DEBUG_DOMAIN( Wayland_Primary, "Wayland/Primary", "Wayland Primary Layer" );
+
+struct wayland_context *wayland_context;
+
+extern const SurfacePoolFuncs WaylandSurfacePoolFuncs;
+
+DirectFBPixelFormatNames( pixelformats );
+
+static void
+system_get_info( CoreSystemInfo *info )
+{
+     info->type = CORE_WAYLAND;
+     info->caps = CSCAPS_NONE;
+
+     snprintf( info->name, DFB_CORE_SYSTEM_INFO_NAME_LENGTH, "Wayland" );
+}
+
+static DFBResult
+system_suspend( void )
+{
+     return DFB_OK;
+}
+
+static DFBResult
+system_resume( void )
+{
+     return DFB_OK;
+}
+
+static volatile void *
+system_map_mmio( unsigned int    offset,
+                 int             length )
+{
+     return NULL;
+}
+
+static void
+system_unmap_mmio( volatile void  *addr,
+                   int             length )
+{
+}
+
+static int
+system_get_accelerator( void )
+{
+     if (dfb_config->accelerator)
+          return dfb_config->accelerator;
+
+     return 99;
+}
+
+static VideoMode*
+system_get_modes( void )
+{
+     return NULL;
+}
+
+static VideoMode*
+system_get_current_mode( void )
+{
+     return NULL;
+}
+
+static bool
+system_input_filter( CoreInputDevice *device,
+                     DFBInputEvent   *event )
+{
+     return false;
+}
+
+static unsigned long
+system_video_memory_physical( unsigned int offset )
+{
+     return 0;
+}
+
+static void*
+system_video_memory_virtual( unsigned int offset )
+{
+     return NULL;
+}
+
+static unsigned int
+system_videoram_length( void )
+{
+     return 1;
+}
+
+static unsigned long
+system_aux_memory_physical( unsigned int offset )
+{
+     return 0;
+}
+
+static void *
+system_aux_memory_virtual( unsigned int offset )
+{
+     return NULL;
+}
+
+static unsigned int
+system_auxram_length( void )
+{
+     return 0;
+}
+
+static void
+system_get_busid( int *ret_bus, int *ret_dev, int *ret_func )
+{
+     *ret_bus  = 1;
+     *ret_dev  = 0;
+     *ret_func = 0;
+}
+
+static int
+system_surface_data_size( void )
+{
+     return 0;
+}
+
+static void
+system_surface_data_init( CoreSurface *surface, void *data )
+{
+}
+
+static void
+system_surface_data_destroy( CoreSurface *surface, void *data )
+{
+}
+
+static void
+system_get_deviceid( unsigned int *ret_vendor_id,
+                     unsigned int *ret_device_id )
+{
+     *ret_vendor_id = 1;
+     *ret_device_id = 0;
+}
+
+static DFBResult
+system_thread_init( void )
+{
+//     if (dfb_config->block_all_signals)
+//          direct_signals_block_all();
+
+     return DFB_OK;
+}
+
+static void
+buffer_release(void *data, struct wl_buffer *buffer)
+{
+     struct wayland_context *d = data;
+
+     if (d->config.buffermode != DLBM_FRONTONLY)
+          sem_post( &d->flip_semaphore );
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+	buffer_release
+};
+
+static int to_shm_format( DFBSurfacePixelFormat format )
+{
+     switch (format) {
+     case DSPF_ARGB:
+          return WL_SHM_FORMAT_ARGB8888;
+	case DSPF_RGB32:
+          return WL_SHM_FORMAT_XRGB8888;
+	case DSPF_ARGB4444:
+          return WL_SHM_FORMAT_ARGB4444;
+	case DSPF_RGB555:
+          return WL_SHM_FORMAT_XRGB1555;
+	case DSPF_ARGB1555:
+          return WL_SHM_FORMAT_ARGB1555;
+	case DSPF_RGB16:
+          return WL_SHM_FORMAT_RGB565;
+	case DSPF_RGB24:
+          return WL_SHM_FORMAT_RGB888;
+     default:
+          return -1;
+     }
+}
+
+static int
+create_shm_buffer( struct display_buffer* buffer, int width, int height,
+                   DFBSurfacePixelFormat format )
+{
+     struct wl_shm_pool *pool;
+     int fd, size, stride;
+     void *data;
+
+     int shm_format = to_shm_format( format );
+     if (shm_format < 0)
+          return -1; /* format not recognized */
+
+     if (shm_format != WL_SHM_FORMAT_ARGB8888
+         && !fusion_vector_contains( &wayland_context->shm_formats,
+                                     (void*)shm_format))
+          return -1; /* wl_shm didn't advestise the pixelformat */
+
+     stride = DFB_BYTES_PER_LINE( format, width );
+     size = stride * height;
+
+     fd = os_create_anonymous_file( size );
+     if (fd < 0)
+          return -1;
+
+     data = mmap( NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0 );
+     if (data == MAP_FAILED) {
+          close( fd );
+          return -1;
+     }
+
+     pool = wl_shm_create_pool( wayland_context->shm, fd, size );
+     buffer->buffer =
+               wl_shm_pool_create_buffer( pool, 0, width, height,
+                                          stride, shm_format );
+     buffer->data = data;
+     buffer->pitch = stride;
+     buffer->size = size;
+
+     wl_buffer_add_listener( buffer->buffer, &buffer_listener, wayland_context );
+     wl_shm_pool_destroy( pool );
+
+     close( fd );
+
+     return 0;
+}
+
+static DFBResult
+primaryInitScreen( CoreScreen           *screen,
+                   CoreGraphicsDevice   *device,
+                   void                 *driver_data,
+                   void                 *screen_data,
+                   DFBScreenDescription *description )
+{
+     D_DEBUG_AT( Wayland_Primary, "%s()\n", __FUNCTION__ );
+
+     description->caps = DSCCAPS_VSYNC;
+
+     snprintf( description->name,
+               DFB_SCREEN_DESC_NAME_LENGTH, "Wayland Primary Screen" );
+
+     return DFB_OK;
+}
+
+static void
+frame_hint(void *data, struct wl_callback *callback, uint32_t time)
+{
+}
+
+static const struct wl_callback_listener frame_listener = {
+	frame_hint
+};
+
+static DFBResult
+primaryGetScreenSize( CoreScreen *screen,
+                      void       *driver_data,
+                      void       *screen_data,
+                      int        *ret_width,
+                      int        *ret_height )
+{
+     D_DEBUG_AT( Wayland_Primary, "%s()\n", __FUNCTION__ );
+
+     D_ASSERT( wayland_context != NULL );
+
+     *ret_width  = wayland_context->width;
+     *ret_height = wayland_context->height;
+
+     return DFB_OK;
+}
+
+static int
+primaryLayerDataSize( void )
+{
+     return 0;
+}
+
+static int
+primaryRegionDataSize( void )
+{
+     return 0;
+}
+
+static DFBResult
+primaryInitLayer( CoreLayer                  *layer,
+                  void                       *driver_data,
+                  void                       *layer_data,
+                  DFBDisplayLayerDescription *description,
+                  DFBDisplayLayerConfig      *config,
+                  DFBColorAdjustment         *adjustment )
+{
+     D_DEBUG_AT( Wayland_Primary, "%s()\n", __FUNCTION__ );
+
+     int ret;
+
+     description->caps = DLCAPS_SURFACE;
+     description->type = DLTF_GRAPHICS;
+
+     snprintf( description->name,
+               DFB_DISPLAY_LAYER_DESC_NAME_LENGTH, "Wayland Primary Layer" );
+
+     config->flags      = DLCONF_WIDTH       | DLCONF_HEIGHT |
+                          DLCONF_PIXELFORMAT | DLCONF_BUFFERMODE;
+     config->buffermode = DLBM_FRONTONLY;
+     config->width      = dfb_config->mode.width ?
+                               dfb_config->mode.width : 640;
+     config->height     = dfb_config->mode.height ?
+                               dfb_config->mode.height : 480;
+
+     if (dfb_config->mode.format)
+          config->pixelformat = dfb_config->mode.format;
+     else
+          config->pixelformat = DSPF_ARGB;
+
+     wayland_context->width = config->width;
+     wayland_context->height = config->height;
+     wayland_context->format = config->pixelformat;
+
+     /* allocate all targets as DirectFB might be locking the back buffers
+        before calling primarySetRegion(). */
+     for (int i = 0; i < 3; i++) {
+          ret = create_shm_buffer( &wayland_context->buffer[i],
+                                   config->width, config->height,
+                                   config->pixelformat );
+          if (ret < 0)
+               return DFB_FAILURE;
+     }
+
+     /* attach the front buffer */
+     wl_surface_attach( wayland_context->surface,
+                        wayland_context->buffer[0].buffer, 0, 0 );
+     wl_surface_damage( wayland_context->surface, 0, 0,
+                        wayland_context->width, wayland_context->height );
+     wl_surface_commit( wayland_context->surface );
+
+     wl_display_roundtrip( wayland_context->display );
+
+     wayland_context->timer_fd = -1;
+
+     return DFB_OK;
+}
+
+static DFBResult
+primaryTestRegion( CoreLayer                  *layer,
+                   void                       *driver_data,
+                   void                       *layer_data,
+                   CoreLayerRegionConfig      *config,
+                   CoreLayerRegionConfigFlags *failed )
+{
+     CoreLayerRegionConfigFlags fail = CLRCF_NONE;
+
+     D_DEBUG_AT( Wayland_Primary, "%s( %dx%d, %s )\n", __FUNCTION__,
+                 config->source.w, config->source.h,
+                 dfb_pixelformat_name(config->format) );
+
+     /* pixelformat gets set only once at startup */
+     if (config->format != wayland_context->format)
+          fail |= CLRCF_FORMAT;
+
+     if (failed)
+          *failed = fail;
+
+     if (fail)
+          return DFB_UNSUPPORTED;
+
+     return DFB_OK;
+}
+
+static DFBResult
+primaryAddRegion( CoreLayer             *layer,
+                  void                  *driver_data,
+                  void                  *layer_data,
+                  void                  *region_data,
+                  CoreLayerRegionConfig *config )
+{
+     D_DEBUG_AT( Wayland_Primary, "%s()\n", __FUNCTION__ );
+
+     return DFB_OK;
+}
+
+static DFBResult
+primarySetRegion( CoreLayer                  *layer,
+                  void                       *driver_data,
+                  void                       *layer_data,
+                  void                       *region_data,
+                  CoreLayerRegionConfig      *config,
+                  CoreLayerRegionConfigFlags  updated,
+                  CoreSurface                *surface,
+                  CorePalette                *palette,
+                  CoreSurfaceBufferLock      *left_lock,
+                  CoreSurfaceBufferLock      *right_lock )
+{
+     int buffers_count = 1;
+     int ret;
+
+     D_DEBUG_AT( Wayland_Primary, "%s()\n", __FUNCTION__ );
+
+     wayland_context->config = *config;
+
+     if (updated & (CLRCF_WIDTH | CLRCF_HEIGHT | CLRCF_BUFFERMODE))
+     {
+          buffers_count =
+                    (config->buffermode == DLBM_FRONTONLY) ? 1 :
+                    ((config->buffermode == DLBM_BACKVIDEO
+                      || config->buffermode == DLBM_BACKSYSTEM) ? 2 : 3);
+
+          /* clean up resources as we were in DLBM_FRONTONLY mode */
+          if (buffers_count > 1
+              && wayland_context->timer_fd > 0) {
+               epoll_ctl( wayland_context->epoll_fd, EPOLL_CTL_DEL,
+                          wayland_context->timer_fd, NULL );
+
+               close( wayland_context->timer_fd );
+               wayland_context->timer_fd = -1;
+          }
+
+          wl_surface_attach( wayland_context->surface, NULL, 0, 0 );
+          wl_surface_commit( wayland_context->surface );
+
+          for (int i = 0; i < buffers_count; i++) {
+               if (wayland_context->buffer[i].buffer) {
+                    wl_buffer_destroy( wayland_context->buffer[i].buffer );
+                    wayland_context->buffer[i].buffer = NULL;
+               }
+
+               ret = create_shm_buffer( &wayland_context->buffer[i],
+                                        config->width, config->height,
+                                        config->format );
+               if (ret < 0) {
+                    D_DEBUG_AT( Wayland_Primary,
+                                "  -> Failed creating shm buffer (index %d, size %dx%d, format %s)\n",
+                                i, config->width, config->height,
+                                dfb_pixelformat_name( config->format ) );
+                    return DFB_FAILURE;
+               }
+          }
+
+          if (buffers_count > 1) {
+               sem_destroy( &wayland_context->flip_semaphore );
+               sem_init( &wayland_context->flip_semaphore, 0, buffers_count - 1 );
+          }
+
+          wl_surface_attach( wayland_context->surface,
+                             wayland_context->buffer[0].buffer, 0, 0 );
+          wl_surface_damage( wayland_context->surface, 0, 0,
+                             wayland_context->width, wayland_context->height );
+          wl_surface_commit( wayland_context->surface );
+     }
+
+     wl_display_roundtrip( wayland_context->display );
+
+     /* simulate a 30Hz refresh rate using a timer */
+     if (config->buffermode == DLBM_FRONTONLY) {
+          if (wayland_context->timer_fd < 0) {
+               wayland_context->timer_fd =
+                         timerfd_create( CLOCK_MONOTONIC, TFD_CLOEXEC );
+
+               if (wayland_context->timer_fd > 0) {
+                    struct itimerspec its;
+                    int ret;
+
+                    its.it_interval.tv_sec = 0;
+                    its.it_interval.tv_nsec = 33000000;
+                    its.it_value.tv_sec = 0;
+                    its.it_value.tv_nsec = 33000000;
+
+                    ret = timerfd_settime( wayland_context->timer_fd, 0,
+                                           &its, NULL );
+                    if (ret == 0) {
+                         struct epoll_event ep;
+                         ep.events = EPOLLIN;
+                         ep.data.ptr = wayland_context;
+                         ep.data.fd = wayland_context->timer_fd;
+                         /* multiplex timer fd */
+                         ret = epoll_ctl( wayland_context->epoll_fd,
+                                          EPOLL_CTL_ADD,
+                                          wayland_context->timer_fd, &ep );
+                    }
+
+                    if (ret < 0)
+                         D_DEBUG_AT( Wayland_Primary, "  -> Failed muxing timer fd\n" );
+               }
+          }
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult
+primaryRemoveRegion( CoreLayer             *layer,
+                     void                  *driver_data,
+                     void                  *layer_data,
+                     void                  *region_data )
+{
+     D_DEBUG_AT( Wayland_Primary, "%s()\n", __FUNCTION__ );
+
+     return DFB_OK;
+}
+
+static DFBResult
+primaryFlipRegion( CoreLayer             *layer,
+                   void                  *driver_data,
+                   void                  *layer_data,
+                   void                  *region_data,
+                   CoreSurface           *surface,
+                   DFBSurfaceFlipFlags    flags,
+                   const DFBRegion       *left_update,
+                   CoreSurfaceBufferLock *left_lock,
+                   const DFBRegion       *right_update,
+                   CoreSurfaceBufferLock *right_lock )
+{
+     D_DEBUG_AT( Wayland_Primary, "%s()\n", __FUNCTION__ );
+
+     int index = left_lock->allocation->index;
+
+     /* We can't support DSFLIP_WAITFORSYNC, DSFLIP_WAIT, DSFLIP_ONSYNC
+        because Wayland clients don't have direct access to the hardware. */
+
+     wl_surface_attach( wayland_context->surface,
+                        wayland_context->buffer[index].buffer, 0, 0 );
+     wl_surface_damage( wayland_context->surface, 0, 0,
+                        wayland_context->width, wayland_context->height );
+
+     if (wayland_context->callback)
+          wl_callback_destroy( wayland_context->callback );
+
+     wayland_context->callback = wl_surface_frame( wayland_context->surface );
+     wl_callback_add_listener( wayland_context->callback,
+                               &frame_listener, wayland_context );
+
+     wl_surface_commit( wayland_context->surface );
+
+     wl_display_flush( wayland_context->display );
+
+     dfb_surface_flip( surface, false );
+
+     if (wayland_context->config.buffermode != DLBM_FRONTONLY)
+          sem_wait( &wayland_context->flip_semaphore );
+
+     return DFB_OK;
+}
+
+static void
+handle_shell_surface_ping( void *data, struct wl_shell_surface *surface,
+                           uint32_t serial )
+{
+     wl_shell_surface_pong( surface, serial );
+}
+
+static void
+handle_shell_surface_configure( void *data, struct wl_shell_surface *surface,
+                                uint32_t edges, int32_t width, int32_t height )
+{
+}
+
+static void
+handle_shell_surface_popup_done( void *data, struct wl_shell_surface *surface )
+{
+}
+
+static const struct wl_shell_surface_listener shell_surface_listener = {
+     handle_shell_surface_ping,
+     handle_shell_surface_configure,
+     handle_shell_surface_popup_done
+};
+
+static void
+configure_callback( void *data, struct wl_callback *callback, uint32_t time )
+{
+     wl_callback_destroy( callback );
+}
+
+static struct wl_callback_listener configure_callback_listener = {
+     configure_callback,
+};
+
+static void
+pointer_handle_enter( void *data, struct wl_pointer *pointer,
+                      uint32_t serial, struct wl_surface *surface,
+                      wl_fixed_t sx, wl_fixed_t sy )
+{
+}
+
+static void
+pointer_handle_leave( void *data, struct wl_pointer *pointer,
+                      uint32_t serial, struct wl_surface *surface )
+{
+}
+
+static void
+pointer_handle_motion( void *data, struct wl_pointer *pointer,
+                       uint32_t time, wl_fixed_t sx, wl_fixed_t sy )
+{
+     if (wayland_context->input_device) {
+          DFBInputEvent event;
+
+          event.type = DIET_AXISMOTION;
+          event.flags = DIEF_AXISABS | DIEF_FOLLOW;
+          event.axis = DIAI_X;
+          event.axisabs = sx >> 8;
+
+          dfb_input_dispatch( wayland_context->input_device, &event );
+
+          event.type = DIET_AXISMOTION;
+          event.flags = DIEF_AXISABS;
+          event.axis = DIAI_Y;
+          event.axisabs = sy >> 8;
+
+          dfb_input_dispatch( wayland_context->input_device, &event );
+     }
+}
+
+static void
+pointer_handle_button( void *data, struct wl_pointer *wl_pointer,
+                       uint32_t serial, uint32_t time, uint32_t button,
+                       uint32_t state )
+{
+     DFBInputEvent event;
+
+     event.type = 0;
+
+     if (button == BTN_LEFT)
+          event.button = DIBI_LEFT;
+     if (button == BTN_RIGHT)
+          event.button = DIBI_RIGHT;
+
+     if (state == WL_POINTER_BUTTON_STATE_PRESSED)
+          event.type = DIET_BUTTONPRESS;
+     if (state == WL_POINTER_BUTTON_STATE_RELEASED)
+          event.type = DIET_BUTTONRELEASE;
+
+     if (event.type)
+          dfb_input_dispatch( wayland_context->input_device, &event );
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+	pointer_handle_enter,
+	pointer_handle_leave,
+	pointer_handle_motion,
+	pointer_handle_button
+};
+
+static void
+keyboard_handle_keymap( void *data, struct wl_keyboard *keyboard,
+                        uint32_t format, int fd, uint32_t size )
+{
+}
+
+static void
+keyboard_handle_enter( void *data, struct wl_keyboard *keyboard,
+                       uint32_t serial, struct wl_surface *surface,
+                       struct wl_array *keys )
+{
+}
+
+static void
+keyboard_handle_leave( void *data, struct wl_keyboard *keyboard,
+                       uint32_t serial, struct wl_surface *surface )
+{
+}
+
+/* from linux_input systme module */
+static int
+translate_key( unsigned short code )
+{
+     if (code < D_ARRAY_SIZE( basic_keycodes ))
+          return basic_keycodes[code];
+
+     if (code >= KEY_OK)
+          if (code - KEY_OK < D_ARRAY_SIZE( ext_keycodes ))
+               return ext_keycodes[code-KEY_OK];
+
+     return DIKI_UNKNOWN;
+}
+
+static void
+keyboard_handle_key( void *data, struct wl_keyboard *keyboard,
+                     uint32_t serial, uint32_t time, uint32_t key,
+                     uint32_t state )
+{
+     DFBInputEvent event;
+
+	if (!wayland_context->shell)
+		return;
+
+     int symbol = translate_key( key );
+
+     if (symbol == DIKI_UNKNOWN)
+          return;
+
+     event.type = 0;
+
+     if (state == WL_KEYBOARD_KEY_STATE_PRESSED)
+          event.type = DIET_KEYPRESS;
+     if (state == WL_KEYBOARD_KEY_STATE_RELEASED)
+          event.type = DIET_KEYRELEASE;
+
+     if (DFB_KEY_TYPE(symbol) == DIKT_IDENTIFIER) {
+          event.flags = DIEF_KEYID;
+          event.key_id = symbol;
+     } else {
+          event.flags = DIEF_KEYSYMBOL;
+          event.key_symbol = symbol;
+     }
+
+     event.flags |= DIEF_KEYCODE;
+     event.key_code = key;
+
+     if (event.type)
+          dfb_input_dispatch( wayland_context->input_device, &event );
+}
+
+static void
+keyboard_handle_modifiers( void *data, struct wl_keyboard *keyboard,
+                           uint32_t serial, uint32_t mods_depressed,
+                           uint32_t mods_latched, uint32_t mods_locked,
+                           uint32_t group )
+{
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+     keyboard_handle_keymap,
+     keyboard_handle_enter,
+     keyboard_handle_leave,
+     keyboard_handle_key,
+     keyboard_handle_modifiers,
+};
+
+static void
+seat_handle_capabilities( void *data, struct wl_seat *seat,
+                          enum wl_seat_capability caps )
+{
+     struct wayland_context *d = data;
+
+     if ((caps & WL_SEAT_CAPABILITY_POINTER) && !d->pointer) {
+          d->pointer = wl_seat_get_pointer( seat );
+          wl_pointer_add_listener( d->pointer, &pointer_listener, d );
+     } else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && d->pointer) {
+          wl_pointer_destroy( d->pointer );
+          d->pointer = NULL;
+     }
+
+     if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !d->keyboard) {
+          d->keyboard = wl_seat_get_keyboard( seat );
+          wl_keyboard_add_listener( d->keyboard, &keyboard_listener, d );
+     } else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && d->keyboard) {
+          wl_keyboard_destroy( d->keyboard );
+          d->keyboard = NULL;
+     }
+}
+
+static const struct wl_seat_listener seat_listener = {
+     seat_handle_capabilities,
+};
+
+static void
+shm_format(void *data, struct wl_shm *wl_shm, uint32_t format)
+{
+	struct wayland_context *d = data;
+
+     /* handle WL_SHM_FORMAT_ARGB8888 separately in create_shm_buffer(). */
+     if (format)
+          fusion_vector_add( &d->shm_formats, (void*)format );
+}
+
+static const struct wl_shm_listener shm_listener = {
+	shm_format
+};
+
+static void
+registry_handle_global( void *data, struct wl_registry *registry,
+                        uint32_t name, const char *interface, uint32_t version )
+{
+     struct wayland_context *d = data;
+
+     if (strcmp( interface, "wl_compositor" ) == 0) {
+          d->compositor = wl_registry_bind( registry, name,
+                                            &wl_compositor_interface, 1 );
+     } else if (strcmp( interface, "wl_shell" ) == 0) {
+          d->shell = wl_registry_bind( registry, name, &wl_shell_interface, 1 );
+     } else if (strcmp( interface, "wl_seat" ) == 0) {
+          d->seat = wl_registry_bind( registry, name, &wl_seat_interface, 1 );
+          wl_seat_add_listener(d->seat, &seat_listener, d);
+     } else if (strcmp( interface, "wl_shm" ) == 0) {
+          d->shm = wl_registry_bind( registry, name, &wl_shm_interface, 1 );
+          wl_shm_add_listener( d->shm, &shm_listener, d );
+     }
+}
+
+static void
+registry_handle_global_remove( void *data, struct wl_registry *registry,
+                               uint32_t name )
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+     registry_handle_global,
+     registry_handle_global_remove
+};
+
+#define ARRAY_LENGTH(a) (sizeof (a) / sizeof (a)[0])
+
+static int
+handle_display_event(struct epoll_event *ev)
+{
+     uint32_t events  = ev->events;
+
+	struct epoll_event ep;
+	int ret;
+
+     if (events & EPOLLERR || events & EPOLLHUP)
+          return -1;
+
+	if (events & EPOLLIN) {
+		ret = wl_display_dispatch( wayland_context->display );
+          if (ret)
+			return ret;
+	}
+
+	if (events & EPOLLOUT) {
+		ret = wl_display_flush( wayland_context->display );
+		if (ret == 0) {
+			ep.events = EPOLLIN | EPOLLERR | EPOLLHUP;
+			ep.data.ptr = wayland_context;
+               ep.data.fd = wayland_context->display_fd;
+			epoll_ctl( wayland_context->epoll_fd, EPOLL_CTL_MOD,
+                          wayland_context->display_fd, &ep );
+		} else if (ret == -1 && errno != EAGAIN)
+               return -1;
+	}
+
+     return 0;
+}
+
+static void* wayland_dispatch_thread( DirectThread *thread, void *arg )
+{
+     int ret = 0;
+     int count;
+     int schedule_update = false;
+
+     D_DEBUG_AT( Wayland_Primary, "%s()\n", __FUNCTION__ );
+
+     while (wayland_context->dispatch_running && ret >= 0) {
+          struct epoll_event ep[128];
+
+          if (schedule_update) {
+               if (wayland_context->buffer[0].buffer) {
+                    wl_surface_attach( wayland_context->surface,
+                                       wayland_context->buffer[0].buffer, 0, 0 );
+                    wl_surface_damage( wayland_context->surface, 0, 0,
+                                       wayland_context->width, wayland_context->height );
+                    wl_surface_commit( wayland_context->surface );
+               }
+               schedule_update = false;
+          }
+
+		wl_display_dispatch_pending( wayland_context->display );
+
+          if (!wayland_context->dispatch_running)
+               break;
+
+          ret = wl_display_flush( wayland_context->display );
+          if (ret < 0 && errno == EAGAIN) {
+               ep[0].events = EPOLLIN | EPOLLOUT | EPOLLERR | EPOLLHUP;
+			ep[0].data.ptr = wayland_context;
+               ep[0].data.fd = wayland_context->display_fd;
+			epoll_ctl( wayland_context->epoll_fd, EPOLL_CTL_MOD,
+                          wayland_context->display_fd, &ep[0] );
+               ret = 0; /* not an error */
+          } else if (ret < 0)
+               break;
+
+          count = epoll_wait( wayland_context->epoll_fd,
+                              ep, ARRAY_LENGTH(ep), -1 );
+
+          for (int i = 0; i < count; i++) {
+               if (ep[i].data.fd == wayland_context->timer_fd) {
+                    uint64_t value;
+                    read(wayland_context->timer_fd, &value, sizeof value);
+                    if (wayland_context->config.buffermode == DLBM_FRONTONLY)
+                         schedule_update = true; /* coalesce updates */
+               } else {
+                    ret = handle_display_event( &ep[i] );
+               }
+          }
+     }
+
+     D_DEBUG_AT( Wayland_Primary, "%s() -> Exiting\n", __FUNCTION__ );
+
+     return NULL;
+}
+
+static DFBResult wayland_session_open( void )
+{
+     fusion_vector_init( &wayland_context->shm_formats, 32,
+                         dfb_core_shmpool_data( NULL) );
+
+     wayland_context->epoll_fd = os_epoll_create_cloexec();
+     if (wayland_context->epoll_fd < 0)
+          goto error;
+
+     wayland_context->display = wl_display_connect( NULL );
+     if (!wayland_context->display)
+          goto error;
+
+	wayland_context->registry =
+               wl_display_get_registry( wayland_context->display );
+     if (!wayland_context->registry)
+          goto error;
+
+	wl_registry_add_listener( wayland_context->registry,
+                               &registry_listener, wayland_context );
+
+	wl_display_dispatch( wayland_context->display );
+
+     if (!wayland_context->shell)
+          goto error;
+
+     wayland_context->surface =
+               wl_compositor_create_surface( wayland_context->compositor );
+
+     wayland_context->shell_surface =
+               wl_shell_get_shell_surface( wayland_context->shell,
+                                           wayland_context->surface );
+     wl_shell_surface_add_listener( wayland_context->shell_surface,
+                                    &shell_surface_listener, wayland_context);
+
+     wl_shell_surface_set_title( wayland_context->shell_surface, "DirectFB" );
+     wl_shell_surface_set_toplevel( wayland_context->shell_surface );
+
+     struct wl_callback *callback = wl_display_sync( wayland_context->display );
+     wl_callback_add_listener( callback, &configure_callback_listener, NULL );
+
+     wl_display_roundtrip( wayland_context->display );
+
+     wayland_context->dispatch_running = true;
+
+     wayland_context->display_fd = wl_display_get_fd( wayland_context->display );
+
+     struct epoll_event ep;
+     ep.events = EPOLLIN | EPOLLERR | EPOLLHUP;
+     ep.data.ptr = wayland_context;
+     ep.data.fd = wayland_context->display_fd;
+
+	epoll_ctl( wayland_context->epoll_fd, EPOLL_CTL_ADD,
+                wayland_context->display_fd, &ep );
+
+     wayland_context->dispatch_thread =
+               direct_thread_create( DTT_DEFAULT, wayland_dispatch_thread,
+                                     wayland_context, "Wayland Dispatch" );
+
+     return DFB_OK;
+
+error:
+     return DFB_FAILURE;
+}
+
+static void wayland_session_close( void )
+{
+     close( wayland_context->timer_fd );
+
+     wayland_context->dispatch_running = false;
+
+     if (wayland_context->dispatch_thread) {
+          direct_thread_cancel( wayland_context->dispatch_thread );
+          direct_thread_join( wayland_context->dispatch_thread );
+          direct_thread_destroy( wayland_context->dispatch_thread );
+     }
+
+     close( wayland_context->epoll_fd );
+
+     if (wayland_context->buffer[0].buffer)
+          wl_buffer_destroy( wayland_context->buffer[0].buffer );
+     if (wayland_context->buffer[1].buffer)
+          wl_buffer_destroy( wayland_context->buffer[1].buffer );
+
+     if (wayland_context->surface)
+          wl_surface_destroy(wayland_context->surface);
+
+     if (wayland_context->shm)
+          wl_shm_destroy(wayland_context->shm);
+
+	if (wayland_context->callback)
+		wl_callback_destroy(wayland_context->callback);
+
+	if (wayland_context->compositor)
+		wl_compositor_destroy(wayland_context->compositor);
+
+	if (wayland_context->registry)
+          wl_registry_destroy(wayland_context->registry);
+
+     if (wayland_context->display) {
+          wl_display_flush(wayland_context->display);
+          wl_display_disconnect(wayland_context->display);
+     }
+
+     fusion_vector_destroy( &wayland_context->shm_formats );
+
+     sem_destroy( &wayland_context->flip_semaphore );
+}
+
+static DisplayLayerFuncs primaryLayerFuncs = {
+     .LayerDataSize      = primaryLayerDataSize,
+     .RegionDataSize     = primaryRegionDataSize,
+     .InitLayer          = primaryInitLayer,
+
+     .TestRegion         = primaryTestRegion,
+     .AddRegion          = primaryAddRegion,
+     .SetRegion          = primarySetRegion,
+     .RemoveRegion       = primaryRemoveRegion,
+     .FlipRegion         = primaryFlipRegion,
+};
+
+static ScreenFuncs primaryScreenFuncs = {
+     .InitScreen    = primaryInitScreen,
+     .GetScreenSize = primaryGetScreenSize,
+};
+
+static DFBResult
+system_initialize( CoreDFB *core, void **data )
+{
+     DFBResult            ret;
+     CoreScreen          *screen;
+
+     D_ASSERT( wayland_context == NULL );
+
+     wayland_context = D_CALLOC( 1, sizeof(struct wayland_context) );
+     if (!wayland_context)
+          return D_OOM();
+
+     wayland_context->core = core;
+
+     ret = wayland_session_open();
+     if (ret) {
+          D_FREE( wayland_context );
+          wayland_context = NULL;
+          return ret;
+     }
+
+     dfb_surface_pool_initialize( core, &WaylandSurfacePoolFuncs,
+                                  &wayland_context->pool );
+
+     screen = dfb_screens_register( NULL, NULL, &primaryScreenFuncs );
+
+     dfb_layers_register( screen, NULL, &primaryLayerFuncs );
+
+     *data = wayland_context;
+
+     return DFB_OK;
+}
+
+static DFBResult
+system_join( CoreDFB *core, void **data )
+{
+     DFBResult   ret;
+     CoreScreen *screen;
+
+     D_ASSERT( wayland_context == NULL );
+
+     wayland_context = D_CALLOC( 1, sizeof(struct wayland_context) );
+     if (!wayland_context)
+          return D_OOM();
+
+     wayland_context->core = core;
+
+     ret = wayland_session_open();
+     if (ret) {
+          D_FREE( wayland_context );
+          wayland_context = NULL;
+          return ret;
+     }
+
+     /* not joining any existing pool, as this is a separate process with
+        it's own wl_shm buffer objects bound to the display layer. */
+     dfb_surface_pool_initialize( core, &WaylandSurfacePoolFuncs,
+                                  &wayland_context->pool );
+
+     screen = dfb_screens_register( NULL, NULL, &primaryScreenFuncs );
+
+     dfb_layers_register( screen, NULL, &primaryLayerFuncs );
+
+     *data = wayland_context;
+
+     return DFB_OK;
+}
+
+static DFBResult
+system_shutdown( bool emergency )
+{
+     D_ASSERT( wayland_context != NULL );
+
+     wayland_session_close();
+
+     dfb_surface_pool_destroy( wayland_context->pool );
+
+     D_FREE( wayland_context );
+     wayland_context = NULL;
+
+     return DFB_OK;
+}
+
+static DFBResult
+system_leave( bool emergency )
+{
+     D_ASSERT( wayland_context != NULL );
+
+     wayland_session_close();
+
+     dfb_surface_pool_destroy( wayland_context->pool );
+
+     D_FREE( wayland_context );
+     wayland_context = NULL;
+
+     return DFB_OK;
+}
diff --git a/systems/wayland/wayland.h b/systems/wayland/wayland.h
new file mode 100644
index 0000000..9e80343
--- /dev/null
+++ b/systems/wayland/wayland.h
@@ -0,0 +1,82 @@
+/*
+   (c) Copyright 2015 STMicroelectronics, L&D
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __CORE__WAYLAND_H__
+#define __CORE__WAYLAND_H__
+
+#include <asm/types.h>
+
+#include <semaphore.h>
+
+#include <core/coretypes.h>
+#include <core/layers_internal.h>
+#include <core/system.h>
+
+#include <fusion/vector.h>
+
+#include <wayland-client.h>
+
+struct display_buffer {
+     struct wl_buffer *buffer;
+     void             *data;
+     int               pitch;
+     int               size;
+};
+
+struct wayland_context {
+     CoreDFB                  *core;
+
+     uint32_t                  width;
+     uint32_t                  height;
+     DFBSurfacePixelFormat     format;
+     DFBDisplayLayerBufferMode mode;
+
+     CoreSurfacePool          *pool;
+
+     CoreLayerRegionConfig     config;
+
+     struct wl_display        *display;
+     struct wl_registry       *registry;
+     struct wl_compositor     *compositor;
+     struct wl_shell          *shell;
+     struct wl_seat           *seat;
+     struct wl_pointer        *pointer;
+     struct wl_keyboard       *keyboard;
+     struct wl_shm            *shm;
+     struct wl_surface        *surface;
+     struct wl_callback       *callback;
+     struct wl_shell_surface  *shell_surface;
+     struct display_buffer     buffer[3];
+
+     FusionVector              shm_formats;
+
+     DirectThread             *dispatch_thread;
+     bool                      dispatch_running; /* aborts execution, for debug only */
+     int                       display_fd;
+     int                       epoll_fd;
+
+     sem_t                     flip_semaphore;
+     int                       timer_fd; /* for DLBM_FRONTONLY updates */
+
+     CoreInputDevice           *input_device;
+};
+
+#endif
diff --git a/systems/wayland/wayland_surface_pool.c b/systems/wayland/wayland_surface_pool.c
new file mode 100644
index 0000000..37070f7
--- /dev/null
+++ b/systems/wayland/wayland_surface_pool.c
@@ -0,0 +1,323 @@
+/*
+   (c) Copyright 2015  STMicroelectronics R&D
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Ilyes Gouta <ilyes.gouta@st.com>
+
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjälä <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <direct/debug.h>
+#include <direct/mem.h>
+
+#include <core/core.h>
+#include <core/surface_pool.h>
+#include <core/system.h>
+#include <misc/conf.h>
+
+#include "wayland.h"
+
+D_DEBUG_DOMAIN( Wayland_Surfaces, "Wayland/Surfaces", "Wayland Surface Pool" );
+
+extern struct wayland_context *wayland_context;
+
+typedef struct {
+     int         magic;
+} WaylandPoolData;
+
+typedef struct {
+     int             magic;
+     struct wayland_context *wayland_context;
+} WaylandPoolLocalData;
+
+typedef struct {
+     int         magic;
+     void       *addr;
+     int         pitch;
+     int         size;
+} WaylandAllocationData;
+
+static int
+WaylandPoolDataSize( void )
+{
+     return sizeof( WaylandPoolData );
+}
+
+static int
+WaylandPoolLocalDataSize( void )
+{
+     return sizeof( WaylandPoolLocalData );
+}
+
+static int
+WaylandAllocationDataSize( void )
+{
+     return sizeof( WaylandAllocationData );
+}
+
+static DFBResult
+WaylandInitPool( CoreDFB                    *core,
+                 CoreSurfacePool            *pool,
+                 void                       *pool_data,
+                 void                       *pool_local,
+                 void                       *system_data,
+                 CoreSurfacePoolDescription *ret_desc )
+{
+     WaylandPoolData *data = pool_data;
+     WaylandPoolLocalData *local = pool_local;
+
+     D_DEBUG_AT( Wayland_Surfaces, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_ASSERT( ret_desc != NULL );
+
+     ret_desc->caps              = CSPCAPS_VIRTUAL;
+     ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+     ret_desc->access[CSAID_GPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+     ret_desc->types             = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
+     ret_desc->priority          = CSPP_DEFAULT;
+
+     /* For hardware layers */
+     ret_desc->access[CSAID_LAYER0] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER1] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER2] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER3] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER4] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER5] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER6] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER7] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER8] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER9] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER10] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER11] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER12] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER13] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER14] = CSAF_READ;
+     ret_desc->access[CSAID_LAYER15] = CSAF_READ;
+
+     snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "Wayland Memory" );
+
+     D_MAGIC_SET( data, WaylandPoolData );
+     D_MAGIC_SET( local, WaylandPoolLocalData );
+
+     local->wayland_context = wayland_context;
+
+     return DFB_OK;
+}
+
+static DFBResult
+WaylandJoinPool( CoreDFB                    *core,
+                 CoreSurfacePool            *pool,
+                 void                       *pool_data,
+                 void                       *pool_local,
+                 void                       *system_data )
+{
+     WaylandPoolData *data = pool_data;
+     WaylandPoolLocalData *local = pool_local;
+
+     D_DEBUG_AT( Wayland_Surfaces, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+
+     D_MAGIC_SET( data, WaylandPoolData );
+     D_MAGIC_SET( local, WaylandPoolLocalData );
+
+     local->wayland_context = wayland_context;
+
+     return DFB_OK;
+}
+
+static DFBResult
+WaylandDestroyPool( CoreSurfacePool *pool,
+                    void            *pool_data,
+                    void            *pool_local )
+{
+     D_DEBUG_AT( Wayland_Surfaces, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+
+     return DFB_OK;
+}
+
+static DFBResult
+WaylandLeavePool( CoreSurfacePool *pool,
+                  void            *pool_data,
+                  void            *pool_local )
+{
+     D_DEBUG_AT( Wayland_Surfaces, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+
+     return DFB_OK;
+}
+
+static DFBResult
+WaylandTestConfig( CoreSurfacePool         *pool,
+                   void                    *pool_data,
+                   void                    *pool_local,
+                   CoreSurfaceBuffer       *buffer,
+                   const CoreSurfaceConfig *config )
+{
+     CoreSurface        *surface;
+     WaylandPoolLocalData *local = pool_local;
+
+     D_DEBUG_AT( Wayland_Surfaces, "%s( %p )\n", __FUNCTION__, buffer );
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_MAGIC_ASSERT( local, WaylandPoolLocalData );
+     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
+
+     surface = buffer->surface;
+     D_MAGIC_ASSERT( surface, CoreSurface );
+
+     /* only IDirectFBDisplayLayer objects are accepted */
+     if (surface->type & CSTF_LAYER)
+          return DFB_OK;
+
+     return DFB_TEMPUNAVAIL;
+}
+
+static DFBResult
+WaylandAllocateBuffer( CoreSurfacePool       *pool,
+                       void                  *pool_data,
+                       void                  *pool_local,
+                       CoreSurfaceBuffer     *buffer,
+                       CoreSurfaceAllocation *allocation,
+                       void                  *alloc_data )
+{
+     CoreSurface         *surface;
+     WaylandPoolLocalData *local = pool_local;
+     WaylandAllocationData *alloc = alloc_data;
+
+     D_DEBUG_AT( Wayland_Surfaces, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
+     D_ASSERT( alloc != NULL );
+
+     surface = buffer->surface;
+     D_MAGIC_ASSERT( surface, CoreSurface );
+
+     D_MAGIC_SET( alloc, WaylandAllocationData );
+
+     D_ASSERT( surface->type & CSTF_LAYER );
+
+     struct display_buffer *display_buffer =
+               &local->wayland_context->buffer[allocation->index];
+
+     allocation->size = display_buffer->size;
+
+     return DFB_OK;
+}
+
+static DFBResult
+WaylandDeallocateBuffer( CoreSurfacePool       *pool,
+                       void                  *pool_data,
+                       void                  *pool_local,
+                       CoreSurfaceBuffer     *buffer,
+                       CoreSurfaceAllocation *allocation,
+                       void                  *alloc_data )
+{
+     WaylandAllocationData *alloc = alloc_data;
+
+     D_DEBUG_AT( Wayland_Surfaces, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_MAGIC_ASSERT( alloc, WaylandAllocationData );
+
+     D_MAGIC_CLEAR( alloc );
+
+     return DFB_OK;
+}
+
+static DFBResult
+WaylandLockBuffer( CoreSurfacePool       *pool,
+                   void                  *pool_data,
+                   void                  *pool_local,
+                   CoreSurfaceAllocation *allocation,
+                   void                  *alloc_data,
+                   CoreSurfaceBufferLock *lock )
+{
+     WaylandPoolLocalData *local = pool_local;
+     WaylandAllocationData *alloc = alloc_data;
+
+     D_DEBUG_AT( Wayland_Surfaces, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+     D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );
+     D_MAGIC_ASSERT( alloc, WaylandAllocationData );
+
+     struct display_buffer *display_buffer =
+               &local->wayland_context->buffer[allocation->index];
+
+     lock->addr  = display_buffer->data;
+     lock->pitch = display_buffer->pitch;
+
+     return DFB_OK;
+}
+
+static DFBResult
+WaylandUnlockBuffer( CoreSurfacePool       *pool,
+                     void                  *pool_data,
+                     void                  *pool_local,
+                     CoreSurfaceAllocation *allocation,
+                     void                  *alloc_data,
+                     CoreSurfaceBufferLock *lock )
+{
+     WaylandAllocationData *alloc = alloc_data;
+
+     D_DEBUG_AT( Wayland_Surfaces, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+     D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );
+     D_MAGIC_ASSERT( alloc, WaylandAllocationData );
+
+     (void) alloc;
+
+     return DFB_OK;
+}
+
+const SurfacePoolFuncs WaylandSurfacePoolFuncs = {
+     .PoolDataSize       = WaylandPoolDataSize,
+     .PoolLocalDataSize  = WaylandPoolLocalDataSize,
+     .AllocationDataSize = WaylandAllocationDataSize,
+
+     .InitPool           = WaylandInitPool,
+     .JoinPool           = WaylandJoinPool,
+     .DestroyPool        = WaylandDestroyPool,
+     .LeavePool          = WaylandLeavePool,
+
+     .TestConfig         = WaylandTestConfig,
+     .AllocateBuffer     = WaylandAllocateBuffer,
+     .DeallocateBuffer   = WaylandDeallocateBuffer,
+
+     .Lock               = WaylandLockBuffer,
+     .Unlock             = WaylandUnlockBuffer,
+};
+
diff --git a/systems/x11/surfacemanager.c b/systems/x11/surfacemanager.c
index 24c593b..e3028be 100644
--- a/systems/x11/surfacemanager.c
+++ b/systems/x11/surfacemanager.c
@@ -270,7 +270,7 @@ DFBResult dfb_surfacemanager_displace( CoreDFB           *core,
           D_MAGIC_ASSERT( chunk, Chunk );
 
           allocation = chunk->allocation;
-          if (allocation) {
+          if (allocation && allocation->buffer) {
                CoreSurfaceBuffer *other;
                int                size, locks;
 
diff --git a/tests/dfbtest_flip.c b/tests/dfbtest_flip.c
index a88c3c9..9cc9a25 100644
--- a/tests/dfbtest_flip.c
+++ b/tests/dfbtest_flip.c
@@ -180,7 +180,7 @@ timings_get( Timings   *timings,
 
           //printf( "%4zu: %4zu  %lld  (%lld)   count %zu\n", i, index, stamp, now, timings->counts[ index ] );
 
-          if (stamp >= now - 800000) {
+          if (stamp >= now - 1200000) {
                ret_stamps[num] = stamp;
                ret_counts[num] = timings->counts[ index ];
 
@@ -192,12 +192,12 @@ timings_get( Timings   *timings,
 }
 
 static void
-draw_timings( IDirectFBSurface *dest )
+draw_timings( IDirectFBSurface *dest, long long base )
 {
      long long now = direct_clock_get_time( DIRECT_CLOCK_MONOTONIC );
      long long stamps[1000];
      size_t    counts[1000];
-     size_t    num, i, n, count0 = 0;
+     size_t    num, i, n;
 
      for (i=0; i<D_ARRAY_SIZE(m_timings) && m_timings[i].name; i++) {
           timings_get( &m_timings[i], now, stamps, counts, &num );
@@ -207,15 +207,13 @@ draw_timings( IDirectFBSurface *dest )
 
           dest->DrawString( dest, m_timings[i].name, -1, 20, 200 + i*40 + 2, DSTF_TOPLEFT );
 
-          if (i == 0)
-               count0 = counts[0];
-
           for (n=0; n<num; n++) {
-               size_t count = counts[n] - count0;
-
-               dest->SetColor( dest, 100 * count, 133 * count, 199 * count, 0xff );
+               size_t count = counts[n];
 
-               dest->FillRectangle( dest, 200 + (now - stamps[n]) / 1000LL, 200 + i*40, 1, 40 );
+               if ((stamps[n] - base) >= 0) {
+                    dest->SetColor( dest, 100 * count, 133 * count, 199 * count, 0xff );
+                    dest->FillRectangle( dest, 200 + (stamps[n] - base) / 1000LL, 200 + i*40, 1, 40 );
+               }
           }
      }
 }
@@ -335,6 +333,9 @@ main( int argc, char *argv[] )
 
      long long prev = 0;
 
+     long long base_stamp;
+     int cursor_now = 0, cursor_prev = 0;
+
      while (num <= 0 || count < num) {
 //          long long t1, t2;
           long long base, frame_time = 0;
@@ -351,26 +352,32 @@ main( int argc, char *argv[] )
                if (count % 120 == 0)
                     D_INFO( "Got frame time %lld (now %lld) with advance %lld (us in future)\n", frame_time, now, frame_time - now );
 
-               base = frame_time * 5 / 17000;
+               base = frame_time / 1000;
           }
           else if (frames) {
                base = count * 5;
           }
           else {
-               base = (direct_clock_get_abs_millis() - t0) * 5 / 17;
+               base = (direct_clock_get_abs_millis() - t0);
           }
 
           timings_add( "frametime", frame_time, count );
 
           dest->Clear( dest, 0x33, 0x33, 0x33, 0xff );
 
+          cursor_now = base % (desc.width - 100);
+
+          if (!cursor_prev || cursor_now < cursor_prev)
+               base_stamp = direct_clock_get_time( DIRECT_CLOCK_MONOTONIC );
+
+          cursor_prev = cursor_now;
 
-          draw_timings( dest );
+          draw_timings( dest, base_stamp );
 
 
           dest->SetColor( dest, 0xff, 0xff, 0xff, 0xff );
           //dest->FillRectangle( dest, base % (desc.width - 100), 100, 100, 10000 );
-          dest->FillRectangle( dest, base % (desc.width - 100), 0, 100, 20000 );
+          dest->FillRectangle( dest, 200 + cursor_now, 0, 100, 20000 );
 
 
           dest->SetColor( dest, 0x33, 0x55, 0xff, 0xff );
diff --git a/wm/default/default.c b/wm/default/default.c
index 0155cf4..a8a99b2 100644
--- a/wm/default/default.c
+++ b/wm/default/default.c
@@ -3416,7 +3416,7 @@ wm_initialize( CoreDFB *core, void *wm_data, void *shared_data )
      DFBResult  ret;
      WMData    *wmdata = wm_data;
 
-     fusion_skirmish_init2( &wmdata->update_skirmish, "WM/Update", dfb_core_world(core), fusion_config->secure_fusion );
+     fusion_skirmish_init2( &wmdata->update_skirmish, "WM/Update", dfb_core_world(core), true );
 
      ret = local_init( wm_data, core );
      if (ret)
@@ -3429,11 +3429,16 @@ static DFBResult
 wm_join( CoreDFB *core, void *wm_data, void *shared_data )
 {
      DFBResult ret;
+     WMData    *wmdata = wm_data;
+
+     fusion_skirmish_init2( &wmdata->update_skirmish, "WM/Update", dfb_core_world(core), true );
 
      ret = local_init( wm_data, core );
      if (ret)
           return ret;
 
+     local_ref( wm_data );
+
      return ret;
 }
 
@@ -3452,6 +3457,8 @@ wm_shutdown( bool emergency, void *wm_data, void *shared_data )
 static DFBResult
 wm_leave( bool emergency, void *wm_data, void *shared_data )
 {
+     local_unref( wm_data );
+
      local_deinit( wm_data );
 
      return DFB_OK;
diff --git a/wm/sawman/sawman_wm.c b/wm/sawman/sawman_wm.c
index 3de78aa..005140e 100644
--- a/wm/sawman/sawman_wm.c
+++ b/wm/sawman/sawman_wm.c
@@ -1267,7 +1267,7 @@ wm_initialize( CoreDFB *core, void *wm_data, void *shared_data )
      WMData    *data   = wm_data;
      SaWMan    *sawman = shared_data;
 
-     fusion_skirmish_init2( &data->update_skirmish, "WM/Update", dfb_core_world(core), fusion_config->secure_fusion );
+     fusion_skirmish_init2( &data->update_skirmish, "WM/Update", dfb_core_world(core), true );
 
      ret = local_init( data, sawman, core );
      if (ret)
@@ -1283,10 +1283,14 @@ wm_join( CoreDFB *core, void *wm_data, void *shared_data )
      WMData    *data   = wm_data;
      SaWMan    *sawman = shared_data;
 
+     fusion_skirmish_init2( &data->update_skirmish, "WM/Update", dfb_core_world(core), true );
+
      ret = local_init( data, sawman, core );
      if (ret)
           return ret;
 
+     local_ref( data );
+
      return sawman_join( sawman, data->world, &data->process );
 }
 
@@ -1309,6 +1313,8 @@ wm_leave( bool emergency, void *wm_data, void *shared_data )
      WMData *data   = wm_data;
      SaWMan *sawman = shared_data;
 
+     local_unref( data );
+
      local_deinit( data );
 
      return sawman_leave( sawman, data->world );
